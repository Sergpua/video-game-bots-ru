# Пример бота для 2 Diablo 2

## Обзор игры Diablo 2

Мы узнали достаточно, чтобы написать простого внутриигрового бота. Он будет автоматизировать некоторые действия в известной игре Diablo 2. Её игровой процесс типичен для жанра RPG: игрок должен выполнять квесты, убивать монстров и развивать своего персонажа.

Наш бот будет следить за состоянием игрового персонажа. Как только один из его параметров (например здоровье) опустится ниже порогового значения, бот будет выполнять некоторое действие (например использовать зелье лечения).

Перед тем как начать разработку бота, следует подробно изучить интерфейс игры. Скриншот Diablo 2 приведён на иллюстрации 3-15. В центре экрана находится игровой персонаж. Слева и справа от него находятся монстры, один из которых выделен курсором мыши. В нижней части экрана находится панель управления. На ней есть четыре слота с зельями лечения, которые привязаны к горячим клавишам. Наш бот будет использовать предметы в этих слотах при необходимости.

![Интерфейс Diablo 2](diablo-interface.png)

**Иллюстрация 3-15.** *Скриншот окна Diablo 2*

Все параметры игрового персонажа приведены на иллюстрации 3-16. В верхней части левого окна находится общая информация о нём: имя Kain, класс Paladin, уровень 70, очки опыта 285,160,782. Ниже указаны параметры персонажа, влияющие на игровую механику. Например, параметр “Strength” определяет урон, наносимый монстрам при ударе.

![Игровой персонаж в Diablo 2](diablo-player.png)

**Иллюстрация 3-16.** *Параметры игрового персонажа*

Правое окно на иллюстрации 3-16 отображает дерево способностей персонажа. Способности позволяют наносить больше урона монстрам или увеличивать параметры персонажа. Каждая способность имеет свой уровень, который опредеяет её эффективность. Более подробная информация о параметрах и способностях персонажа достпна на [Wiki](diablo.gamepedia.com/Classes_(Diablo_II)).

В Diablo 2 есть однопользовательский и многопользовательский режимы игры. Мы будем рассматривать только однопользовательский. В нём вы сможете останавливать игру под отладчиком в любой момент на неограниченное время, чтобы исследовать память её процесса. В многопользовательском режиме это не будет работать из-за таймаутов. Если игровой клиент не отвечает какое-то время, сервер его отключит.

Чтобы протестировать нашего бота, вы можете купить игру Diablo 2 на [официальном сайте](eu.shop.battle.net/en-b/product/diablo-ii) разработчика. Либо вы можете воспользоваться бесплатным клоном игры под названием [Flaire](http://flarerpg.org). В этом случае вам придётся самостоятельно разработать бота, следуя рассмотренным далее приёмам. Diablo 2 отличается от своего клона интерфейсом и сложностью. Память процесса оригинальной игры намного сложнее анализировать из-за большого количество вспомогательных библиотек.

## Задачи бота

Прежде всего, стоит чётко определить наши цели. Мы не собираемся взламывать игру, то есть нарушать её правила и вмешиваться в механику игрового процесса. Примеры подобных взломов вы можете найти в статьях Jan Miller:

* extreme-gamerz.org/diablo2/viewdiablo2/hackingdiablo2

* www.battleforums.com/threads/howtohackd2-edition-2.111214

Наш бот не нарушает правила игры. Он реагирует на изменение состояния персонажа и симулирует действие. При этом состояние всех игровых объектов меняется согласно правилам. Процесс Diablo 2 продолжает работать по своим оригинальным алгоритмам так же, как если бы действия совершал игрок.

Мы рассмотрели параметры игрового персонажа. Из них проще всего контролировать уровень здоровья. Когда персонаж получает урон от монстров, здоровье уменьшается. При использовании зелья лечения - увеличивается. Учитывая эту механику, наш бот может работать по следующему алгоритму:

1. Прочитать текущий уровень здоровья игрового персонажа.

2. Сравнить этот уровень с пороговоым значением.

3. Если здоровье меньше порога, использовать зелье лечения.

Этот простой алгоритм позволит игровому персонажу выживать до тех пор, пока у него остаются зелья лечения. Однако, несмотря на его простоту, для реализации бота нам придётся детально изучить память процесса Diablo 2.

## Исследование памяти процесса Diablo 2

Мы готовы приступить к исследованию памяти процесса Diablo 2. Наша задача - найти переменную, котоаря хранит значение текущего здоровья персонажа.

Выполним предварительную настройку окна Diablo 2, чтобы с ним было удобнее работать. Если вы запустите игру с найстройками по-умолчанию, она будет работать в полноэкранном режиме. Это неудобно, если приходится часто переключаться на отладчик или сканер памяти.

Чтобы запустить игру в оконном режиме, выполните следующие действия:

1. Щёлкните правой кнопкой мыши по иконке "Diablo II" на рабочем столе. В открывшемся меню выберите пункт "Properties".

2. В диалоге "Properties" перейдите на вкладку "Shortcut".

3. В поле "Target" добавить параметр "-w". В результате полная команда запуска приложения будет выглядеть так:
```
"C:\DiabloII\Diablo II.exe" -w
```
Если вы запустите Diablo 2 через настроенную иконку на рабочем столе, приложение откроется в оконном режиме. Чтобы начать игру, нажмите кнопку "Single player" в главном меню и создайте нового персонажа.

### Поиск параметров персонажа

Мы ищем уровень здоровья игрового персонажа в памяти процесса Diablo 2. Воспользуемся сканером Cheat Engine. Ведь этот инструмент был разработан именно для подобных задач.

Если вы попробуйте искать уровень здоровья по его текущему значению без предварительной настройки Cheat Engine, поиск не даст результата. Вероятнее всего, после первого сканирования вы получите длинный список предполагаемых адресов. При повторном поиске (кнопка "Next Scan") после изменения уровня здоровья персонажа, список результатов станет пуст.

Прямолинейный подход не заработал. Это совершенно нормально для больших, сложных приложений, как Diablo 2. В памяти процесса хранится очень много игровых объектов, причём параметры некоторых из них совпадают. Мы не знаем, как именно они хранятся в памяти. Поэтому будет разумно сначала изучить этот вопрос. Если мы сможем найти нужный объект в памяти, получить доступ к его параметрам будет очень просто.

Еще раз обратимся к окну с параметрами игрового персонажа. Значения некоторых из них наверняка уникальны именно для объекта персонажа. Какие именно?

1. **Имя персонажа**
Очень маловероятно, что в игре встретится объект с тем же именем, которое игрок дал своему персонажу. Если это всё-таик произошло, всегда можно создать другого персонажа и дать ему другой имя.

2. **Очки опыта**
Это длинное положительное целочисленное число. Число такого размера редко встречается в нескольких объектах случайно. Если Cheat Engine всё же нашел несколько потенциальных адресов, очки опыта персонажа очень просто увеличить. Просто убейте одного-двух монстров и выполните повторное сканирование памяти кнопкой "Next Scan".

3. **Значение выносливости**
Это так же длинное число, которое определяет, как долго персонаж может быстро двигаться по карте. Его очень просто уменьшить - достаточно перемщать игрового персонажа вне города.

Из всех вариантов, предлагаю искать очки опыта персонажа. Если вы только начали игру, вам нужно убить нескольких монстров, чтобы этот параметр стал больше нуля. Иллюстрация 3-17 демонстрирует окно Cheat Engine с возможным результатом поиска. Сканер нашёл несколько переменных с одинаковым значением. Только некоторые из них относятся к объекту игрового персонажа. Другие могут быть связаны с интерфейсом игры и выводом информации на экран.

![Результат поиска](experience-value.png)

**Иллюстрация 3-17.** *Результаты поиска параметра игрового персонажа*

Следующий шаг - определить, какие из найденных параметров относятся к объекту персонажа. Тип сегмента, в котором они хранятся, может дать подсказку в этом вопросе.

Запустите отладчик WinDbg, подключитесь к работающему процессу Diablo 2 и выполните команду `!address`. Сегменты с найденными параметрами выглядят следующим образом:
```
+ 0`003c0000  0`003e0000  0`00020000  MEM_PRIVATE MEM_COMMIT PAGE_READWRITE <unknown>
+ 0`03840000  0`03850000  0`00010000  MEM_PRIVATE MEM_COMMIT PAGE_READWRITE <unknown>
+ 0`03850000  0`03860000  0`00010000  MEM_PRIVATE MEM_COMMIT PAGE_READWRITE <unknown>
+ 0`04f50000  0`04fd0000  0`00080000  MEM_PRIVATE MEM_COMMIT PAGE_READWRITE <unknown>
```
Отладчик не смог определить тип этих сегментов и указал, что он неизвестен ("unknown"). Мы знаем, что WinDbg умеет корректно определять сегменты стека и динамической памяти. Если тип неизвестен, скорее всего, это не первое и не второе.

Сегменты неизвестного типа может выделять WinAPI функция `VirtualAllocEx`. Чтобы проверить это предположение, можно написать простое тестовое приложение. Вы можете найти его по имени `VirtualAllocEx.cpp` в архиве с примерами для этой книги. Если вы запустите приложение под отладчиком WinDbg и прочитаете его адресное пространство, вы увидите один сегмент с неизвестным типом. Функция `VirtualAllocEx` возвращает базовый адрес выделенного сегмента.

Вернемся к процессу Diablo 2. Все сегменты, хранящие переменные со значением очков опыта персонажа, имеют одинаковый тип. Поэтому мы не сможем их отличить по типу. Это важно, поскольку после перезапуска игры, порядок следования сегментов может измениться. Если мы не можем их отличать, мы не определим сегмент, в котором находится игровой объект персонажа. Размер сегмента тоже не подходит - у двух из них он одинаковый.

Попробуем другой подход. Очевидно, что параметры персонажа меняются, когда игрок совершает действия. Например координата, когда персонаж двигается. Мы можем следить за такими изменениями в области памяти около найденных нами предполагаемых адресов параметра очков опыта. Cheat Engine может отображать изменения в области памяти в реальном времени. Для этого откройте окно Memory Viewer:

1. Выберите один из адресов в списке результатов поиска.

2. Щелкните правой кнопокой мыши по адресу.

3. Выберите пункт "Browse this memory region" в открывшемся меню.

Откроется окно Memory Viewer приведённое на иллюстрации 3-18. Это окно разделено на две части. В верхней части выводится область памяти около выбранного адреса в виде **дизассемблированного кода**. Это значит, что Cheat Engine пытается представить данные в виде инструкций процессора. В нижней части окна отображаются данные той же самой области памяти в шестнадцатеричном формате. Окно Memory Viewer выводит одни и те же данные, но представленные в разном виде.

Нас интересует нижняя половина окна. Данные, соответствующие очкам опыта персонажа, подчеркнуты красным на иллюстрации 3-18. В моём примере персонаж имеет 285161118 очков опыта. Почему последовательность байт "9E 36 FF 10" равна числу 285161118?

Мы запускаем Diablo 2 на процессоре с архитектурой x86, которая имеет **порядок байт от младщего к старшему** (little-endian byte order). Следовательно, значение из окна Memory Viewer нужно перевернуть, чтобы получить правильно число. Таким образом последовательность байт "9E 36 FF 10" превращается в "10 FF 36 9E". Вы можете воспользоваться стандартным приложением Windows Calculator, чтобы сконвертировать 10FF369E в десятичную систему счисления и получить 285161118.

![Memory Viewer](memory-viewer.png)

**Иллюстрация 3-18.** *Окно Memory Viewer сканера Cheat Engine*

Вы можете настроить формат вывода данных в окне Memory Viewer. Для этого щелкните правой кнопкой мыши в любом месте нижней половины окна и выберите пункт "Display Type" в открывшемся меню. Однако, я рекомендую вам пользоваться форматом "Byte hex", как на иллюстрации 3-18. Другие форматы могут вызвать путанницу, потому что объединяют соседние байты в числа. Когда размер искомых чисел неизвестен, их фрагменты могут объединяться неправильно.

Теперь попробуем проследить изменения данных в областях памяти. Для удобства размести окна Memory Viewer и Diablo 2 рядом, но без перекрытия, как изображено на иллюстрации 3-19. Это позволит вам одновременно управлять персонажем и следить за изменениями в памяти.

![Изменения в памяти](memory-inspection.png)

**Иллюстрация 3-19.** *Исследование изменений в памяти процесса Diablo 2*

В окне Memory Viewer, приведённом на иллюстрации 3-19, открыта область памяти около адреса 04FC04A4. Это один из адресов, который мы получили при поиске очков опыта персонажа. Вам нужно исследовать области около каждого из них.

Как мы поймём, что нашли объект игрового персонажа в памяти? Предлагаю простое правило: если объект хранит больше параметров персонажа, чем другие - его информация о персонаже наиболее полная, и нам следует использовать именно его. В моем случае последний адрес (04FC04A4) в списке результатов сканирования Cheat Engine относится к объекту игрового персонажа.

Таблица 3-6 демонстрирует параметры, которые мы обнаружили в объекте.

**Таблица 3-6.** *Найденные параметры игрового объекта*

| Параметр | Адрес | Смещение | Размер | Шестнадцатеричное значение | Десятичное значение |
| -- | -- | -- | -- | -- | -- |
| Здоровье | 04FC0490 | 490 | 2 | 40 01 | 320 |
| Мана | 04FC0492 | 492 | 2 | 9D 01 | 413 |
| Выносливость | 04FC0494 | 494 | 2 | FE 1F | 8190 |
| Координата X | 04FC0498 | 498 | 2 | 37 14 | 5175 |
| Координата Y | 04FC04A0 | 4A0 | 2 | 47 12 | 4679 |
| Очки опыта | 04FC04A4 | 4A4 | 4 | 9E 36 FF 10 | 285161118 |

Эти параметры подчёркнуты красным на иллюстрации 3-19. Чтобы их обнаружить, я выполнил следующие игровые действия:

1. Оставаться на месте и получать урон от атакующего монстра. В этом случае уменьшается только параметр здоровья по адресу 04FC0490.

2. Оставаться на месте и использовать любую способность. В этом случае уменьшается запас маны персонажа. Соответствующая переменная находится по адресу 04FC0492.

3. Перемещаться бегом вне города. При этом действии меняются сразу три парамета: выносливость, координаты X и Y. Если персонаж бегает достаточно долго, его выносливость уменьшиться до нуля. Таким образом вы можете отличить в памяти её значение (по адресу 04FC0494) от координат. Если перемещать персонажа только в горизонтальном или вертикальном направлении будет меняться одна из координат (X - 04FC0498, а Y - 04FC04A0).

4. Убить любого монстра. В результате этого увеличатся очки опыта персонажа. Этот параметр легко отличить от уровней здоровья и маны, потому что они наоборот уменьшаются. Его адрес равен 04FC04A4.

Что мы узнали нового о параметрах персонажа? Прежде всего то, что уровень здоровья хранится в двухбайтовой переменной. Следовательно, чтобы найти его значение в памяти, вы должны указать "2 Byte" в поле "Value Type" окна Cheat Engine перед поиском.

Также мы узнали, что у некоторых параметров нет четырехбайтового **выравнивания**. Это означает, что их адреса не делтся на четыре. Например, параметр мана по адресу 04FC0492. Чтобы найти значения таких параметров, вам надо убрать галочку "Fast Scan" в окне Cheat Engine.

Правильная конфигурация Cheat Engine для поиска параметров игрового персонажа приведена на иллюстрации 3-20. Красным подчёркнуты изменённые настройки.

![Конфигурация Cheat Engine](cheatengine-configured.png)

**Иллюстрация 3-20.** *Конфигурация Cheat Engine*

Возможно, вы обратили внимание на столбец "Смещение" в таблице 3-6. В нём указаны смещения каждого параметра относительно адреса начала объекта. Рассмотрим, как найти этот адрес в памяти процесса.

### Поиск объекта в памяти

Задумаемся над тем, как наш бот будет искать параметр здоровья персонажа в памяти процесса Diablo 2. Эту задачу можно разделить на два этапа:

1. Найти объект персонажа.

2. Добавить к адресу объекта постоянное смещение, чтобы получить адрес параметра.

Можем ли мы быть уверены, что смещение параметра будет всегда постоянным? Если приложение написано на C++ или C (обычно именно эти языки применяют для разработки игр), параметры игрового объекта, скорее всего, будут храниться в структуре или классе (особый вид структуры). Структура - это тип, в котором все поля и их порядок жёстко определены. Поэтому при каждом запуске приложения смещение полей структуры от её начала остаётся неизменным.

Мы знаем, как искать игровой объект в памяти во время работы приложения с помощью Cheat Engine. К сожалению, наш бот не может пользоваться сканером памяти, точнее такое решение было бы слишком громоздким. Вместо этого, он должен полагаться на собственные алгоритмы. Поэтому нам нужно найти способ поиска объекта на единственном снимке памяти, который доступен боту через WinAPI функции.

Прокрутите окно Memory Viewer вверх в сторону младших адресов переменной с очками опыта персонажа. Вы обнаружите его имя, как на иллюстрации 3-21. Четыре подчёркнутых красным байта представляют собой строку "Kain". Обратите внимание, что для строк порядок байт не перевернут на процессорах с little-endian архитектурой. Причина этого в том, что внутренняя структура ASCII строк и массивов с элементами в один байт совпадает. Процессор обрабатывает байтовые массивы поэлементно, то есть читает в свои регистры по одному байту, т.е. никаких перестановок не происходит.

Обратите внимание на иллюстрации 3-21, что область памяти в сторону младших адресов от имени персонажа занулена. Предположим, что это признак границы игрового объекта. Как мы можем проверить это предположение?

Воспользуемся OllyDbg, чтобы поставить точку останова (breakpoint) на адрес переменной с именем персонажа. Когда какой-то код процесса Diablo 2 попытается прочитать или записать значение по этому адресу, процесс остановится и отладчик получит управление. Мы сможем проанализировать этот код и, возможно, найдём признаки начала игрового объекта.

![Имя персонажа](memory-object-head.png)

**Иллюстрация 3-21.** *Имя персонажа в памяти процесса*

Алгоритм поиска границ объекта с помощью отладчика OllyDbg выглядит следующим образом:

1. Запустить отладчик с правами администратора и подключиться к уже запущенному процессу Diablo 2.

2. Щёлкнуть правой кнопкой мыши в левом нижнем окне OllyDbg и переключиться на шестнадцатеричный формат [**дампа памяти**](https://ru.wikipedia.org/wiki/%D0%94%D0%B0%D0%BC%D0%BF_%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D0%B8).

3. Нажать комбинацию клавиш Ctrl+G, чтобы открыть диалог "Enter expression to follow" для поиска адреса в памяти.

4. Введите адрес строки с именем персонажа в поле "Enter address expression" диалога поиска. В моём случае это адрес 04FC000D. Нажмите кнопку "Follow expression". Теперь курсор в окне с дампом памяти указывает на первый байт строки.

5. Прокрутите окно дампа памяти вверх, чтобы найти первый ненулевой байт с которого предположительно начинается объект персонажа. Выделите этот байт щелчком левой кнопки мыши.

6. Нажмите комбинацию клавиш Shift+F3, чтобы открыть диалог "Set memory breakpoint" для установки точки останова. Выберите в диалоге галочки "Read access" и "Write access", чтобы точка останова срабатывала на чтение и запись по выбранному адресу памяти. Нажмите кнопку "OK".

7. Нажмите F9, чтобы продолжить выполнение процесса Diablo 2. По разным причинам он остановится несколько раз. Продолжайте его выполнение по нажатию F9, пока процесс не будет стабильно работать. В этом случае вы увидите состояние "Running" в правом нижнем углу окна отладчика.

8. Переключитесь на окно Diablo 2. Сразу после этого сработает наша точка останова.

9. Переключитесь на окно OllyDbg. Оно должно выглядеть также, как на иллюстрации 3-22.

Дизассемблерный код процесса отображается в левом верхнем окне отладчика. Инструкция процессора с адресом 03668D9F, исполнение которой вызвало срабатывание нашей точки останова, выделена серой линией:
```assembly
CMP DWORD PTR DS:[ESI+4], 4
```
Эта инструкция сравнивает константу 4 и число типа DWORD, хранящееся по адресу "ESI + 4". Регистр **ESI** используется для указания на источник данных в инструкциях процессора. Регистр **DS** хранит базовый адрес сегмента с данными. Как правило регистры ESI и DS используются совместно. В правом верхнем окне отладчика отображается текущее значение всех регистров процессора. ESI хранит адрес 04FC0000.

![Diablo 2 Ollydbg](diablo-ollydbg.png)

**Иллюстрация 3-22.** *Точка останова на начале объекта игрового персонажа*

Изучим дизассемблированный код после инструкции, на которой сработала точка останова. На иллюстрации 3-22 найдите следующие инструкции, начинающиеся по адресу 03668DE0:
```assembly
MOV EDI,DWORD PTR DS:[ESI+1B8]
CMP DWORD PTR DS:[ESI+1BC],EDI
JNE SHORT 03668DFA
MOV DWORD PTR DS:[ESI+1BC],EBX
```
Эти инструкции выглядят как обращения к полям C++ или C структуры. Константы 1B8 и 1BC - это смещения полей от её начала. Если вы прокрутите дизассемблированный код ниже, вы найдёте ещё несколько подобных обращений. Следовательно, адрес начала структуры, в которой хранятся параметры игрового персонажа, равен 04FC0000, то есть текущему значению регистра ESI.

Теперь мы можем вычислить смещение параметра здоровья от начала структуры:
```
04FC0490 - 04FC0000 = 0x490
```
Смещение равно 490 в шестнадцатеричной системе счисления.

Следующий вопрос: как бот найдёт адрес начала объекта игрового персонажа в памяти? Мы знаем, что этот объект хранится в сегменте неизвестного (unknown) типа, размер которого 80000 байт в шестнадцатеричной системе. У сегмента есть три флага: MEM\_PRIVATE, MEM\_COMMIT и PAGE\_READWRITE. В адресном пространстве процесса Diablo 2 есть минимум десять сегментов этого же типа, размера и с теми же флагами. Следовательно, мы не можем просто перебрать все сегменты и найти нужный по этим признакам.

Ещё раз рассмотрим первые несколько байт объекта персонажа:
```
00 00 00 00 04 00 00 00 03 00 28 0F 00 4B 61 69 6E 00 00 00
```
Если перезапустить игру и найти объект снова, эти байты останутся неизменными. Можно предположить, что эта последовательность байт представляет собой неизменные параметры персонажа. Они задаются однократно при создании нового персонажа и больше никогда не меняются.

Список неизменяемых параметрво персонажа следующий:

* Имя

* Флаг, означающий что персонаж играет в [расширенную версию Diablo 2](diablo.wikia.com/wiki/Expansion_Character)

* Флаг [hardcore режима](diablo.wikia.com/wiki/Hardcore) игры. Он означает, что игра закончится после первой смерти персонажа.

* Класс персонажа.

Последовательность неизменных байт в начале объекта можно использовать как цель для поиска. Учтите, что в вашем случае эта последовательность может отличаться.

Проверим наши предположения с помощью Cheat Engine. Запустите сканер и подключитесь к процессу Diablo 2. Выберите пункт "Array of byte" (массив байт) в поле "Value Type" (тип значения). Затем выберите галочку "Hex" и скопируйте свою последовательность байт в поле "Array of byte". Ожидаемый результат поиска представлен на иллюстрации 3-23.

![Поиск последовательности байт](magic-numbers-search.png)

**Иллюстрация 3-23.** *Поиск объекта игрового персонажа в памяти процесса Diablo 2*

Если вы перезапустите игру, адрес объекта изменится. На иллюстрации 3-23 он равен 04F70000. Тем не менее, смещения всех параметров персонажа внутри объекта остаются неизменными. Исходя из этого, абсолютный адрес уровня здоровья персонажа в нашем случае будет равен 04F70490, т.к. его смещение равно 490.

Есть альтернативный способ найти уровень здоровья персонажа с помощью Cheat Engine. Он может быть поелезен при первоначальном анализе памяти игрового приложения. Cheat Engine предоставляет функцию сканирования указателей (pointer scanning). С её помощью можно найти базовый адрес и смещение переменной после нескольких этапов сканирования памяти процесса. К сожалению, в некоторых случаях эта возможность не работает. Подробнее о ней можно узнать в [статье](https://sethioz.com/mediawiki/index.php/Pointer_Scanning_/_Finding_Pointer).






