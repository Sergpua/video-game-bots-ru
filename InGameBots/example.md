# Пример бота для 2 Diablo 2

## Обзор игры Diablo 2

Мы узнали достаточно, чтобы написать простого внутриигрового бота. Он будет автоматизировать некоторые действия в известной игре Diablo 2. Её игровой процесс типичен для жанра RPG: игрок должен выполнять квесты, убивать монстров и развивать своего персонажа.

Наш бот будет следить за состоянием игрового персонажа. Как только один из его параметров (например здоровье) опустится ниже порогового значения, бот будет выполнять некоторое действие (например использовать зелье лечения).

Перед тем как начать разработку бота, следует подробно изучить интерфейс игры. Скриншот Diablo 2 приведён на иллюстрации 3-15. В центре экрана находится игровой персонаж. Слева и справа от него находятся монстры, один из которых выделен курсором мыши. В нижней части экрана находится панель управления. На ней есть четыре слота с зельями лечения, которые привязаны к горячим клавишам. Наш бот будет использовать предметы в этих слотах при необходимости.

![Интерфейс Diablo 2](diablo-interface.png)

**Иллюстрация 3-15.** *Скриншот окна Diablo 2*

Все параметры игрового персонажа приведены на иллюстрации 3-16. В верхней части левого окна находится общая информация о нём: имя Kain, класс Paladin, уровень 70, очки опыта 285,160,782. Ниже указаны параметры персонажа, влияющие на игровую механику. Например, параметр “Strength” определяет урон, наносимый монстрам при ударе.

![Игровой персонаж в Diablo 2](diablo-player.png)

**Иллюстрация 3-16.** *Параметры игрового персонажа*

Правое окно на иллюстрации 3-16 отображает дерево способностей персонажа. Способности позволяют наносить больше урона монстрам или увеличивать параметры персонажа. Каждая способность имеет свой уровень, который опредеяет её эффективность. Более подробная информация о параметрах и способностях персонажа достпна на [Wiki](diablo.gamepedia.com/Classes_(Diablo_II)).

В Diablo 2 есть однопользовательский и многопользовательский режимы игры. Мы будем рассматривать только однопользовательский. В нём вы сможете останавливать игру под отладчиком в любой момент на неограниченное время, чтобы исследовать память её процесса. В многопользовательском режиме это не будет работать из-за таймаутов. Если игровой клиент не отвечает какое-то время, сервер его отключит.

Чтобы протестировать нашего бота, вы можете купить игру Diablo 2 на [официальном сайте](eu.shop.battle.net/en-b/product/diablo-ii) разработчика. Либо вы можете воспользоваться бесплатным клоном игры под названием [Flaire](http://flarerpg.org). В этом случае вам придётся самостоятельно разработать бота, следуя рассмотренным далее приёмам. Diablo 2 отличается от своего клона интерфейсом и сложностью. Память процесса оригинальной игры намного сложнее анализировать из-за большого количество вспомогательных библиотек.

## Задачи бота

Прежде всего, стоит чётко определить наши цели. Мы не собираемся взламывать игру, то есть нарушать её правила и вмешиваться в механику игрового процесса. Примеры подобных взломов вы можете найти в статьях Jan Miller:

* extreme-gamerz.org/diablo2/viewdiablo2/hackingdiablo2

* www.battleforums.com/threads/howtohackd2-edition-2.111214

Наш бот не нарушает правила игры. Он реагирует на изменение состояния персонажа и симулирует действие. При этом состояние всех игровых объектов меняется согласно правилам. Процесс Diablo 2 продолжает работать по своим оригинальным алгоритмам так же, как если бы действия совершал игрок.

Мы рассмотрели параметры игрового персонажа. Из них проще всего контролировать уровень здоровья. Когда персонаж получает урон от монстров, здоровье уменьшается. При использовании зелья лечения - увеличивается. Учитывая эту механику, наш бот может работать по следующему алгоритму:

1. Прочитать текущий уровень здоровья игрового персонажа.

2. Сравнить этот уровень с пороговоым значением.

3. Если здоровье меньше порога, использовать зелье лечения.

Этот простой алгоритм позволит игровому персонажу выживать до тех пор, пока у него остаются зелья лечения. Однако, несмотря на его простоту, для реализации бота нам придётся детально изучить память процесса Diablo 2.

## Исследование памяти процесса Diablo 2

Мы готовы приступить к исследованию памяти процесса Diablo 2. Наша задача - найти переменную, котоаря хранит значение текущего здоровья персонажа.

Выполним предварительную настройку окна Diablo 2, чтобы с ним было удобнее работать. Если вы запустите игру с найстройками по-умолчанию, она будет работать в полноэкранном режиме. Это неудобно, если приходится часто переключаться на отладчик или сканер памяти.

Чтобы запустить игру в оконном режиме, выполните следующие действия:

1. Щёлкните правой кнопкой мыши по иконке "Diablo II" на рабочем столе. В открывшемся меню выберите пункт "Properties".

2. В диалоге "Properties" перейдите на вкладку "Shortcut".

3. В поле "Target" добавить параметр "-w". В результате полная команда запуска приложения будет выглядеть так:
```
"C:\DiabloII\Diablo II.exe" -w
```
Если вы запустите Diablo 2 через настроенную иконку на рабочем столе, приложение откроется в оконном режиме. Чтобы начать игру, нажмите кнопку "Single player" в главном меню и создайте нового персонажа.

### Поиск параметров персонажа

Мы ищем уровень здоровья игрового персонажа в памяти процесса Diablo 2. Воспользуемся сканером Cheat Engine. Ведь этот инструмент был разработан именно для подобных задач.

Если вы попробуйте искать уровень здоровья по его текущему значению без предварительной настройки Cheat Engine, поиск не даст результата. Вероятнее всего, после первого сканирования вы получите длинный список предполагаемых адресов. При повторном поиске (кнопка "Next Scan") после изменения уровня здоровья персонажа, список результатов станет пуст.

Прямолинейный подход не заработал. Это совершенно нормально для больших, сложных приложений, как Diablo 2. В памяти процесса хранится очень много игровых объектов, причём параметры некоторых из них совпадают. Мы не знаем, как именно они хранятся в памяти. Поэтому будет разумно сначала изучить этот вопрос. Если мы сможем найти нужный объект в памяти, получить доступ к его параметрам будет очень просто.

Еще раз обратимся к окну с параметрами игрового персонажа. Значения некоторых из них наверняка уникальны именно для объекта персонажа. Какие именно?

1. **Имя персонажа**
Очень маловероятно, что в игре встретится объект с тем же именем, которое игрок дал своему персонажу. Если это всё-таик произошло, всегда можно создать другого персонажа и дать ему другой имя.

2. **Очки опыта**
Это длинное положительное целочисленное число. Число такого размера редко встречается в нескольких объектах случайно. Если Cheat Engine всё же нашел несколько потенциальных адресов, очки опыта персонажа очень просто увеличить. Просто убейте одного-двух монстров и выполните повторное сканирование памяти кнопкой "Next Scan".

3. **Значение выносливости**
Это так же длинное число, которое определяет, как долго персонаж может быстро двигаться по карте. Его очень просто уменьшить - достаточно перемщать игрового персонажа вне города.

Из всех вариантов, предлагаю искать очки опыта персонажа. Если вы только начали игру, вам нужно убить нескольких монстров, чтобы этот параметр стал больше нуля. Иллюстрация 3-17 демонстрирует окно Cheat Engine с возможным результатом поиска. Сканер нашёл несколько переменных с одинаковым значением. Только некоторые из них относятся к объекту игрового персонажа. Другие могут быть связаны с интерфейсом игры и выводом информации на экран.

![Результат поиска](experience-value.png)

**Иллюстрация 3-17.** *Результаты поиска параметра игрового персонажа*

Следующий шаг - определить, какие из найденных параметров относятся к объекту персонажа. Тип сегмента, в котором они хранятся, может дать подсказку в этом вопросе.

Запустите отладчик WinDbg, подключитесь к работающему процессу Diablo 2 и выполните команду `!address`. Сегменты с найденными параметрами выглядят следующим образом:
```
+ 0`003c0000  0`003e0000  0`00020000  MEM_PRIVATE MEM_COMMIT PAGE_READWRITE <unknown>
+ 0`03840000  0`03850000  0`00010000  MEM_PRIVATE MEM_COMMIT PAGE_READWRITE <unknown>
+ 0`03850000  0`03860000  0`00010000  MEM_PRIVATE MEM_COMMIT PAGE_READWRITE <unknown>
+ 0`04f50000  0`04fd0000  0`00080000  MEM_PRIVATE MEM_COMMIT PAGE_READWRITE <unknown>
```
Отладчик не смог определить тип этих сегментов и указал, что он неизвестен ("unknown"). Мы знаем, что WinDbg умеет корректно определять сегменты стека и динамической памяти. Если тип неизвестен, скорее всего, это не первое и не второе.

Сегменты неизвестного типа может выделять WinAPI функция `VirtualAllocEx`. Чтобы проверить это предположение, можно написать простое тестовое приложение. Вы можете найти его по имени `VirtualAllocEx.cpp` в архиве с примерами для этой книги. Если вы запустите приложение под отладчиком WinDbg и прочитаете его адресное пространство, вы увидите один сегмент с неизвестным типом. Функция `VirtualAllocEx` возвращает базовый адрес выделенного сегмента.

Вернемся к процессу Diablo 2. Все сегменты, хранящие переменные со значением очков опыта персонажа, имеют одинаковый тип. Поэтому мы не сможем их отличить по типу. Это важно, поскольку после перезапуска игры, порядок следования сегментов может измениться. Если мы не можем их отличать, мы не определим сегмент, в котором находится игровой объект персонажа. Размер сегмента тоже не подходит - у двух из них он одинаковый.

Попробуем другой подход. Очевидно, что параметры персонажа меняются, когда игрок совершает действия. Например координата, когда персонаж двигается. Мы можем следить за такими изменениями в области памяти около найденных нами предполагаемых адресов параметра очков опыта. Cheat Engine может отображать изменения в области памяти в реальном времени. Для этого откройте окно Memory Viewer:

1. Выберите один из адресов в списке результатов поиска.

2. Щелкните правой кнопокой мыши по адресу.

3. Выберите пункт "Browse this memory region" в открывшемся меню.

Откроется окно Memory Viewer приведённое на иллюстрации 3-18. Это окно разделено на две части. В верхней части выводится область памяти около выбранного адреса в виде **дизассемблированного кода**. Это значит, что Cheat Engine пытается представить данные в виде инструкций процессора. В нижней части окна отображаются данные той же самой области памяти в шестнадцатеричном формате. Окно Memory Viewer выводит одни и те же данные, но представленные в разном виде.

Нас интересует нижняя половина окна. Данные, соответствующие очкам опыта персонажа, подчеркнуты красным на иллюстрации 3-18. В моём примере персонаж имеет 285161118 очков опыта. Почему последовательность байт "9E 36 FF 10" равна числу 285161118?

Мы запускаем Diablo 2 на процессоре с архитектурой x86, которая имеет **порядок байт от младщего к старшему** (little-endian byte order). Следовательно, значение из окна Memory Viewer нужно перевернуть, чтобы получить правильно число. Таким образом последовательность байт "9E 36 FF 10" превращается в "10 FF 36 9E". Вы можете воспользоваться стандартным приложением Windows Calculator, чтобы сконвертировать 10FF369E в десятичную систему счисления и получить 285161118.

![Memory Viewer](memory-viewer.png)

**Иллюстрация 3-18.** *Окно Memory Viewer сканера Cheat Engine*

Вы можете настроить формат вывода данных в окне Memory Viewer. Для этого щелкните правой кнопкой мыши в любом месте нижней половины окна и выберите пункт "Display Type" в открывшемся меню. Однако, я рекомендую вам пользоваться форматом "Byte hex", как на иллюстрации 3-18. Другие форматы могут вызвать путанницу, потому что объединяют соседние байты в числа. Когда размер искомых чисел неизвестен, их фрагменты могут объединяться неправильно.

Теперь попробуем проследить изменения данных в областях памяти. Для удобства размести окна Memory Viewer и Diablo 2 рядом, но без перекрытия, как изображено на иллюстрации 3-19. Это позволит вам одновременно управлять персонажем и следить за изменениями в памяти.

![Изменения в памяти](memory-inspection.png)

**Иллюстрация 3-19.** *Исследование изменений в памяти процесса Diablo 2*

В окне Memory Viewer, приведённом на иллюстрации 3-19, открыта область памяти около адреса 04FC04A4. Это один из адресов, который мы получили при поиске очков опыта персонажа. Вам нужно исследовать области около каждого из них.

Как мы поймём, что нашли объект игрового персонажа в памяти? Предлагаю простое правило: если объект хранит больше параметров персонажа, чем другие - его информация о персонаже наиболее полная, и нам следует использовать именно его. В моем случае последний адрес (04FC04A4) в списке результатов сканирования Cheat Engine относится к объекту игрового персонажа.

Таблица 3-6 демонстрирует параметры, которые мы обнаружили в объекте.

**Таблица 3-6.** *Найденные параметры игрового объекта*

| Параметр | Адрес | Смещение | Размер | Шестнадцатеричное значение | Десятичное значение |
| -- | -- | -- | -- | -- | -- |
| Здоровье | 04FC0490 | 490 | 2 | 40 01 | 320 |
| Мана | 04FC0492 | 492 | 2 | 9D 01 | 413 |
| Выносливость | 04FC0494 | 494 | 2 | FE 1F | 8190 |
| Координата X | 04FC0498 | 498 | 2 | 37 14 | 5175 |
| Координата Y | 04FC04A0 | 4A0 | 2 | 47 12 | 4679 |
| Очки опыта | 04FC04A4 | 4A4 | 4 | 9E 36 FF 10 | 285161118 |

Эти параметры подчёркнуты красным на иллюстрации 3-19. Чтобы их обнаружить, я выполнил следующие игровые действия:

1. Оставаться на месте и получать урон от атакующего монстра. В этом случае уменьшается только параметр здоровья по адресу 04FC0490.

2. Оставаться на месте и использовать любую способность. В этом случае уменьшается запас маны персонажа. Соответствующая переменная находится по адресу 04FC0492.

3. Перемещаться бегом вне города. При этом действии меняются сразу три парамета: выносливость, координаты X и Y. Если персонаж бегает достаточно долго, его выносливость уменьшиться до нуля. Таким образом вы можете отличить в памяти её значение (по адресу 04FC0494) от координат. Если перемещать персонажа только в горизонтальном или вертикальном направлении будет меняться одна из координат (X - 04FC0498, а Y - 04FC04A0).

4. Убить любого монстра. В результате этого увеличатся очки опыта персонажа. Этот параметр легко отличить от уровней здоровья и маны, потому что они наоборот уменьшаются. Его адрес равен 04FC04A4.

Что мы узнали нового о параметрах персонажа? Прежде всего то, что уровень здоровья хранится в двухбайтовой переменной. Следовательно, чтобы найти его значение в памяти, вы должны указать "2 Byte" в поле "Value Type" окна Cheat Engine перед поиском.

Также мы узнали, что у некоторых параметров нет четырехбайтового **выравнивания**. Это означает, что их адреса не делтся на четыре. Например, параметр мана по адресу 04FC0492. Чтобы найти значения таких параметров, вам надо убрать галочку "Fast Scan" в окне Cheat Engine.

Правильная конфигурация Cheat Engine для поиска параметров игрового персонажа приведена на иллюстрации 3-20. Красным подчёркнуты изменённые настройки.

![Конфигурация Cheat Engine](cheatengine-configured.png)

**Иллюстрация 3-20.** *Конфигурация Cheat Engine*

Возможно, вы обратили внимание на столбец "Смещение" в таблице 3-6. В нём указаны смещения каждого параметра относительно адреса начала объекта. Рассмотрим, как найти этот адрес в памяти процесса.

### Поиск объекта в памяти

Задумаемся над тем, как наш бот будет искать параметр здоровья персонажа в памяти процесса Diablo 2. Эту задачу можно разделить на два этапа:

1. Найти объект персонажа.

2. Добавить к адресу объекта постоянное смещение, чтобы получить адрес параметра.

Можем ли мы быть уверены, что смещение параметра будет всегда постоянным? Если приложение написано на C++ или C (обычно именно эти языки применяют для разработки игр), параметры игрового объекта, скорее всего, будут храниться в структуре или классе (особый вид структуры). Структура - это тип, в котором все поля и их порядок жёстко определены. Поэтому при каждом запуске приложения смещение полей структуры от её начала остаётся неизменным.

Мы знаем, как искать игровой объект в памяти во время работы приложения с помощью Cheat Engine. К сожалению, наш бот не может пользоваться сканером памяти, точнее такое решение было бы слишком громоздким. Вместо этого, он должен полагаться на собственные алгоритмы. Поэтому нам нужно найти способ поиска объекта на единственном снимке памяти, который доступен боту через WinAPI функции.

Прокрутите окно Memory Viewer вверх в сторону младших адресов переменной с очками опыта персонажа. Вы обнаружите его имя, как на иллюстрации 3-21. Четыре подчёркнутых красным байта представляют собой строку "Kain". Обратите внимание, что для строк порядок байт не перевернут на процессорах с little-endian архитектурой. Причина этого в том, что внутренняя структура ASCII строк и массивов с элементами в один байт совпадает. Процессор обрабатывает байтовые массивы поэлементно, то есть читает в свои регистры по одному байту, т.е. никаких перестановок не происходит.

Обратите внимание на иллюстрации 3-21, что область памяти в сторону младших адресов от имени персонажа занулена. Предположим, что это признак границы игрового объекта. Как мы можем проверить это предположение?

Воспользуемся OllyDbg, чтобы поставить точку останова (breakpoint) на адрес переменной с именем персонажа. Когда какой-то код процесса Diablo 2 попытается прочитать или записать значение по этому адресу, процесс остановится и отладчик получит управление. Мы сможем проанализировать этот код и, возможно, найдём признаки начала игрового объекта.

![Имя персонажа](memory-object-head.png)

**Иллюстрация 3-21.** *Имя персонажа в памяти процесса*

Алгоритм поиска границ объекта с помощью отладчика OllyDbg выглядит следующим образом:

1. Запустить отладчик с правами администратора и подключиться к уже запущенному процессу Diablo 2.

2. Щёлкнуть правой кнопкой мыши в левом нижнем окне OllyDbg и переключиться на шестнадцатеричный формат [**дампа памяти**](https://ru.wikipedia.org/wiki/%D0%94%D0%B0%D0%BC%D0%BF_%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D0%B8).

3. Нажать комбинацию клавиш Ctrl+G, чтобы открыть диалог "Enter expression to follow" для поиска адреса в памяти.

4. Введите адрес строки с именем персонажа в поле "Enter address expression" диалога поиска. В моём случае это адрес 04FC000D. Нажмите кнопку "Follow expression". Теперь курсор в окне с дампом памяти указывает на первый байт строки.

5. Прокрутите окно дампа памяти вверх, чтобы найти первый ненулевой байт с которого предположительно начинается объект персонажа. Выделите этот байт щелчком левой кнопки мыши.

6. Нажмите комбинацию клавиш Shift+F3, чтобы открыть диалог "Set memory breakpoint" для установки точки останова. Выберите в диалоге галочки "Read access" и "Write access", чтобы точка останова срабатывала на чтение и запись по выбранному адресу памяти. Нажмите кнопку "OK".

7. Нажмите F9, чтобы продолжить выполнение процесса Diablo 2. По разным причинам он остановится несколько раз. Продолжайте его выполнение по нажатию F9, пока процесс не будет стабильно работать. В этом случае вы увидите состояние "Running" в правом нижнем углу окна отладчика.

8. Переключитесь на окно Diablo 2. Сразу после этого сработает наша точка останова.

9. Переключитесь на окно OllyDbg. Оно должно выглядеть также, как на иллюстрации 3-22.

Дизассемблерный код процесса отображается в левом верхнем окне отладчика. Инструкция процессора с адресом 03668D9F, исполнение которой вызвало срабатывание нашей точки останова, выделена серой линией:
```assembly
CMP DWORD PTR DS:[ESI+4], 4
```
Эта инструкция сравнивает константу 4 и число типа DWORD, хранящееся по адресу "ESI + 4". Регистр **ESI** используется для указания на источник данных в инструкциях процессора. Регистр **DS** хранит базовый адрес сегмента с данными. Как правило регистры ESI и DS используются совместно. В правом верхнем окне отладчика отображается текущее значение всех регистров процессора. ESI хранит адрес 04FC0000.

![Diablo 2 Ollydbg](diablo-ollydbg.png)

**Иллюстрация 3-22.** *Точка останова на начале объекта игрового персонажа*

Изучим дизассемблированный код после инструкции, на которой сработала точка останова. На иллюстрации 3-22 найдите следующие инструкции, начинающиеся по адресу 03668DE0:
```assembly
MOV EDI,DWORD PTR DS:[ESI+1B8]
CMP DWORD PTR DS:[ESI+1BC],EDI
JNE SHORT 03668DFA
MOV DWORD PTR DS:[ESI+1BC],EBX
```
Эти инструкции выглядят как обращения к полям C++ или C структуры. Константы 1B8 и 1BC - это смещения полей от её начала. Если вы прокрутите дизассемблированный код ниже, вы найдёте ещё несколько подобных обращений. Следовательно, адрес начала структуры, в которой хранятся параметры игрового персонажа, равен 04FC0000, то есть текущему значению регистра ESI.

Теперь мы можем вычислить смещение параметра здоровья от начала структуры:
```
04FC0490 - 04FC0000 = 0x490
```
Смещение равно 490 в шестнадцатеричной системе счисления.

Следующий вопрос: как бот найдёт адрес начала объекта игрового персонажа в памяти? Мы знаем, что этот объект хранится в сегменте неизвестного (unknown) типа, размер которого 80000 байт в шестнадцатеричной системе. У сегмента есть три флага: MEM\_PRIVATE, MEM\_COMMIT и PAGE\_READWRITE. В адресном пространстве процесса Diablo 2 есть минимум десять сегментов этого же типа, размера и с теми же флагами. Следовательно, мы не можем просто перебрать все сегменты и найти нужный по этим признакам.

Ещё раз рассмотрим первые несколько байт объекта персонажа:
```
00 00 00 00 04 00 00 00 03 00 28 0F 00 4B 61 69 6E 00 00 00
```
Если перезапустить игру и найти объект снова, эти байты останутся неизменными. Можно предположить, что эта последовательность байт представляет собой неизменные параметры персонажа. Они задаются однократно при создании нового персонажа и больше никогда не меняются.

Список неизменяемых параметрво персонажа следующий:

* Имя

* Флаг, означающий что персонаж играет в [расширенную версию Diablo 2](diablo.wikia.com/wiki/Expansion_Character)

* Флаг [hardcore режима](diablo.wikia.com/wiki/Hardcore) игры. Он означает, что игра закончится после первой смерти персонажа.

* Класс персонажа.

Последовательность неизменных байт в начале объекта можно использовать как цель для поиска. Назовём её [**магическим числом** или сигнатурой](https://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D0%B3%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5_%D1%87%D0%B8%D1%81%D0%BB%D0%BE_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)) Учтите, что в вашем случае эта последовательность может отличаться.

Проверим наши предположения с помощью Cheat Engine. Запустите сканер и подключитесь к процессу Diablo 2. Выберите пункт "Array of byte" (массив байт) в поле "Value Type" (тип значения). Затем выберите галочку "Hex" и скопируйте свою последовательность байт в поле "Array of byte". Ожидаемый результат поиска представлен на иллюстрации 3-23.

![Поиск последовательности байт](magic-numbers-search.png)

**Иллюстрация 3-23.** *Поиск объекта игрового персонажа в памяти процесса Diablo 2*

Если вы перезапустите игру, адрес объекта изменится. На иллюстрации 3-23 он равен 04F70000. Тем не менее, смещения всех параметров персонажа внутри объекта остаются неизменными. Исходя из этого, абсолютный адрес уровня здоровья персонажа в нашем случае будет равен 04F70490, т.к. его смещение равно 490.

Есть альтернативный способ найти уровень здоровья персонажа с помощью Cheat Engine. Он может быть поелезен при первоначальном анализе памяти игрового приложения. Cheat Engine предоставляет функцию сканирования указателей (pointer scanning). С её помощью можно найти базовый адрес и смещение переменной после нескольких этапов сканирования памяти процесса. К сожалению, в некоторых случаях эта возможность не работает. Подробнее о ней можно узнать в [статье](https://sethioz.com/mediawiki/index.php/Pointer_Scanning_/_Finding_Pointer).

## Реализация бота

Мы собрали всю необходимую информацию, чтобы реализовать нашего внутриигрового бота. Составим подробный алгоритм его работы:

1. Предоставить привилегию SE\_DEBUG\_NAME процессу бота. Это необходимо для чтения памяти другого процесса.

2. Подключиться к процессу Diablo 2 для доступа к его памяти.

3. Искать объект игрового персонажа в адресном пространстве игры.

4. Вычислить абсолютный адрес параметра здоровья персонажа.

5. Читать значение парамтра в бесконечном цикле. Как только оно опустится ниже 100 пунктов, использовать зелье лечения.

Мы уже рассмотрели реализацию первого шага алгоритма  в предыдущем разделе этой главы.

Второй шаг алгоритма может быть реализован двумя способами. Мы можем указать PID целевого процесса в коде бота (как в предыдущих примерах), либо определять PID динамически по активному в данный момент окну. Важно следить, чтобы в момент запуска бота окно Diablo 2 всегда было активно. Такой подход сделает бота более удобным в использовании, потому что его не придётся компилировать перед каждым запуском.

Листинг 3-11 демонстрирует чтение PID и подключение к процессу.

**Листинг 3-11.** *Код подключения к процессу*
```C++
int main()
{
        Sleep(4000);

        HWND wnd = GetForegroundWindow();
        DWORD pid = 0;
        if (!GetWindowThreadProcessId(wnd, &pid))
        {
                printf("Error of the pid detection\n");
                return 1;
        }
        
        HANDLE hTargetProc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
        if (!hTargetProc)
                printf("Failed to open process: %u\n", GetLastError());
        
        return 0;
}
```
Для чтения PID процесса мы использовали две новые WinAPI функции. Вызов `GetForegroundWindow` возвращает дескриптор активного в данный момент окна. Функция `GetWindowThreadProcessId` возвращает PID процесса, который владеет окном, указанным по его дескриптору. Полученный PID сохраняется в переменной `pid`.

Перед началом работы мы ждём четыре секунды с помощью WinAPI функции `Sleep`. Этого времени должно быть достаточно, чтобы вы успели переключиться на окно Diablo 2.

Третий шаг алгоритма - поиск объекта игрового персонажа в памяти процесса. Предлагаю использовать подход, описанный в серии [видеоуроков](https://www.youtube.com/watch?v=YRPMdb1YMS8). В них рассматривается разработка простого сканера памяти, алгоритм работы которого очень похож на Cheat Engine. Идея заключается в переборе всех сегментов процесса Diablo 2 с помощью WinAPI функции `VirtualQueryEx`.

Код для поиска объекта персонажа в памяти процесса Diablo 2 приведён в листинге 3-12 .

**Листинг 3-12.** *Код поиска игрового объекта в памяти процесса*
```C++
SIZE_T IsArrayMatch(HANDLE proc, SIZE_T address, SIZE_T segmentSize, BYTE array[], SIZE_T arraySize)
{
        BYTE* procArray = new BYTE[segmentSize];

        if (ReadProcessMemory(proc, (void*)address, procArray, segmentSize, NULL) != 0)
        {
                printf("Failed to read memory: %u\n", GetLastError());
                delete[] procArray;
                return 0;
        }
        
        for (SIZE_T i = 0; i < segmentSize; ++i)
        {
                if ((array[0] == procArray[i]) && ((i + arraySize) < segmentSize))
                {
                        if (!memcmp(array, procArray + i, arraySize))
                        {
                                delete[] procArray;
                                return address + i;
                        }
                }
        }

        delete[] procArray;
        return 0;
}

SIZE_T ScanSegments(HANDLE proc, BYTE array[], SIZE_T size)
{
        MEMORY_BASIC_INFORMATION meminfo;
        LPCVOID addr = 0;
        SIZE_T result = 0;

        if (!proc)
                return 0;

        while (1)
        {
                if (VirtualQueryEx(proc, addr, &meminfo, sizeof(meminfo)) == 0)
                        break;

                if ((meminfo.State & MEM_COMMIT) && (meminfo.Type & MEM_PRIVATE) && (meminfo.Protect & PAGE_READWRITE) && !(meminfo.Protect & PAGE_GUARD))
                {
                        result = IsArrayMatch(proc, (SIZE_T)meminfo.BaseAddress, 
                                meminfo.RegionSize, array, size);

                        if (result != 0)
                                return result;
                }
                addr = (unsigned char*)meminfo.BaseAddress + meminfo.RegionSize;
        }
        return 0;
}

int main()
{
        // Предоставить SE_DEBUG_NAME привилегию текущему процессу

        // Подключиться к процессу Diablo 2

        BYTE array[] = { 0, 0, 0, 0, 0x04, 0, 0, 0, 0x03, 0, 0x28, 0x0F, 0, 0x4B, 0x61, 0x69, 0x6E, 0, 0, 0 };

        SIZE_T objectAddress = ScanSegments(hTargetProc, array, sizeof(array));
        
        return 0;
}
```
Алгоритм прохода по сегментам памяти целевого процесса реализован в функции `ScanSegments`. Он состоит из следующих шагов:

1. Прочитать сегмент памяти с базовым адресом равным переменной `addr` с помощью функции `VirtualQueryEx`.

2. Сравнить флаги прочитанного сегмента с флагами искомого сегмента. Если они не равны, перейти к следующему сегменту.

3. Искать последовательность байт, характерную для объекта персонажа в прочитанном сегменте.

4. Если последовательность найдена, вернуть её абсолютный адрес. Иначе читать следующий сегмент.

Алгоритм поиска последовательности байт в сегменте реализован в функции `IsArrayMatch`. Он выглядит следующим образом:

1. Прочитать все данные из указанного сегмента с помощью WinAPI функции `ReadProcessMemory`.

2. Искать последовательность байт в этих данных.

Функция `main` листинга 3-12 демонстрирует пример вызова `ScanSegments`, которая имеет три входных параметра:

1. Дескриптор процесса Diablo 2.

2. Указатель на искомую последовательсноть байт.

3. Размер последовательности.

---
Не забывайте, что искомая последовательность байт отличается в вашем случае.
---

Четвертый шаг общего алгоритма бота - это вычисление абсолютного адреса переменной, хранящей уровень здоровья персонажа. Для этого воспользуемся переменной `objectAddress` с результатом вызова функции `ScanSegments`:
```C++
SIZE_T hpAddress = objectAddress + 0x490;
```
Теперь переменная `hpAddress` хранит абсолютный адрес по которому мы можем прочитать параметр здоровья.

Последнее действие бота - проверка уровня здоровья персонажа. Если он оказывается ниже порогового значения, бот должен использовать зелье лечения. Реализация этой проверки приведена в листинге 3-13.

**Листинг 3-13.** *Код проверки уровня здоровья персонажа*
```C++
WORD ReadWord(HANDLE hProc, DWORD_PTR address)
{
        WORD result = 0;

        if (ReadProcessMemory(hProc, (void*)address, &result, sizeof(result), NULL) == 0)
                printf("Failed to read memory: %u\n", GetLastError());

        return result;
}

int main()
{
        // Предоставить SE_DEBUG_NAME привилегию текущему процессу

        // Подключиться к процессу Diablo 2

        // Искать объект игрового персонажа в памяти процесса Diablo 2

        // Вычислить абсолютный адрес переменной с уровнем здоровья персонажа

        ULONG hp = 0;

        while (1)
        {
                hp = ReadWord(hTargetProc, hpAddress);
                printf("HP = %lu\n", hp);

                if (hp < 100)
                        PostMessage(wnd, WM_KEYDOWN, 0x31, 0x1);

                Sleep(2000);
        }
        return 0;
}
```
Здоровье персонажа читается в бесконечном `while` цикле с помощью функции `ReadWord`. Эта функция - обёртка для WinAPI функции `ReadProcessMemory`. Прочитав значение здоровья, бот выводит его в консоль. Благодаря этому вы можете проверить корректность параметра, сравнив его с выводом в окне Diablo 2. Если значение становится меньше 100, бот симулирует нажатие горячей клавиши "1". По этому нажатию игровой персонаж использует зелье лечения. Для симуляции нажатия клавиши вызывается WinAPI функция `PostMessage`.

Вы можете возразить, что использование функции `PostMessage` - это не встраивание данных в память процесса, характерное для внутриигровых ботов. Вместо модификации памяти, мы внедряем сообщение `WM_KEYDOWN`, которое соответствует нажатию клавиши, в очередь сообщений процесса Diablo 2. Это самый простой способ симуляции действий игрока. Более сложный способ мы рассмотрим далее.

Параметры функции `PostMessage` описаны в таблице 3-7.

**Таблица 3-7.** *Параметры функции `PostMessage`*

| Параметр | Описание |
| --- | --- |
| `wnd` | Дескриптор окна. Процесс, создавший это окно, получит сообщение. |
| `WM_KEYDOWN` | Код сообщения. |
| `0x31` | [**Виртуальный код**](http://msdn.microsoft.com/en-us/library/windows/desktop/dd375731(v=vs.85).aspx) нажатой клавиши. |
| `0x1` | Параметры нажатия. Самый важный из них - число срабатываний нажатия (хранится в битах с 0 по 15). |

---
Симуляция нажатия клавиши не сработает, если четвёртый параметр функции `PostMessage` будет равен нулю.
---
Полная реализация бота доступна в файле AutohpBot.cpp в архиве примеров к этой книге.

Чтобы протестировать бота, выполните следующие действия:

1. Измените последовательность байт для поиска так, чтобы она соответствовала вашему персонажу. В исходном коде бота это строка:
```C++
BYTE array[] = { 0, 0, 0, 0, 0x04, 0, 0, 0, 0x03, 0, 0x28, 0x0F, 0, 0x4B, 0x61, 0x69, 0x6E, 0, 0, 0 };
```

2. Скомпилируйте бота с новой последовательностью байт.

3. Запустите Diablo 2 в оконном режиме.

4. Запустите бота с правами администратора.

5. В течение четырёх секунд после старта бота переключитесь на окно Diablo 2. После этой задержки, бот подключится к процессу игры и начнёт анализировать уровень здоровья персонажа.

6. Найдите в игре монстра и получите от него урон так, чтобы здоровье персонажа опустилось ниже 100 пунктов.

В этом случае бот нажмёт горячую клавишу "1". Не забудьте привязать зелье лечение к этой горячей клавише.

Для вызова справки по интерфейсу игры, нажмите клавишу H. Панель "Belt" (пояс) горячих клавиш находится в правой нижней части экрана. Вы можете перенести на неё зелья лечения левой кнопкой мыши.


