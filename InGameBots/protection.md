# Методы защиты от внутриигровых ботов

Мы реализовали внутриигрового бота для Diablo 2 и узнали, как он получает доступ к памяти процесса игры. Теперь рассмотрим способы защиты от этого типа ботов.

Есть две группы методов защиты от внутриигровых ботов:

* Защита приложения от реверс-инжиниринга.

* Блокировка алгоритмов бота.

Первая группа методов разрабатывается очень давно: со времён первых версий коммерческого ПО, которое нужно было защищать от нелицензионного распространения. Эти методы хорошо известны и информацию о них легко найти в Интернете. Их основная задача - усложнить анализ приложения с помощью отладчика и дизассемблера.

Вторая группа методов защищает данные процесса игрового приложения от чтения и записи. Таким образом боту становится сложнее читать состояние объектов и внедрять свои действия.

Некоторые методы защиты можно отнести сразу к обоим группам.

## Тестовое приложение

Вспомним архитектуру клиент-сервер современных онлайн игр. Клиент выполняется на компьютере пользователя и обменивается сообщениями с игровым сервером. Большая часть методов защиты от внутриигровых ботов работает на стороне клиента.

Рассмотрим методы защиты на конкретном примере. Напишем простое приложение, которое будет имитировать состояние игрового объекта. Для управления им разработаем также простейшего внутриигрового бота.

---
Все примеры этого раздела компилировались на Visual Studio C++ под 32 разрядную архитектуру. Некоторые из них могут не заработать или потребуют изменений, если вы соберёте их под 64 разрядную архитектуру или с помощью MinGW.
---

Алгоритм тестового приложения будет следующим:

1. При старте присвоить параметру объекта (например уровень здоровья) максимально допустимое значение.

2. В цикле проверять состояние горячей клавиши "1".

3. Если пользователь не нажимает клавишу, уменьшать параметр объект. Иначе - увеличивать.

4. Если параметр оказался равен 0, завершить приложение.

Листинг 3-16 демонстрирует исходный код тестового приложения.

**Листинг 3-16.** *Исходный код тестового приложения*
```C++
#include <stdio.h>
#include <stdint.h>
#include <windows.h>

static const uint16_t MAX_LIFE = 20;
static uint16_t gLife = MAX_LIFE;

int main()
{
    SHORT result = 0;

    while (gLife > 0)
    {
        result = GetAsyncKeyState(0x31);
        if (result != 0xFFFF8001)
            --gLife;
        else
            ++gLife;
 
        printf("life = %u\n", gLife);
        Sleep(1000);
    }
    printf("stop\n");
    return 0;
}
```
Уровень здоровья игрового объекта хранится в глобальной переменной `gLife`. При старте приложения мы присваиваем ей значение константы `MAX_LIFE`, равное 20.

Вся работа функции `main` происходит в цикле `while`. В нём мы проверяем состояние клавиши "1" с помощью WinAPI функции `GetAsyncKeyState`. Виртуальный код этой клавиши (равный 0x31) передаётся в функцию входным параметром. Если вызов `GetAsyncKeyState` возвращает состояние "не нажато", переменная `gLife` уменьшается на 1. В противном случае - увеличивается также на 1. После этого идёт односекундная задержка для того, чтобы пользователь успел отпустить клавишу.

Попробуйте скомпилировать тестовое приложение в конфигурации "Debug" (отладка) в Visual Studio и запустить его.

### Исследование памяти тестового приложения

Теперь напишем бота для нашего тестового приложения. Его алгоритм будет таким же, как и для игры Diablo 2 из прошлого раздела. Если параметр здоровья опускается ниже 10, бот симулирует нажатие клавиши "1".

Чтобы контролировать параметр здоровья, бот должен читать значение переменной `gLife`. Очевидно, мы не можем воспользоваться тем же механизмом поиска объекта, который мы применили для Diablo 2. Нам нужно проанализировать адресное пространство тестового приложения и найти подходящий метод доступа к `gLife`. Хорошая новость заключается в том, что это приложение очень простое и нам будет достаточно отладчика OllyDbg.

Чтобы найти сегмент, содержащий переменную `gLife` выполним следующие шаги:

1. Запустите отладчик OllyDbg. Нажмите F3, чтобы открыть диалог "Select 32-bit executable" (выберите 32-разрядный исполняемый файл). В диалоге выберите скомпилированное приложение из листинга 3-16. В резльтате отладчик запустит приложение и остановит его процесс на первой исполняемой инструкции процессора.

2. Нажмите комбинацию клавиш Ctrl+G, чтобы открыть диалог "Enter expression to follow" (ввести выражение для перехода).

3. Введите имена EXE модуля и функции `main` через точку в поле диалога "Enter address expression" (ввести адрес выражения). Должна получиться строка "TestApplication.main". После этого нажмите кнопку "Follow expression" (перейти к выражению). Теперь курсор окна дизассемблера должен указывать на первую инструкцию функции `main`.

4. Поставьте точку останова на эту инструкцию нажатием F2.

5. Начните исполнение процесса нажатием F9. Должна сработать наша точка останова.

6. Щёлкните правой кнопкой мыши по следующей строке дизассемблерного кода:
```assembly
MOV AX,WORD PTR DS:[gLife]
```
Позиция курсора должна совпадать с иллюстрацией 3-24.

![Test Application main](test-application-ollydbg.png)

**Иллюстрация 3-24.** *Точка останова в `main` функции*

7. Выберите пункт “Follow in Dump” ➤ “Memory address” ("Следить в дампе" ➤ "Адрес памяти") в открывшемся меню. Теперь курсор в окне дампа памяти указывает на переменную `gLife`. В моём случае она находится по адресу 329000 и имеет значение 14 в шестнадцатеричной системе.

8. Нажмите комбинацию клавиш Alt+M, чтобы открыть окно "Memory map" (карта памяти).

9. Найдите сегмент в котором находится переменная `gLife`. Это должен быть `.data` модуля TestApplication как на иллюстрации 3-25.

![Test Application сегмент .data](testapp-segment-ollydbg.png)

**Иллюстрация 3-25.** *Сегменты модуля TestApplication*

Мы выяснили, что переменная `gLife` хранится в самом начале сегмента `.data`. Следовательно, её адрес равен базовому адресу сегмента. Если бот найдет `.data`, он сразу сможет прочитать `gLife`.

### Бот для тестового приложения

Мы рассмотрели алгоритм бота для тестового приложения в общих чертах. Теперь составим точную последовательность действий, которую затем запрограммируем:

1. Предоставить привилегию SE\_DEBUG\_NAME процессу бота.

2. Подключиться к процессу тестового приложения.

3. Искать в памяти сегмент `.data`, в котором хранится переменная `gLife`.

4. Читать переменную в бесконечном цикле. Если её значение оказывается меньше 10, записать вместо него 20.

Исходный код бота приведён в листинге 3-17.

**Листинг 3-17.** *Исходный код бота для тестового приложения*
```C++
#include <stdio.h>
#include <windows.h>

BOOL SetPrivilege(HANDLE hToken, LPCTSTR lpszPrivilege, BOOL bEnablePrivilege)
{
    // См. реализацию этой функции в листинге 3-1
}

SIZE_T ScanSegments(HANDLE proc)
{
    MEMORY_BASIC_INFORMATION meminfo;
    LPCVOID addr = 0;

    if (!proc)
        return 0;

    while (1)
    {
        if (VirtualQueryEx(proc, addr, &meminfo, sizeof(meminfo)) == 0)
            break;

        if ((meminfo.State == MEM_COMMIT) && (meminfo.Type & MEM_IMAGE) && (meminfo.Protect == PAGE_READWRITE) && (meminfo.RegionSize == 0x1000))
        {
            return (SIZE_T)meminfo.BaseAddress;
        }
        addr = (unsigned char*)meminfo.BaseAddress + meminfo.RegionSize;
    }
    return 0;
}

WORD ReadWord(HANDLE hProc, DWORD_PTR address)
{
    // См. реализацию этой функции в листинге 3-13
}

void WriteWord(HANDLE hProc, DWORD_PTR address, WORD value)
{
    if (WriteProcessMemory(hProc, (void*)address, &value, sizeof(value), NULL) == 0)
        printf("Failed to write memory: %u\n", GetLastError());
}

int main()
{
    // Предоставить SE_DEBUG_NAME привилегию текущему процессу

    // Подключиться к процессу тестового приложения

    SIZE_T lifeAddress = ScanSegments(hTargetProc);

    ULONG hp = 0;
    while (1)
    {
        hp = ReadWord(hTargetProc, lifeAddress);
        printf("life = %lu\n", hp);

        if (hp < 10)
            WriteWord(hTargetProc, lifeAddress, 20);

        Sleep(1000);
    }
    return 0;
}
```
Главное различие ботов для тестового приложения и для Diablo 2 - это реализация функции `ScanSegments`. Теперь мы можем отличить нужный нам сегмент `.data` по его флагам и размеру. Эта информация выводится в окне "Memory map" отладчика OllyDbg. Таблица 3-8 поясняет значения флагов.

**Таблица 3-8.** *Значения флагов сегмента `.data`*

| Столбец окна "Memory map" | Значение в OllyDbg | Значение в WinAPI | Описание |
| --- | --- | --- | --- |
| Type | Img | MEM_IMAGE | Страницы памяти были загружены из исполняемого файла. |
| Access | RW | PAGE_READWRITE | Страницы памяти доступны для чтения и записи. |
|  |  | MEM_COMMIT | Страницы памяти были выделены на физическом носителе (RAM или файл подкачки на жёстком диске). |

Флаг `MEM_COMMIT` не отображается в OllyDbg, но его можно прочитать с помощью WinDbg.

Чтобы запустить бота, выполните следующие действия:

1. Запустите тестовое приложение.

2. Запустите бота с правами администратора.

3. Переключитесь на консоль с работающим тестовым приложением.

4. Ждите, пока не увидите сообщение, что переменная `gLife` стала меньше 10.

Бот перепишет значение `gLife`, как только оно станет слишко мало.

## Защита приложения от реверс-инжиниринга

Сначала рассмотрим методы защиты кода и памяти игрового приложения от исследования. Как показал пример разработки бота для Diablo 2, знание внутренних аспектов работы игры очень важно. К сожалению, абсолютно надёжной защиты не бывает. Лучшее, чего можно достигнуть, - заставить потенциального разработчика бота потратить больше времени на исследование игры. Возможно, этого будет достаточно, чтобы он отказался от своих планов.

### WinAPI функции для обнаружения отладчика

Основной инструмент для исследования памяти процесса - это отладчик. Поэтому самым прямолинейным способом защиты будет его обнаружение. Для этого WinAPI интерфейс предоставляет несколько подходящих функций. Если отладчик подключен, достаточно просто завершить работу приложения.
 
Рассматриваемые далее методы не защищают память процесса от чтения сканером (например Cheat Engine) или ботом. Они только позволяют обнаружить факт подключения отладчика.

#### IsDebuggerPresent

WinAPI функция `IsDebuggerPresent` возвращает значение `true`, если к вызвавшему её процессу подключён отладчик. `IsDebuggerPresent` можно использовать следующим образом:
```C++
int main()
{
    if (IsDebuggerPresent())
    {
        printf("debugger detected!\n");
        exit(EXIT_FAILURE);
    }

    // Остальной код соответствует функции main из листинга 3-16
}
```
Мы проверяем присутствие отладчика в начале функции `main`. Если он обнаружен, процесс тестового приложения прерывается вызовом `exit`. Такой способ использования `IsDebuggerPresent` неэффективен. Мы обнаружим отладчик только в том случае, если он запускает процесс приложения. Если же подключиться к уже запущенному процессу, мы сможем его отлаживать. В этом случае проверка `IsDebuggerPresent` уже прошла и регулярного её повтора нет.

Листинг 3-18 демонстрирует правильный способ использования функции `IsDebuggerPresent`.

**Листинг 3-18.** *Защита тестового приложения вызовом `IsDebuggerPresent`*
```C++
#include <stdio.h>

int main()
{
    SHORT result = 0;

    while (gLife > 0)
    {
        if (IsDebuggerPresent())
        {
            printf("debugger detected!\n");
            exit(EXIT_FAILURE);
        }
        result = GetAsyncKeyState(0x31);
        if (result != 0xFFFF8001)
            --gLife;
        else
            ++gLife;

        printf("life = %u\n", gLife);
        Sleep(1000);
    }
    printf("stop\n");
    return 0;
}
```
Теперь проверка наличия отладчика с помощью вызова `IsDebuggerPresent` происходит в начале каждой итерации `while` цикла. Поэтому он будет обнаружен, даже если подключиться к уже работающему приложению.

Как обойти такую защиту? Первый способ - манипуляция регистрами процессора в момент проверки. Мы можем вручную подменить возвращаемое функцией значение, чтобы предотвратить выполнение блока кода с вызовом `exit`.

Чтобы подменить результат вызова функции `IsDebuggerPresent`, необходимы следующие действия:

1. Запустите отладичк OllyDbg и приложение из листинга 3-18 под его управлением.

2. Нажмите комбинацию клавиш Ctrl+N, чтобы открыть окно "Names in TestApplication" (имена в TestApplication). Перед вами [**таблица символов**](https://ru.wikipedia.org/wiki/%D0%A2%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D0%B0_%D1%81%D0%B8%D0%BC%D0%B2%D0%BE%D0%BB%D0%BE%D0%B2) тестового приложения, в которой указаны все его переменные и функции.

3. Введите имя `IsDebuggerPresent` в окне "Names in TestApplication". При этом переход в списке к соответствующей функции произойдёт автоматически.

4. Щёлкните левой кнопкой мыши по строчке "&KERNEL32.IsDebuggerPresent" в списке.

5. Нажмите Ctrl+R, чтобы открыть диалог "Search - References to..." (поиск ссылок на...). Вы увидите список мест в коде приложения из которых вызывается функция `IsDebuggerPresent`.

6. Двойным левым щелчком мыши выберите первую строчку в окне "Search - References to...". Курсор окна дизассемблера перейдёт на вызов `IsDebuggerPresent` из функции `main`.

7. В окне дизассемблера левым щелчком мыши выберите инструкцию `TEST EAX,EAX`, которая следует за вызовом `IsDebuggerPresent`. Установите на ней точку останова нажатием F2.

8. Нажмите F9, чтобы продолжить работу тестового приложения. Должна сработать наша точка останова.

9. Измените значение регистра EAX на 0. Для этого двойным щелчком мыши выберите значение регистра EAX в окне "Registers (FPU)" (регистры). Откроется диалог "Modify EAX" (изменение EAX), как на иллюстрации 3-26. Затем введите значение 0 в ряд "Signed" (знаковый), столбец "EAX". Нажмите кнопку "OK".

10. Нажмите F9, чтобы приложение работало дальше.

![Изменение регистра EAX](register-modify-ollydbg.png)

**Иллюстрация 3-26.** *Изменение значения регистра EAX*

После изменения значения регистра процессора, тестовое приложение не обнаружит отладчик на текущей итерации цикла `while`. Однако, проверка `IsDebuggerPresent` произойдёт на следующей итерации, и OllyDbg будет обнаружен. Следовательно, необходимо изменение регистра вручную перед каждой такой проверкой, что неудобно.

Другой способ обойти проверку `IsDebuggerPresent` - модифицировать код тестового приложения. Он уже загружен в память процесса, а у OllyDbg есть возможность её чтения и записи.

Чтобы модифицировать код приложения, выполним следующие действия:

1. Запустите отладичк OllyDbg и тестовое приложение с проверкой `IsDebuggerPresent` под его управлением.

2. Найдите место вызова функции `IsDebuggerPresent` в коде.

3. Выберите левым щелчком мыши инструкцию `JE SHORT 01371810`, следующую сразу за `TEST EAX,EAX` (см. иллюстрацию 3-27). Нажмите клавишу пробел, чтобы открыть диалог "Assemble" её редактирования.

4. Измените инструкцию `JE SHORT 01371810` на `JNE SHORT 01371810` в диалоге, как показано на иллюстрации 3-27. После этого нажмите кнопку "Assemble".

5. Нажмите F9, чтобы продолжить работу тестового приложения.

![Редактирование кода](byte-hack-ollydbg.png)

**Иллюстрация 3-27.** *Диалог редактирования инструкции*

После этих действий тестовое приложение больше не обнаруживает отладчик.

Что означает замена инструкции `JE` на `JNE`? Рассмотрим, какой C++ соответствует каждому варианту. Исходная инструкция `JE` соответствует следующему оператору `if`:
```C++
if (IsDebuggerPresent())
{
    printf("debugger detected!\n");
    exit(EXIT_FAILURE);
}
```
После замены инструкции на `JNE` мы получили следующий код:
```C++
if ( ! IsDebuggerPresent())
{
    printf("debugger detected!\n");
    exit(EXIT_FAILURE);
}
```
Другими словами, мы инвертировали условие оператора `if`. Теперь если к тестовому приложению не подключён отладчик, оно будет звершено с сообщением "debugger detected!" (отладчик обнаружен) в консоль. Если же отладчик подключён, приложение продолжит свою работу.

После перезапуска тестового приложения, модификацию кода придётся повторить. Чтобы этого избежать, можно воспользоваться плагином [**OllyDumpEx**](http://low-priority.appspot.com/ollydumpex) отладчика OllyDbg. Он позволяет сохранить отредактированный код в исполняемый файл.

Для установки плагина OllyDumpEx выполните следующее:

1. Скачайте архив с лпгином с сайта разработчика.

2. Распакуйте архив в папку установки OllyDbg. По-умолчанию это:<br/>
```
C:\Program Files (x86)\odbg200
```
3. Проверьте путь до папки с плагинами в настройке OllyDbg. Для этого выберите пункт “Options” ➤ “Options...” главного меню. Откроется диалог "Options" (настройки). В левой его части выберите пункт “Directories” (каталоги). Поле "Plug-in directory" (каталог плагинов) должно соответствовать пути установки OllyDbg (например `C:\Program Files (x86)\odbg200`).

4. Перезапустите отладчик.

После этого появится новый пункт главного меню "Plug-ins" (плагины). Чтобы воспользоваться возможностью сохранения модифицированного кода приложения в исполняемый файл, выполните:

1. Выберите пункт главного меню “Plug-ins“ ➤ ”OllyDumpEx“ ➤ ”Dump process”. Откроется диалог "OllyDumpEx".

2. Нажмите кнопку "Dump" (выгрузить) в диалоге. Откроется диалог "Save Dump to File" (сохранение дампа в память).

3. Укажите путь к исполняемому файлу для сохранения кода.

После этого на жёстком диске будет создан исполняемый файл с модифицированным кодом приложения. Вы можете его запустить, как обычный EXE файл. Для простых приложений запуск произойдёт корректно. К сожалению, если вы работаете с большой и сложной игрой, она может завершиться с ошибкой после старта из дампа.

В интерфейсе WinAPI есть ещё одна функция для обнаружения отладчика - `CheckRemoteDebuggerPresent`. Она позволяет обнаружить отладчик, подключённый к указанному процессу. `CheckRemoteDebuggerPresent` может быть полезна, если система защиты и игра работают в разных процессах.

Обе функции `CheckRemoteDebuggerPresent` и `IsDebuggerPresent` проверяют данные PEB сегмента. `CheckRemoteDebuggerPresent` вызывает внутри себя функцию `NtQueryInformationProcess`, которая возвращает структуру типа [`PROCESS_BASIC_INFORMATION`](https://docs.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-ntqueryinformationprocess). Её второе поле - это указатель на структуру типа [`PEB`](https://docs.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-_peb). У `PEB` есть поле под названием `BeingDebugged`, значение которого равно 1, если к процессу подключен отладчик. Иначе значение поля равно 0.

#### CloseHandle

У функции `IsDebuggerPresent` есть два серьёзных недостатка. Во-первых, эту функцию легко обнаружить в исходном коде приложения и инвертировать условие проверки её результата. Во-вторых, достаточно просто изменить значение поля `BeingDebugged` в PEB сегменте, чтобы предотвратить обнаружение отладчика.

Есть более изящные способы проверки наличия отладчика с помощью WinAPI. Один из них - использование побочного эффекта функции `CloseHandle`. Обычно `CloseHandle` вызывается, чтобы сообщить ОС об окончании работы с каким-то объектом. После этого объект может быть удалён, либо к нему могут получить доступ другие процессы. Очевидно, что любое сложное приложение интенсивно использует `CloseHandle`.

Функция `CloseHandle` имеет единственный входной параметр - дескриптиор объекта. Если переданный дескриптор некорректен будет сгенерированно [**исключение**](http://www.cplusplus.com/doc/tutorial/exceptions) (exception) `EXCEPTION_INVALID_HANDLE`. То же самое произойдёт если процесс вызовет `CloseHandle` дважды для одного и того же дескриптора. Теперь важный момент - исключение генерируется только тогда, когда к процессу подключен отладчик. Если отладчика нет, исключения не будет, и функция вернёт код ошибки. Таким образом, мы можем следить за поведением функции и делать вывод о наличии отладчика.

Для обхода защиты, использующей `CloseHandle`, потребудется много работы. Прежде всего, надо отследить все вызовы функции. Затем надо отличить места, где с её помощью проверяется наличие отладчика. Во всех этих местах надо будет отредактировать код, например заменить вызов функции на `NOP` (no operation) инструкции.

Пример использования `CloseHandle`:
```C++
BOOL IsDebug()
{
    __try
    {
        CloseHandle((HANDLE)0x12345);
    }
    __except (GetExceptionCode() == EXCEPTION_INVALID_HANDLE ?
              EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
    {
        return TRUE;
    }
    return FALSE;
}
```
Для обработки исключения `EXCEPTION_INVALID_HANDLE` мы применили конструкцию **try-except**, которая отличается от **try-catch**, определённой в стандарте C++. Эта конструкция - расширение для C и C++ от Microsoft, которое является частью механизма [**Structured Exception Handling**](https://docs.microsoft.com/en-us/windows/win32/debug/structured-exception-handling) (SEH).

Изменим наше тестовое приложение из листинга 3-18. Добавим определение функции `IsDebug` (приведённое выше) и будем вызывать её вместо `IsDebuggerPresent` в цикле `while`. Результат приведён в файле `CloseHandle.cpp` из примеров к книге. Попробуйте его скомпилировать и протестировать с отладчиками OllyDbg и WinDbg. Приложение успешно обнаруживает WinDbg, но не OllyDbg. Это связано с тем, что OllyDbg имеет встроенный механизм для обхода этой защиты.

С помощью WinAPI функции `DebugBreak` можно сделать очень похожую проверку на наличие отладчика:
```C++
BOOL IsDebug()
{
    __try
    {
        DebugBreak();
    }
    __except (GetExceptionCode() == EXCEPTION_BREAKPOINT ?
              EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
    {
        return TRUE;
    }
    return FALSE;
}
```
В отличие от `CloseHandle`, `DebugBreak` всегда генерирует исключение `EXCEPTION_BREAKPOINT`. Если к приложению подключён отладчик, он обработает это исключение. Это значит, что блок `__except` приведённого выше кода не полчит управление. Если же отладчика нет, исключение должно быть обработано приложением. В этом случае, мы попадём в блок `__except`, и функция `IsDebug` вернёт значение `TRUE`.

Проверка отладчика через `DebugBreak` обнаруживает и OllyDbg, и WinDbg.

В WinAPI есть функция `DebugBreakProcess`, которая очень похожа на `DebugBreak`. Она позволяет сгенерировать исключение `EXCEPTION_BREAKPOINT` для указанного процесса. Это может быть полезно для реализации защиты, работающей в отдельном процессе.

#### CreateProcess

Есть метод запрещающий отладку процесса в принципе. Он связан со следующим ограничением ОС Windows: только один отладчик может быть подключён к процессу. Следовательно, если одна часть приложения подключается к другой в качестве отладчика, эта вторая часть становится защищённой. Метод известен, как **самоотладка** (self-debugging).

Идея заключается в разделении приложения на два отдельных процесса: родительский и дочерний. При этом возможны следующие разделения обязанностей:

1. Дочерний процесс отлаживает родительский, который в свою очередь выполняет алгоритмы защищаемого приложения (TestApplication в нашем случае). Этот подход описан в [статье](https://www.codeproject.com/Articles/30815/An-Anti-Reverse-Engineering-Guide#SelfDebugging).

2. Родительский процесс отлаживает дочерний. Дочерний выполняет алгоритмы защищаемого приложения.

Мы рассмотрим второй подход. Для создания дочернего процесса воспользуемся WinAPI функцией `CreateProcess`. Результат приведён в листинге 3-19.

**Листинг 3-19.** *Защита тестового приложения методом самоотладки*
```C++
#include <stdio.h>
#include <stdint.h>
#include <windows.h>
#include <string>

using namespace std;

static const uint16_t MAX_LIFE = 20;
static uint16_t gLife = MAX_LIFE;

void DebugSelf()
{
    wstring cmdChild(GetCommandLine());
    cmdChild.append(L" x");

    PROCESS_INFORMATION pi;
    STARTUPINFO si;
    ZeroMemory(&pi, sizeof(PROCESS_INFORMATION));
    ZeroMemory(&si, sizeof(STARTUPINFO));
    GetStartupInfo(&si);

    CreateProcess(NULL, (LPWSTR)cmdChild.c_str(), NULL, NULL, FALSE,
            DEBUG_PROCESS | CREATE_NEW_CONSOLE, NULL, NULL, &si, &pi);

    DEBUG_EVENT de;
    ZeroMemory(&de, sizeof(DEBUG_EVENT));

    for (;;)
    {
        if (!WaitForDebugEvent(&de, INFINITE))
            return;

        ContinueDebugEvent(de.dwProcessId,
                de.dwThreadId,
                DBG_CONTINUE);
    }
}

int main(int argc, char* argv[])
{
    if (argc == 1)
    {
        DebugSelf();
    }
    SHORT result = 0;

    while (gLife > 0)
    {
        result = GetAsyncKeyState(0x31);
        if (result != 0xFFFF8001)
            --gLife;
        else
            ++gLife;

        printf("life = %u\n", gLife);
        Sleep(1000);
    }

    printf("stop\n");
    return 0;
}
```
Иллюстрация 3-28 демонстрирует взаимодействие родительского и дочернего процессов.

![Взаимодействие процессов](self-debugging.png)

**Иллюстрация 3-28.** *Взаимодействие родительского и дочернего процессов*

Приложение из листинга 3-19 запускается в два этапа. Первый этап - пользователь щёлкает по иконке рабочего стола и приложение запускается без параметров командной строки. В этом случае следующее `if` условие будет истинным:
```C++
    if (argc == 1)
    {
        DebugSelf();
    }
```
Параметр `argv` функции `main` - это указатель на строку параметров командной строки. `argc` хранит их количество. Когда приложение запущено без параметров командной строки, `argc` равен 1, а строка `argv` содержит только имя запускаемого файла. Таким образом приложение вызовет функцию `DebugSelf`. Её алгоритм следующий:

1. Прочитать параметры командной строки и добавить к ним "x". Этот параметр сообщает дочернему процессу, что он был запущен из родительского:
```C++
wstring cmdChild(GetCommandLine());
cmdChild.append(L" x");
```

2. Создать дочерний процесс с помощью вызова `CreateProcess`. В эту функцию мы передаём флаг `DEBUG_PROCESS`, который означает что новый процесс будет отлаживаться родительским. Так же мы передаём флаг `CREATE_NEW_CONSOLE`, благодаря которому у дочернего процесса будет отдельная консоль. В ней вы сможете прочитать вывод нашего приложения.

3. Запустить бесконечный цикл `for`, в котором будем обрабатывать все события дочернего процесса.

Попробуйте запустить приложение из листинга 3-19 и подключиться к нему отладчиками OllyDbg и WinDbg. Ни одному из них это не удастся.

Наше тестовое приложение демонстрирует метод самоотладки в максимально простом и лаконичном виде. Его защиту очень просто обойти. Для этого достаточно запустить приложение из командной строки, передав параметром символ "x":
```
TestApplication.exe x
```
В этом случае приложение запустится без самоотладки и к нему можно будет подключиться.

В настоящей защите нельзя полагаться на число параметров командной строки. Вместо этого надо проверять их значение. Например родительский процесс может сгенерировать случайный ключ и передать его дочернему через вызов `CreateProcess`. Дочерний процесс проверяет корректность ключа при старте. Если ключ ошибочный, работа приложения завершается.

Есть более надёжные техники обмена информацией между родительским и дочерним процессом, чем параметры командной строки. Они описаны в официальной [документации](https://docs.microsoft.com/en-us/windows/win32/ipc/interprocess-communications) Microsoft.

### Операции с регистрами для обнаружения отладчиков

Все техники обнаружения отладчиков, использующие WinAPI функции, имеют серьёзный недостаток - отследить места их вызовов достаточно легко. Даже если вы используете `CloseHandle` против отладки, и ваше приложение имеет 500 таких вызовов, такую защиту можно обойти за предсказуемое время.

Есть несколько техник, лишённых этого недостатка. Они основаны на манипуляции регистрами процессора. Доступ к этим регистрам можно получить через ассемблерные вставки или встроенные функции компилятора. Преимущество такого подхода в том, что анализ таблицы символов не поможет в поиске проверок на наличие отладчика. Из-за этого их намного сложнее обнаружить.

#### Флаг BeingDebugged

Рассмотрим как устроена WinAPI функция `IsDebuggerPresent` внутри. Мы знаем, что онм проверяет данные PEB сегмента. Возможно, мы сможем повторить её алгоритм.

Выполним следующие шаги для исследования `IsDebuggerPresent`:

1. Запустите OllyDbg.

2. Запустите из него тестовое приложение из листинга 3-18.

3. Найдите место вызова функции `IsDebuggerPresent` из `main`. Поставьте в нём точку останова. Продолжайте исполнение приложения.

4. Когда сработает точка останова нажмите F7, чтобы перейти к инструкциям функции `IsDebuggerPresent`.

Вы увидите код в окне дизассемблера OllyDbg, как на иллюстрации 3-29.

![Код IsDebuggerPresent](is-debugger-present.png)

**Иллюстрация 3-29.** *Инструкции функции IsDebuggerPresent*

Рассмотрим каждую инструкцию функции `IsDebuggerPresent`:

1. Прочитать линейный (или абсолютный) адрес TEB сегмента, соответствующего текущему потоку, в регистр EAX. Как мы уже знаем, регистр FS всегда указывает на сегмент TEB, а по смещению 0x18 в нём лежит собственный линейный адрес.

2. Прочитать линейный адрес сегмента PEB в регистр EAX. Он хранится по смещению 0x30 в регистре TEB.

3. Прочитать значение со смещением 0x2 из сегмента PEB в EAX регистр. По этому смещению хранится флаг `BeingDebugged`, по значению которого можно определить наличие отладчика.

4. Вернуться из функции.

Повторим рассмотренный алгоритм в коде нашего тестового приложения. Результат приведён в листинге 3-20.

**Листинг 3-20.** *Обнаружение отладчика через прямой доступ к PEB сегменту*
```C++
#include <stdio.h>

int main()
{
    SHORT result = 0;

    while (gLife > 0)
    {
        int res = 0;
        __asm
        {
            mov eax, dword ptr fs:[18h]
            mov eax, dword ptr ds:[eax+30h]
            movzx eax, byte ptr ds:[eax+2h]
            mov res, eax
        };
        if (res)
        {
            printf("debugger detected!\n");
            exit(EXIT_FAILURE);
        }
        result = GetAsyncKeyState(0x31);
        if (result != 0xFFFF8001)
            --gLife;
        else
            ++gLife;

        printf("life = %u\n", gLife);
        Sleep(1000);
    }
    printf("stop\n");
    return 0;
}
```
Сравните наш код и инструкции процессора на иллюстрации 3-29. Они почти одинаковы. Единственное отличие - это последняя инструкция. В нашем коде значение флага `BeingDebugged` присваивается переменной `res`. Сразу после ассемблерной вставки она проверяется в `if` условии.

Если вы поместите такую ассемблерную вставку и проверку на отладчик в нескольких местах приложения, их будет труднее найти чем вызовы функции `IsDebuggerPresent`. Можем ли мы в этом случае избежать дублирования кода? Это хороший вопрос. Если в следующих версиях Windows поменяется структура TEB или PEB сегмента, исправление придётся вносить в нескольких местах.

Есть несколько способов избежать дублирования кода в ассемблерных вставках. Очевидно, что в нашем случае мы не можем просто поместить этот код в обычную C++ функцию. Она обязательно попадёт в таблицу символов, по которой легко отследить все места её вызовов.

Первое решение - вынести код ассемблерной вставки в C++ функцию и пометить её ключевым словом `__forceinline`. Такая функция называется **встроенной**. Компилятор будет вставлять её код в места вызовов. К сожалению, `__forceinline` игнорируется в нескольких случаях:

1. Приложение компилируется в конфигурации "Debug" (отладка).

2. Если встраиваемая функция содержит рекурсивные вызовы (она вызывает саму себя).

3. Если встраиваемая функция вызывает подпрограмму `alloca`.

Ключевое слово `__forceinline` работает только в конфигурации сборки "Release" (релиз), что может быть неудобно. В этом случае выходной исполняемый файл не содержит отладочной информации.

Второе решение - использовать макрос препроцессора. Компилятор вставляет тело макроса в каждое место исходного кода, где упоминается его имя. В этом случае поведение компилятиора не зависит от конфигурации сборки.

Листинг 3-21 демонстрирует проверку флага `BeingDebugged` с помощью ассемблерной вставки, завёрнутой в макрос препроцессора.

**Листинг 3-21.** *Обнаружение отладчика через прямой доступ к PEB сегменту*
```C++
#include <stdio.h>

#define CheckDebug() \
int isDebugger = 0; \
{ \
__asm mov eax, dword ptr fs : [18h] \
__asm mov eax, dword ptr ds : [eax + 30h] \
__asm movzx eax, byte ptr ds : [eax + 2h] \
__asm mov isDebugger, eax \
} \
if (isDebugger) \
{ \
printf("debugger detected!\n"); \
exit(EXIT_FAILURE); \
}

int main()
{
    SHORT result = 0;

    while (gLife > 0)
    {
        CheckDebug();

        result = GetAsyncKeyState(0x31);
        if (result != 0xFFFF8001)
            --gLife;
        else
            ++gLife;
    }

    printf("stop\n");

    return 0;
}
```
Обратите внимание на использование макроса `CheckDebug` в функции `main`. Это выглядит, как обычный вызов функции. Однако, поведение макроса кардинально отличается от функции. Ещё на этапе обработки препроцессора, который идёт до компиляции, код `main` будет преобразован в следующий:
```C++
int main()
{
    SHORT result = 0;

    while (gLife > 0)
    {
        int res = 0;
        __asm
        {
            mov eax, dword ptr fs:[18h]
            mov eax, dword ptr ds:[eax + 30h]
            movzx eax, byte ptr ds:[eax + 2h]
            mov res, eax
        };
        if (res)
        {
            printf("debugger detected!\n");
            exit(EXIT_FAILURE);
        }
        ...
```
Учитывайте эту особенность макросов, когда будете использовать их в своих проектах. Если в теле макросе есть ошибка, компилятор будет указывать на строку его использования, а не определения.

Как вы помните, мы не можем использовать ассемблерные вставки при компиляции 64-разрядных приложений на Visual Studio C++. В этом случае можно переписать макрос `CheckDebug` следующим образом:
```C++
#include <winternl.h>

#define CheckDebug() \
{ \
PTEB pTeb = reinterpret_cast<PTEB>(__readgsqword(0x30)); \
PPEB pPeb = pTeb->ProcessEnvironmentBlock; \
if (pPeb->BeingDebugged) \
{ \
printf("debugger detected!\n"); \
exit(EXIT_FAILURE); \
} \
}
```
Не забудьте включить заголовчный файл `winternl.h`, в котором определены структуры `TEB` и `PEB`, а также указатели на них (`PTEB` и `PPEB`).

Защита, приведённая в листинге 3-21, выглядит достаточно надёжной. Так ли это и сможем ли мы её обойти? На самом деле сможем и достаточно легко. Вместо того, чтобы искать в коде проверки и инвертировать `if` условия, мы можем просто изменить флаг `BeingDebugged` в PEB сегменте. Для этого выполним следующие шаги:

1. Запустите отладчик OllyDbg.

2. Из него запустите тестовое приложение из листинга 3-21.

3. Нажмите Alt+M, чтобы открыть карту памяти процесса. В ней найдите сегмент “Process Environment Block” (PEB).

4. Дважды щёлкните левой кнопкой мыши по сегменту PEB. Откроется окно "Dump - Process Environment Block". В нём найдите значение флага “BeingDebugged".

5. Щёлкните левой кнопкой мыши по флагу “BeingDebugged", чтобы его выделить. Нажмите Ctrl+E - откроектся диалог "Edit data at address..." (редактирование данных по адресу).

6. Измените значение поля "HEX+01" с "01" на "00" и нажмите кнопку "OK", как изображено на иллюстрации 3-30.

![Редактирование флага BeingDebugged](beingdebugged-ollydbg.png)

**Иллюстрация 3-29.** *Диалог редактирования флага "BeingDebugged"*

Если вы продолжите выполнение, приложение не обнаружит подключённый отладчик. Обход этой защиты выглядит очень просто. Поэтому рассмотрим более надёжный метод.

#### INT 3

Как вы помните, WinAPI функция `DebugBreak` позволяет обнаружить отладчик по тому, кто обрабатывает сгенерированное ей исключение. Исследуем инструкции этой функции и попробуем повторить их с помощью ассемблерной вставки. Для этого выполните уже рассмотренные нами шаги, когда мы исследовали `IsDebuggerPresent`. Если вы сделаете всё правильно, вы обнаржите, что функция `DebugBreak` состоит из единственной инструкции процессора `INT 3`. Она генерирует исключение `EXCEPTION_BREAKPOINT`.

Перепишем функцию `IsDebug` так, чтобы она использовала инструкцию `INT 3` вместо вызова `DebugBreak`:
```C++
BOOL IsDebug()
{
    __try
    {
        __asm int 3;
    }
    __except (GetExceptionCode() == EXCEPTION_BREAKPOINT ?
            EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
    {
        return FALSE;
    }
    return TRUE;
}
```
Чтобы усложнить поиск вызовов функции `IsDebug`, мы могли бы применить ключевое слово `__forceinline` в её определении. Однако, в этом случае компилятор его проигнорирует. Дело в том, что обработчик `__try`/`__except` неявно выделяет блок памяти с помощью функции `alloca`. Как вы помните, это нарушает условие использования `__forceinline`.

Правильное решение - использовать макрос:
```C++
#define CheckDebug() \
bool isDebugger = true; \
__try \
{ \
    __asm int 3 \
} \
__except (GetExceptionCode() == EXCEPTION_BREAKPOINT ? \
          EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) \
{ \
    isDebugger = false; \
} \
if (isDebugger) \
{ \
    printf("debugger detected!\n"); \
    exit(EXIT_FAILURE); \
}
```
Для 64-разрядного приложения воспользуемся встроенной функцией компилятора `__debugbreak()`:
```C++
#define CheckDebug() \
bool isDebugger = true; \
__try \
{ \
	__debugbreak(); \
} \
__except (GetExceptionCode() == EXCEPTION_BREAKPOINT ? \
		  EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) \
{ \
	isDebugger = false; \
} \
if (isDebugger) \
{ \
	printf("debugger detected!\n"); \
	exit(EXIT_FAILURE); \
}
```
Вы можете найти исходный код `Int3.cpp` тестового приложения, защищенного этим методом, в архиве примеров к книге. Чтобы обойти эту защиту вам придётся найти все `if` проверки в коде и инвертировать их.

У OllyDbg есть функция поиска инструкций процессора в памяти отлаживаемого процесса. Для этого нажмите Ctrl+F в окне дизассемблера и в открывшемся диалоге введите значение "INT3". После этого нажмите кнопку "Search" (поиск).

В машинном коде инструкция `INT 3` представляется шестнадцатеричным числом 0xCC. В результате поиска OllyDbg вы получите список инструкций, содержащих 0xCC в своем [**коде операции**](https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%B4_%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%B8) (opcode). Далеко не все из этих инструкций являются `INT 3`, но вам придётся их проверить.

### Проверка таймера

Во время отладки приложения, пользователь часто останавливает его выполнение. Обычно это нужно чтобы проверить значения переменных, дампа памяти или дизассемблированный исполняемый код. На этой особенности строится достаточно надёжная защита. Идея заключается в том, чтобы измерять время между контрольными точками в коде приложения. Если остановок выполнения не было, это время будет достаточно небольшим. В противном случае можно с уверенностью заключить, что приложение работает под отладчиком.

#### WinAPI функции

Есть несколько WinAPI функций, которые позволяют прочитать текущее время:

1. `GetTickCount` - возвращает количество миллисекунд с момента запуска ОС.

2. `GetLocalTime` - возвращает текущее время с учётом настройки часового пояса.

3. `GetSystemTime` - возвращает текущее всемирное координированное время (UTC).

Вы можете использовать любую из этих функций для замеров времени между контрольными точками. Листинг 3-22 демонстрирует решение на `GetTickCount`.

**Листинг 3-22.** *Замер времени между контрольными точками приложения с помощью GetTickCount*
```C++
#include <stdio.h>
#include <stdint.h>
#include <windows.h>

static const DWORD MAX_DELTA = 1020;

static const uint16_t MAX_LIFE = 20;
static uint16_t gLife = MAX_LIFE;

int main()
{
    SHORT result = 0;

    DWORD prevCounter = GetTickCount();

    while (gLife > 0)
    {
        if (MAX_DELTA < (GetTickCount() - prevCounter))
        {
            printf("debugger detected!\n");
            exit(EXIT_FAILURE);
        }
        prevCounter = GetTickCount();

        result = GetAsyncKeyState(0x31);
        if (result != 0xFFFF8001)
            --gLife;
        else
            ++gLife;

        printf("life = %u\n", gLife);
        Sleep(1000);
    }

    printf("stop\n");

    return 0;
}
```
В этом примере мы замеряем время между итерациями цикла `while`. Если остановок не было, каждая итерация занимает чуть больше одной секунды. Если задержка оказывается больше константы `MAX_DELTA`, равной 1020 миллисекунд, скорее всего была остановка. В этом случае приложение завершается.

Чтобы обойти эту защиту, надо найти вызовы `GetTickCount` в коде приложения с помощью таблицы символов. Затем будет достаточно инвертировать проверку в операторе `if`.

#### Счётчики процессора

Текущее время можно читать не только с помощью WinAPI функций. У процессора есть несколько аппаратных счётчиков. Один из них Time Stamp Counter (TSC) считает количество тактовых сигналов (или циклов) с момента старта процессора. Его значение можно прочитать с помощью ассемблерных инструкций или встроенной функции компилятора.

Листинг 3-23 демонстрирует использование счётчика TSC для замеров времени между контрольными точками приложения.

**Листинг 3-23.** *Замер времени между контрольными точками приложения с помощью TSC*
```C++
#include <stdio.h>
#include <stdint.h>
#include <windows.h>

static const DWORD64 MAX_DELTA = 2650000000;

static const uint16_t MAX_LIFE = 20;
static uint16_t gLife = MAX_LIFE;

#define ReadRdtsc(result) \
{ \
__asm cpuid \
__asm rdtsc \
__asm mov dword ptr[result + 0], eax \
__asm mov dword ptr[result + 4], edx \
}

int main()
{
	SHORT result = 0;

	DWORD64 prevCounter = 0;
	ReadRdtsc(prevCounter);

	while (gLife > 0)
	{
		DWORD64 counter = 0;
		ReadRdtsc(counter);

		if (MAX_DELTA < (counter - prevCounter))
		{
			printf("debugger detected!\n");
			exit(EXIT_FAILURE);
		}
		ReadRdtsc(prevCounter);

		result = GetAsyncKeyState(0x31);
		if (result != 0xFFFF8001)
			--gLife;
		else
			++gLife;

		printf("life = %u\n", gLife);
		Sleep(1000);
	}

	printf("stop\n");

	return 0;
}
```
Для 64-разрядного приложения функция `main` будет выглядеть следующим образом:
```C++
int main()
{
	SHORT result = 0;

	DWORD64 prevCounter = __rdtsc();

	while (gLife > 0)
	{
		DWORD64 counter = __rdtsc();

		if (MAX_DELTA < (counter - prevCounter))
		{
			printf("debugger detected!\n");
			exit(EXIT_FAILURE);
		}
		prevCounter = __rdtsc();

		result = GetAsyncKeyState(0x31);
		if (result != 0xFFFF8001)
			--gLife;
		else
			++gLife;

		printf("life = %u\n", gLife);
		Sleep(1000);
	}

	printf("stop\n");

	return 0;
}
```
Алгоритм этой проверки точно такой же, как и в примере из листинга 3-22. Отличие только способе замера времени и величине константы `MAX_DELTA`. В данном случае мы замеряем не миллисекунды, а тактовые сигналы процессора. Каждая итерация цикла длится примерно два с половиной миллиона циклов. Из-за этого пороговое значение `MAX_DELTA` получилось намного больше.

Обойти эту защиту труднее. Необходимо найти в коде все инструкции `rdtsc` и выяснить, есть ли после каждой из них проверка на временную задержку.

## Защита приложения от ботов

У Windows есть механизм **Security Descriptors** (SD) (дескрипторы безопасности) для ограничения доступа к системным объектам (например процессам). Он подробно описан в [статье](http://helgeklein.com/blog/2009/03/permissions-a-primer-or-dacl-sacl-owner-sid-and-ace-explained/?PageSpeed=noscript).

Следующие примеры демонстрируют использование SD:

* http://www.cplusplus.com/forum/windows/96406

* http://stackoverflow.com/questions/6185975/prevent-user-process-from-being-killed-with-end-process-from-process-explorer/10575889#10575889

В них приложение защищается с помощью **Discretionary Access Control List** (DACL) (дискреционный список контроля доступа).

К сожалению, механизм SD не может защитить приложение, если процесс запущенный с правами администратора пытается получить к нему доступ. Поэтому разработчику приходится реализовывать собственные механизмы для защиты данных своего приложения.

Надёжная система защиты должна решать две задачи:

1. Сокрытие данных от сканнеров памяти (например Cheat Engine).

2. Проверка корректности данных для предотвращения их несанкционированного изменения.

### Сокрытие данных

Рассмотрим техники сокрытия данных от сканнеров памяти.

#### XOR шифр

Один из самых прямолинейных способов скрыть данные - это зашифровать их. Если состояния игровых объектов будут хранится зашифрованными в памяти процесса, бот по-прежнему сможет их прочитать. Но он не сможет не восстановить их значение.

Самый простой шифр - это **XOR**. Листинг 3-24 демонстрирует его использование.

**Листинг 3-24.** *Защита данных приложения шифром XOR*
```C++
#include <stdio.h>
#include <stdint.h>
#include <windows.h>

using namespace std;

inline uint16_t maskValue(uint16_t value)
{
	static const uint16_t MASK = 0xAAAA;
	return (value ^ MASK);
}

static const uint16_t MAX_LIFE = 20;
static uint16_t gLife = maskValue(MAX_LIFE);

int main(int argc, char* argv[])
{
	SHORT result = 0;

	while (maskValue(gLife) > 0)
	{
		result = GetAsyncKeyState(0x31);
		if (result != 0xFFFF8001)
			gLife = maskValue(maskValue(gLife) - 1);
		else
			gLife = maskValue(maskValue(gLife) + 1);

		printf("life = %u\n", maskValue(gLife));
		Sleep(1000);
	}

	printf("stop\n");

	return 0;
}
```
Функция `maskValue` шифрует данные при первом вызове и дешифрует при втором. Чтобы получить зашифрованное значение, мы используем **операцию XOR** (также известную как "исключающее ИЛИ") над данными и ключём. В качестве ключа используется константа `MASK`. Для расшифровки значения переменной `gLife`, мы вызываем `maskValue` повторно.

Если запустить приложение и попробовать найти переменную `gLife` по её значению с помощью Cheat Engine, это не получится. Однако, если вам известно значение константы `MASK`, задача значительно упрощается. Всё что вам нужно, это вручную или с помощью стандартного калькулятора Windows рассчитать зашифрованное значение `gLife` и задать его сканнеру для поиска.

Наша реализация шифра XOR в целях демонстрации подхода упрощена. Если вы планируете использовать её для защиты своих приложений, её следует доработать.

Прежде всего будет полезно поместить алгоритм шифрования в [шаблон класса](https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B_C%2B%2B) (template) C++. Для этого класса следует определить арифметические операторы и присваивание. Тогда вы сможете шифровать данные неявно, и код будет выглядеть намного компактнее. Например так:
```C++
XORCipher<int> gLife(20);
gLife = gLife - 1;
```
Ещё одно улучшение - генерация случайного ключа шифрования (зачение константы `MASK` в нашем примере) в конструкторе шаблона класса. Благодаря этому его будет труднее найти и применить для сканирования памяти.

#### AES шифр

Даже с нашими улучшениями шифр XOR крайне прост для взлома. Чтобы лучше защитить данные вашего приложения, понадобится шифр посложнее. WinAPI предоставляет ряд [криптографических функций](https://docs.microsoft.com/en-us/windows/win32/seccrypto/cryptography-functions). Среди них есть достаточно современный шифр AES. Попробуем применить его для нашего тестового приложения, как демонстрирует листинг 3-25.

**Листинг 3-25.** *Защита данных приложения шифром AES*
```C++
#include <stdint.h>
#include <stdio.h>
#include <windows.h>
#include <string>

#pragma comment (lib, "advapi32")
#pragma comment (lib, "user32")

using namespace std;

static const uint16_t MAX_LIFE = 20;
static uint16_t gLife = 0;

HCRYPTPROV hProv;
HCRYPTKEY hKey;
HCRYPTKEY hSessionKey;

#define kAesBytes128 16

typedef struct {
    BLOBHEADER  header;
    DWORD       key_length;
    BYTE        key_bytes[kAesBytes128];
} AesBlob128;

static const BYTE gCipherBlockSize = kAesBytes128 * 2;
static BYTE gCipherBlock[gCipherBlockSize] = {0};

void CreateContex()
{
    if (!CryptAcquireContext(&hProv, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT))
    {
        printf("CryptAcquireContext() failed - error = 0x%x\n", GetLastError());
    }
}

void CreateKey(string& key)
{
    AesBlob128 aes_blob;
    aes_blob.header.bType = PLAINTEXTKEYBLOB;
    aes_blob.header.bVersion = CUR_BLOB_VERSION;
    aes_blob.header.reserved = 0;
    aes_blob.header.aiKeyAlg = CALG_AES_128;
    aes_blob.key_length = kAesBytes128;
    memcpy(aes_blob.key_bytes, key.c_str(), kAesBytes128);

    if (!CryptImportKey(hProv,
                      reinterpret_cast<BYTE*>(&aes_blob),
                      sizeof(AesBlob128),
                      NULL,
                      0,
                      &hKey))
    {
        printf("CryptImportKey() failed - error = 0x%x\n", GetLastError());
    }
}

void Encrypt()
{
    unsigned long length = kAesBytes128;
    memset(gCipherBlock, 0, gCipherBlockSize);
    memcpy(gCipherBlock, &gLife, sizeof(gLife));

    if (!CryptEncrypt(hKey, 0, TRUE, 0, gCipherBlock, &length, gCipherBlockSize))
    {
        printf("CryptEncrypt() failed - error = 0x%x\n", GetLastError());
        return;
    }
    gLife = 0;
}

void Decrypt()
{
    unsigned long length = gCipherBlockSize;

    if (!CryptDecrypt(hKey, 0, TRUE, 0, gCipherBlock, &length))
    {
        printf("Error CryptDecrypt() failed - error = 0x%x\n", GetLastError());
        return;
    }
    memcpy(&gLife, gCipherBlock, sizeof(gLife));
    memset(gCipherBlock, 0, gCipherBlockSize);
}

int main(int argc, char* argv[])
{
    CreateContex();

    string key("The secret key");

    CreateKey(key);

    gLife = MAX_LIFE;

    Encrypt();

    SHORT result = 0;

    while (true)
    {
        result = GetAsyncKeyState(0x31);

        Decrypt();

        if (result != 0xFFFF8001)
            gLife = gLife - 1;
        else
            gLife = gLife + 1;

        printf("life = %u\n", gLife);

        if (gLife == 0)
            break;

        Encrypt();

        Sleep(1000);
    }
    printf("stop\n");
    return 0;
}
```
Алгоритм работы приложения следующий:

1. Создать контекст для криптографического алгоритма с помощью функции `CreateContex`. Это обёртка над WinAPI функцией `CryptAcquireContext`. Контекст представляет собой комбинацию двух компонентов: **контейнер ключей** и **Cryptography Service Provider** (CSP) (криптопровайдер). Контейнер содержит все ключи, принадлежащие пользователю. CSP - это программный модуль, реализующий криптографический алгоритм.

2. Добавить ключ шифрования в CSP с помощью функции `CreateKey`. Функция принимает в качестве входного параметра строку со значением ключа. Из неё создается структура BLOB (расшифровывается как Binary Large Object, т.е. двоичный большой объект). Эта структура передаётся в CSP с помощью WinAPI вызова `CryptImportKey`.

3. Инициализировать переменную `gLife` и зашифровать её функцией `Encrypt`. Внутри себя она вызывает WinAPI функцию `CryptEncrypt`. Зашифрованное значение сохраняется в глобальномбайтовом массиве `gCipherBlock`. При этом значение переменной `gLife` зануляем, чтобы сканнер памяти не смог её найти.

4. Перед каждым использованием переменной `gLife` расшифровываем её значение функцией `Decrypt`, которая вызывает внутри себя WinAPI функцию `CryptDecrypt`. После работы с `gLife` мы снова её шифруем.

В чём преимущество шифра AES по сравнению с XOR? На самом деле алгоритм поиска зашифрованного значения в памяти одинаков в обоих случаях:

1. Восстановить ключ шифрования.

2. Применить ключ для шифровки текущего значения переменной.

3. Искать зашифрованное значение в памяти процесса с помощью сканнера.

XOR шифр работает намного быстрее, но его проще взломать. Для этого есть два варианта: перебор всех возможных ключей или поиск ключа в памяти процесса. В некоторых случаях первый подход будет быстрее и проще. Для шифра AES есть долько один вариант - поиск ключа в памяти. Чтобы взломать его перебором, понадобится значительное время. Поэтому надёжность защиты определяется только тем, насколько хорошо спрятан ключ. Надёжным решением может быть генерация нового ключа при каждом запуске приложения.

У шифра AES есть еще одно достоинство. После восстановления ключа, необходимо точно повторить алгоритм шифрования. Только так возможно получить зашифрованное значение из того, что например отображается в окне игры. Шифр XOR настолько прост, что вы можете вычислить зашированное значение в уме. Но AES использует несколько этапов применения операций XOR и битового сдвига. Потребуется специальное приложение для выполнения шифрования, а это требует времени и знаний.

Оба шифра XOR и AES скрывают данные приложения от сканирования. Если эти данные удастся найти, бот сможет их читать и писать без каких-либо проблем. В некоторых случаях это может оказаться достаточным для его работы.

### Проверка корректности данных

Теперь рассмотрим способы защиты данных приложения от изменения. Идея такой защиты - дублировать данные и периодически сравнивать их и копию. Каждый раз когда данные модифицируются, то же самое должно происходить с их копией. Если в какой-то момент времени данные и копия различаются, мы можем заключить, что они были несанкционированно изменены.

Если значения копии и данных всегда одинаковы, копию будет легко найти в памяти процесса с помощью сканнера. Чтобы обойти защиту, боту будет достаточно менять её и данные. Таким образом наша задача заключается в том, чтобы скрыть копию данных. Мы можем применить шифрование, но есть более быстрый способ - **хэширование** (hashing).

Хэширование очень похоже на шифрование. Алгоритм берёт исходные данные и конвертирует их в другое представление. Различие заключается в том, что шифрование обратимо, т.е. данные можно расшифровать и получить исходное значение. Опреация хэширования необратима. Благодаря этому свойству алгоритмы хэширования работают намного быстрее.

Проверка целостности данных с помощью хэширования приведена в листинге 3-26.

**Листинг 3-26.** *Проверка целостности данных приложения*
```C++
#include <stdio.h>
#include <stdint.h>
#include <windows.h>
#include <functional>

using namespace std;

static const uint16_t MAX_LIFE = 20;
static uint16_t gLife = MAX_LIFE;

std::hash<uint16_t> hashFunc;
static size_t gLifeHash = hashFunc(gLife);

void UpdateHash()
{
	gLifeHash = hashFunc(gLife);
}

__forceinline void CheckHash()
{
	if (gLifeHash != hashFunc(gLife))
	{
		printf("unauthorized modification detected!\n");
		exit(EXIT_FAILURE);
	}
}

int main(int argc, char* argv[])
{
	SHORT result = 0;

	while (gLife > 0)
	{
		result = GetAsyncKeyState(0x31);

		CheckHash();

		if (result != 0xFFFF8001)
			--gLife;
		else
			++gLife;

		UpdateHash();
		
		printf("life = %u\n", gLife);

		Sleep(1000);
	}

	printf("stop\n");

	return 0;
}
```
В этом примере мы добавили вспомогательную переменную `gLifeHash`, которая хранит хэшированное значение `gLife`. Для вычисления хэша используется функция `hash` из **стандартной библиотеки шаблонов** (STL) стандарта C++11.

На каждой итерации `while` цикла мы сравниваем хэшированное и текущее значение переменной `gLife` в функции `CheckHash`. Если они различаются, мы делаем вывод о несанкционированном изменении переменной. После проверки мы работаем с `gLife` точно так же, как и раньше. Затем пересчитываем значение `gLifeHash` с помощью функции `UpdateHash`.

Попробуйте скомпилировать и запустить этот пример. Если вы модифицируйте значение переменной `gLife` с помощью сканнера Cheat Engine, приложение завершит свою работу.

Обойти такую защиту возможно. Для этого бот должен одновременно модифицировать переменные `gLife` и `gLifeHash`. Но здесь есть подводные камни. Во-первых, необходимо выбрать правильный момент времени для модификации. Это не должно произойти во проверки `if` в функции `CheckHash`, иначе изменение будет обнаружено. Во-вторых, хэшированное значение не так то просто найти. Если алгоритм хэширования известен, вы можете рассчитать хэш исходного значения и найти его с помощью сканера памяти. В большинстве случаев алгоритм неизвестен. Чтобы его восстановить необходимо проанализировать дизассемблированный код приложения. С другой стороны, если удалось найти все проверки `if` в коде (в нашем примере она в функции `CheckHash`), их можно просто инвертировать. Если `CheckHash` будет встроенной или её заменить макросом, то найти проверки `if` может быть затруднительно.

Самая надёжная защита игровых данных от несанкицонированного изменения - хранить их на стороне сервера. Тогда клиент будет получать эти данные только для визуализации текущего состояния игры. Их изменение ботом повлияет только на картинку в окне приложения. Данные на стороне сервера останутся неизменными. Их можно рассматривать как всегда верные и игнорировать данные от клиента в случае их отличия.

## Выводы

Мы рассмотрели методы защиты памяти процесса игрового приложения. Большинство из них можно реализовать с помощью WinAPI функций. Однако, в некоторых случаях операции с регистрами позволят лучше скрыть алгоритм защиты от исследования.

Мы познакомились с методами защиты от отладки и сканирования памяти, а также с техниками предотвращения несанкционированного изменения данных прложения.



