# Приёмы защиты от внутриигровых ботов

Мы реализовали внутриигрового бота для Diablo 2 и узнали, как он получает доступ к памяти процесса игры. Теперь рассмотрим способы защиты от этого типа ботов.

Есть две группы методов защиты от внутриигровых ботов:

* Защита приложения от реверс-инжиниринга.

* Блокировака алгоритмов бота.

Первая группа методов разрабатывается очень давно: со времён первых версий коммерческого ПО, которое нужно было защищать от нелицензионного распространения. Эти методы хорошо известны и документированны в Интернете. Их основаня задача - усложнить анализ приложения с помощью отладчика и дизассемблера.

Вторая группа методов защищает данные процесса игрового приложения от чтения и записи. Таким образом боту становится сложнее читать состояние объектов и внедрять свои действия.

Некоторые методы защиты могут относится сразу к обоим группам.

## Тестовое приложение

Вспомним архитетуру клиент-сервер современных онлайн игр. Клиент выполняется на компьютере пользователя и обменивается сообщениями с игровым сервером. Большая часть методов защиты от внутриигровых ботов работают на стороне клиента.

Чтобы познакомиться с методами защиты, напишем простое приложение, имитирующее состояние игрового объекта. Также разработаем простейшего внутриигрового бота, который подключается к нашему приложению и управляет им.

Алгоритм тестового приложения может быть следующим:

1. При старте присвоить параметру объекта (например уровень здоровья) максимально допустимое значение.

2. В цикле проверять состояние горячей клавиши "1".

3. Если пользователь не нажимает клавишу, уменьшать параметр объект. Иначе - увеличивать.

4. Если параметр объекта оказался равень 0, завершить приложение.

Листинг 3-16 демонстрирует исходный код тестового приложения.

**Листинг 3-16.** *Запись нового значения параметра персонажа в память процесса*
```C++
TODO: Insert me
```
Уровень здоровья игрового объекта хранится в глобальной переменной `gLife`. При старте приложения мы присваиваем ей значение константы `MAX_LIFE` (равно 20).

В функции `main` есть цикл `while`, в котором мы проверяем состояние клавиши с помощью WinAPI функции `GetAsyncKeyState`. Код этой клавиши передаётся в функцию входным параметром. Виртуальный код клавиши "1" равен 0x31. Если вызов `GetAsyncKeyState` возвращает состояние "не нажато", переменная `gLife` уменьшается на 1. В противном случае - увеличивается также на 1. После этого идёт односекундная задержка, которая нужна чтобы пользователь успел отпустить клавишу.

Попробуйте скомпилировать тестовое приложение в конфигурации "Debug" (отладка) в Visual Studio и запустить его.

## Исследование памяти тестового приложения

Теперь напишем бота для нашего тестового приложения. Его алгоритм будет таким же, как и для игры Diablo 2 из прошлого раздела. Если параметр здоровья опускается ниже 10, бот симулирует нажатие клавиши "1".

Бот должен читать значение переменной `gLife`. Очевидно, мы не можем воспользоваться механизмом поиска объекта из бота для Diablo 2. Нам нужно провести полный анализ адресного пространства тестового приложения и разработать метод доступа к `gLife`. Хорошая новость в том, что это приложение очень простое и нам будет достаточно отладчика OllyDbg.

Чтобы найти сегмент, содержащий переменную `gLife` выполним следующие шаги:

1. 




