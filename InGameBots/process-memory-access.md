# Доступ к памяти процесса

Мы научились вручную искать переменную в памяти процесса. Пришло время написать код, для автоматизации этого поиска. Вутриигровые боты не могут использовать программу-отладчик (например OllyDbg). Вместо этого они должны сами реализовывать необходимые функции отладчика.

## Открытие процесса

Как вы помните, перед началом работы с памятью процесса к нему нужно подключить отладчик. После этого он получает полный доступ к адресному пространства процесса. Мы выполняли это действие через диалог интерфейса пользователя. То же самое должен уметь выполнять внутриигровой бот. Рассмотрим, какими WinAPI функциями он может воспользоваться для этого.

Практически все объекты и ресурсы Windows доступны через их дескрипторы. WinAPI функция `OpenProcess` возвращает дескриптор указнного процесса. У каждого процесса, запущенного в системе, есть уникальный номер или **идентификатор** (process identifier или PID). Его мы должны передать в `OpenProcess` входным параметром. Получив дескриптор, мы можем обращаться к памяти процесса с помощью других WinAPI функций.

Windows отвечает за распределение своих ресурсов между запущенными процессами. Один из этих ресурсов - память. Если любой процесс вегда будет иметь доступ к памяти других процессов, это может привести к сбоям в их работе. Система в целом будет ненадёжна. Поэтому ОС имеет специальный механизм защиты доступа к своим объектам. Рассмотрим его подробнее.

В архитектуре Windows разработчику пользовательских приложений предоставляются высокоуровневые абстракции к ресурсам ОС. Объекты Windows (например процессы) также используют эти абстракции. Дугими словами, одни объекты служат обёртками для системных ресурсов и предоставляют другим объектам единообразный интерфейс к этим ресурсам. Такой подход упрощает интерфейсы для разработки как системных библиотек Windows, так и пользовательских приложений.

Представим, что мы разрабатываем пользовательское приложение, например внутриигрового бота. Каким образом оно может взаимодействовать с каким-нибудь Windows объектом? Каждый объект представляет собой структуру, состоящую из **заголовка** (header) и **тела** (body). Тело содержит специфичные для данного типа объектов данные. Заголовок же метаинформацию о процессе, которая используется **Менеджером Объектов** (Object Manager). Именно он предоставляет доступ к ресусам ОС через соответствующие им объекты.

**Модель безопасности Windows** ограничивает процессам доступ к системным объектам и различным действиям, требущих прав администратора. Можно сказать, что Менеджер Объектов реализует модель безпасности Windows. Согласно ей, процесс должен иметь специалные привилегии, чтобы получить доступ к памяти другого через вызов `OpenProcess`. Управлять привилегиями процесса можно с помощью специального объека Windows под названием **маркер доступа** (access token).

Полный алгоритм подключеныия к процессу через WinAPI функцию `OpenProcess` выглядит следующим образом:

1. Получить дескриптор текущего процесса.

2. По дескриптору получить маркер доступа текущего процесса.

3. Предоставить привилегию `SE_DEBUG_NAME` для маркера доступа текущего процесса. Эта привилегия даёт право отлаживать другие процессы.

4. Получить дескриптор целевого процесса через вызов `OpenProcess`.

Приложение, реализующе этот алгоритм, должно быть запущено с правами администратора. Без них невозможно выполнить третий шаг и предоставить текущему процессу привилегию `SE_DEBUG_NAME` через WinAPI функцию `AdjustTokenPrivileges`.

Вам может показаться странным, что приложению, запущенному с правами администратора, надо предоставлять дополнительные права на отладку других процессов. В самом деле, логично предположить, что администратору ситемы по-умолчанию должны быть доступны все её возможности. Но это не означает, что любое запущенное им приложение должно нарушать модель безопасности Windows. Такое поведение может привести к нестабильной работе всей системы.

Листинг 3-1 демонстрирует код приложения, которое подключается к процессу с заданным PID.

**Листинг 3-1.** *Приложение OpenProcess.cpp*
```С++
#include <windows.h>
#include <stdio.h>

BOOL SetPrivilege(HANDLE hToken, LPCTSTR lpszPrivilege, BOOL bEnablePrivilege)
{
    TOKEN_PRIVILEGES tp;
    LUID luid;
    if (!LookupPrivilegeValue(NULL, lpszPrivilege, &luid))

    {
        printf("LookupPrivilegeValue error: %u\n", GetLastError());
        return FALSE;
    }

    tp.PrivilegeCount = 1;
    tp.Privileges[0].Luid = luid;

    if (bEnablePrivilege)
        tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
    else
        tp.Privileges[0].Attributes = 0;

    if (!AdjustTokenPrivileges(hToken, FALSE, &tp, sizeof(TOKEN_PRIVILEGES),
                               (PTOKEN_PRIVILEGES)NULL, (PDWORD)NULL))
    {
        printf("AdjustTokenPrivileges error: %u\n", GetLastError());
        return FALSE;
    }

    if (GetLastError() == ERROR_NOT_ALL_ASSIGNED)
    {
        printf("The token does not have the specified privilege. \n");
        return FALSE;
    }
    return TRUE;
}

int main()
{
    HANDLE hProc = GetCurrentProcess();
    HANDLE hToken = NULL;

    if (!OpenProcessToken(hProc, TOKEN_ADJUST_PRIVILEGES, &hToken))
        printf("Failed to open access token\n");

    if (!SetPrivilege(hToken, SE_DEBUG_NAME, TRUE))
        printf("Failed to set debug privilege\n");

    DWORD pid = 1804;

    HANDLE hTargetProc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
    if (hTargetProc)
        printf("Target process handle = %p\n", hTargetProc);
    else
        printf("Failed to open process: %u\n", GetLastError());

    CloseHandle(hTargetProc);
    return 0;
}
```
Приложение из листинга 3-1 подключается к процессу с PID равным 1804. Вам нужно заменить его на PID запущенного в данный момент процеса на вашей ОС. Узнать идентификаторы запущенных процессов можно с помощью приложения диспетчер задач (Task Manager).

Указать PID целевого процесса следует в строке:
```C++
    DWORD pid = 1804;
```
Каждый шаг алгоритма подключения к процессу выполняется отдельной функцией. Все они вызываются из функции `main`, которая получает управление сразу при старте приложения. Рассмотрим её код подробнее.

Сначала мы с помощью WinAPI функции `GetCurrentProcess` получаем дескриптор текущего процесса и сохраняем его в переменной `hProc`.

Далее мы вызываем WinAPI функцию `OpenProcessToken`, которая возвращает маркер доступа. В неё мы передаем дескриптов `hProc` и маску доступа `TOKEN_ADJUST_PRIVILEGES`. Благодаря этой маске, мы получаем право менять возвращаемый функцией маркер доступа. Его мы сохраняем в переменной `hToken`.

Весь код, предоставляющий привилегию `SE_DEBUG_NAME` маркеру достуа `hToken`, мы реализовали в отдельной функции `SetPrivilege`. Она выполняет два действия:

1. Читает **локальный уникальный идентификатор** (locally unique identifier или LUID) константы, соответствующей привилегии `SE_DEBUG_NAME` с помощью WinApI функции `LookupPrivilegeValue`.

2. Предоставляет маркеру доступа (переданному входным параметром) эту привилегию (указанную по LUID) через WinAPI функцию `AdjustTokenPrivileges`.

Функция `SetPrivilege` более детально рассмотрена в статье (msdn.microsoft.com/en-us/library/aa446619%28VS.85%29.aspx).

Последнее действие в функции `main` - подключение к целевому процессу, дескриптор которого сохраняется в переменной `hTargetProc`. Для этого используем WinAPI функцию `OpenProcess`, в которую мы передаём права доступа `PROCESS_ALL_ACCESS` и PID процесса для подключения. Вся его память доступна теперь по дескриптору `hTargetProc`.
