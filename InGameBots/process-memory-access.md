# Доступ к памяти процесса

Мы научились вручную искать переменную в памяти процесса. Пришло время написать код, для автоматизации этого поиска. Вутриигровые боты не могут использовать программу-отладчик (например OllyDbg). Вместо этого они должны сами реализовывать необходимые функции отладчика.

## Подключение к процессу

Как вы помните, перед началом работы с памятью процесса к нему нужно подключить отладчик. После этого он получает полный доступ к адресному пространства процесса. Мы выполняли это действие через диалог интерфейса пользователя. То же самое должен уметь выполнять внутриигровой бот. Рассмотрим, какими WinAPI функциями он может воспользоваться для этого.

Практически все объекты и ресурсы Windows доступны через их дескрипторы. WinAPI функция `OpenProcess` возвращает дескриптор указнного процесса. У каждого процесса, запущенного в системе, есть уникальный номер или **идентификатор** (process identifier или PID). Его мы должны передать в `OpenProcess` входным параметром. Получив дескриптор, мы можем обращаться к памяти процесса с помощью других WinAPI функций.

Windows отвечает за распределение своих ресурсов между запущенными процессами. Один из этих ресурсов - память. Если любой процесс вегда будет иметь доступ к памяти других процессов, это может привести к сбоям в их работе. Система в целом будет ненадёжна. Поэтому ОС имеет специальный механизм защиты доступа к своим объектам. Рассмотрим его подробнее.

В архитектуре Windows разработчику пользовательских приложений предоставляются высокоуровневые абстракции к ресурсам ОС. Объекты Windows (например процессы) также используют эти абстракции. Дугими словами, одни объекты служат обёртками для системных ресурсов и предоставляют другим объектам единообразный интерфейс к этим ресурсам. Такой подход упрощает интерфейсы для разработки как системных библиотек Windows, так и пользовательских приложений.

Представим, что мы разрабатываем пользовательское приложение, например внутриигрового бота. Каким образом оно может взаимодействовать с каким-нибудь Windows объектом? Каждый объект представляет собой структуру, состоящую из **заголовка** (header) и **тела** (body). Тело содержит специфичные для данного типа объектов данные. Заголовок же метаинформацию о процессе, которая используется **Менеджером Объектов** (Object Manager). Именно он предоставляет доступ к ресусам ОС через соответствующие им объекты.

**Модель безопасности Windows** ограничивает процессам доступ к системным объектам и различным действиям, требущих прав администратора. Можно сказать, что Менеджер Объектов реализует модель безпасности Windows. Согласно ей, процесс должен иметь специалные привилегии, чтобы получить доступ к памяти другого через вызов `OpenProcess`. Управлять привилегиями процесса можно с помощью специального объека Windows под названием **маркер доступа** (access token).

Полный алгоритм подключеныия к процессу через WinAPI функцию `OpenProcess` выглядит следующим образом:

1. Получить дескриптор текущего процесса.

2. По дескриптору получить маркер доступа текущего процесса.

3. Предоставить привилегию `SE_DEBUG_NAME` для маркера доступа текущего процесса. Эта привилегия даёт право отлаживать другие процессы.

4. Получить дескриптор целевого процесса через вызов `OpenProcess`.

Приложение, реализующе этот алгоритм, должно быть запущено с правами администратора. Без них невозможно выполнить третий шаг и предоставить текущему процессу привилегию `SE_DEBUG_NAME` через WinAPI функцию `AdjustTokenPrivileges`.

Вам может показаться странным, что приложению, запущенному с правами администратора, надо предоставлять дополнительные права на отладку других процессов. В самом деле, логично предположить, что администратору ситемы по-умолчанию должны быть доступны все её возможности. Но это не означает, что любое запущенное им приложение должно нарушать модель безопасности Windows. Такое поведение может привести к нестабильной работе всей системы.

Листинг 3-1 демонстрирует код приложения, которое подключается к процессу с заданным PID.

**Листинг 3-1.** *Приложение OpenProcess.cpp*
```С++
#include <windows.h>
#include <stdio.h>

BOOL SetPrivilege(HANDLE hToken, LPCTSTR lpszPrivilege, BOOL bEnablePrivilege)
{
    TOKEN_PRIVILEGES tp;
    LUID luid;
    if (!LookupPrivilegeValue(NULL, lpszPrivilege, &luid))

    {
        printf("LookupPrivilegeValue error: %u\n", GetLastError());
        return FALSE;
    }

    tp.PrivilegeCount = 1;
    tp.Privileges[0].Luid = luid;

    if (bEnablePrivilege)
        tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
    else
        tp.Privileges[0].Attributes = 0;

    if (!AdjustTokenPrivileges(hToken, FALSE, &tp, sizeof(TOKEN_PRIVILEGES),
                               (PTOKEN_PRIVILEGES)NULL, (PDWORD)NULL))
    {
        printf("AdjustTokenPrivileges error: %u\n", GetLastError());
        return FALSE;
    }

    if (GetLastError() == ERROR_NOT_ALL_ASSIGNED)
    {
        printf("The token does not have the specified privilege. \n");
        return FALSE;
    }
    return TRUE;
}

int main()
{
    HANDLE hProc = GetCurrentProcess();
    HANDLE hToken = NULL;

    if (!OpenProcessToken(hProc, TOKEN_ADJUST_PRIVILEGES, &hToken))
        printf("Failed to open access token\n");

    if (!SetPrivilege(hToken, SE_DEBUG_NAME, TRUE))
        printf("Failed to set debug privilege\n");

    DWORD pid = 1804;

    HANDLE hTargetProc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
    if (hTargetProc)
        printf("Target process handle = %p\n", hTargetProc);
    else
        printf("Failed to open process: %u\n", GetLastError());

    CloseHandle(hTargetProc);
    return 0;
}
```
Приложение из листинга 3-1 подключается к процессу с PID равным 1804. Вам нужно заменить его на PID запущенного в данный момент процеса на вашей ОС. Узнать идентификаторы запущенных процессов можно с помощью приложения диспетчер задач (Task Manager).

Указать PID целевого процесса следует в строке:
```C++
    DWORD pid = 1804;
```
Каждый шаг алгоритма подключения к процессу выполняется отдельной функцией. Все они вызываются из функции `main`, которая получает управление сразу при старте приложения. Рассмотрим её код подробнее.

Сначала мы с помощью WinAPI функции `GetCurrentProcess` получаем дескриптор текущего процесса и сохраняем его в переменной `hProc`.

Далее мы вызываем WinAPI функцию `OpenProcessToken`, которая возвращает маркер доступа. В неё мы передаем дескриптов `hProc` и маску доступа `TOKEN_ADJUST_PRIVILEGES`. Благодаря этой маске, мы получаем право менять возвращаемый функцией маркер доступа. Его мы сохраняем в переменной `hToken`.

Весь код, предоставляющий привилегию `SE_DEBUG_NAME` маркеру достуа `hToken`, мы реализовали в отдельной функции `SetPrivilege`. Она выполняет два действия:

1. Читает **локальный уникальный идентификатор** (locally unique identifier или LUID) константы, соответствующей привилегии `SE_DEBUG_NAME` с помощью WinApI функции `LookupPrivilegeValue`.

2. Предоставляет маркеру доступа (переданному входным параметром) эту привилегию (указанную по LUID) через WinAPI функцию `AdjustTokenPrivileges`.

Функция `SetPrivilege` более детально рассмотрена в статье (msdn.microsoft.com/en-us/library/aa446619%28VS.85%29.aspx).

Последнее действие в функции `main` - подключение к целевому процессу, дескриптор которого сохраняется в переменной `hTargetProc`. Для этого используем WinAPI функцию `OpenProcess`, в которую мы передаём права доступа `PROCESS_ALL_ACCESS` и PID процесса для подключения. Вся его память доступна теперь по дескриптору `hTargetProc`.

## Операции чтения и записи

Мы получили дескриптор целевого процесса. Теперь рассмотрим, способы обращения к его памяти.

WinAPI функция `ReadProcessMemory` читает данные из указанной области памяти целевого процесса и сохраняет их в память вызывающего процесса. Аналгичная ей функция `WriteProcessMemory` записывает указанные данные в память целевого процесса.

Рассмотрим пример. Наше тестовое приложение, приведённое в листинге 3-2, записывает шестнадцатирично значение DEADBEEF по некоторому абсолютному адресу памяти целевого процесса. Затем по этому же адресу происходит чтение. Если запись была успешной, мы прочитаем значение DEADBEEF.

**Листинг 3-2.** *Приложение ReadWriteProcessMemory.cpp*
```С++
#include <stdio.h>
#include <windows.h>

BOOL SetPrivilege(HANDLE hToken, LPCTSTR lpszPrivilege, BOOL bEnablePrivilege)
{
    // Смотрите реализацию этой функции в листинге 3-1
}

DWORD ReadDword(HANDLE hProc, DWORD_PTR address)
{
    DWORD result = 0;

    if (ReadProcessMemory(hProc, (void*)address, &result, sizeof(result), NULL) == 0)
    {
        printf("Failed to read memory: %u\n", GetLastError());
    }
    return result;
}

void WriteDword(HANDLE hProc, DWORD_PTR address, DWORD value)
{
    if (WriteProcessMemory(hProc, (void*)address, &value, sizeof(value), NULL) == 0)
    {
        printf("Failed to write memory: %u\n", GetLastError());
    }
}

int main()
{
    HANDLE hProc = GetCurrentProcess();

    HANDLE hToken = NULL;
    if (!OpenProcessToken(hProc, TOKEN_ADJUST_PRIVILEGES, &hToken))
        printf("Failed to open access token\n");

    if (!SetPrivilege(hToken, SE_DEBUG_NAME, TRUE))
        printf("Failed to set debug privilege\n");

    DWORD pid = 5356;
    HANDLE hTargetProc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
    if (!hTargetProc)
        printf("Failed to open process: %u\n", GetLastError());

    DWORD_PTR address = 0x001E0000;
    WriteDword(hTargetProc, address, 0xDEADBEEF);
    printf("Result of reading dword at 0x%llx address = 0x%x\n", address,
           ReadDword(hTargetProc, address));

    CloseHandle(hTargetProc);
    return 0;
}
```
Абсолютный адрес 001E0000 для записи значение DEADBEEF выбран произвольно. Эту область памяти занимает какой-то сегмент целевого процесса. Операция записи данных может привести к его аварийному завершению. Поэтому для тестрования нашего примера не пользуйтесь в качестве цели важными системными службами Windows. Лучше всего подойдёт приложение Блокнот.

Для запуска приложения `ReadWriteProcessMemory.cpp` выполните следующие действия:

1. Запустите Блокнот.

2. С помощью диспетчера задач прочитайте PID процесса Блокнота.

3. Присвойте прочитанный PID соответствующей переменной в исходном коде пирложения `ReadWriteProcessMemory.cpp`:
```C++
DWORD pid = 5356;
```

4. С помощью отладчика WinDbg прочитайте базовый адрес любого сегмента динамической памяти процесса Блокнот. Для этого воспользуйтесь уже знакомой нам командой `!address`.

5. Отлючите WinDbg от процесса Блокнот с помощью команды `.detach`.

6. Присвойте базовый адрес сегмета динамической памяти переменной `address` в функции `main`:
```C++
DWORD_PTR address = 0x001E0000;
```
Запись в динамическую память будет самой безопасной по сравнению с другими сегментами.

7. Скомпилируйте приложение `ReadWriteProcessMemory.cpp`. Разрядность (x86 или x64) полученного EXE файл должна соответствовать разрядности Блокнота. В противном случае наше приложение не сможет к нему подключиться.

8. Запустите тестовое приложение с правами администратора из командной строки Windows.

После упешного выполнения нашего примера, вы увидите в консоле строку:
```
Result of reading dword at 0x1e0000 address = 0xdeadbeef
```
В этом выводе указан абсолютный адрес, по которому происходила запись, и прочитанное значение.

Обратите внимание на функции-обёртки `WriteDword` и `ReadDword` в листинге 3-2. Они скрывают несущественные детали и предоставляют простой интерфейс к WinAPI функциям `WriteProcessMemory` и `ReadProcessMemory`, параметры которых представлены в таблице 3-4.

**Таблица 3-4.** *Параметры функций `WriteProcessMemory` и `ReadProcessMemory`*

| Номер параметра | Параметр | Описание |
| --- | --- | --- |
| 1 | `hProc` | Дескриптор целевого процесса, к памяти которого идёт обращение. |
| 2 | `address` | Абсолютный адрес обасти памяти для доступа. |
| 3 | `result` | Указатель на область памяти текущего процесса, в которую будет сохранён результат вызова `ReadProcessMemory`. |
| 3 | `value` | Указатель на буфер данных, которые будут записаны функцией `WriteProcessMemory` в память целевого процесса. |
| 4 | `sizeof(...)` | Число байт для чтения или записи. |
| 5 | `NULL` | Укзатель на переменную. Если операця чтения или записи была прервана по какой-то причине, в эту переменную запишется число переданных байт. |

## Доступ к сегментам TEB и PEB

Мы научились работать с памятью целевого процесса. Однако, нам нужно знать абсолютный адрес её области для операций чтения и записи. Узнать этот адрес мы можем только найдя сегмент, в котором хранится интересующая нас переменная. В памяти процесса есть несколько мест, где хранится информация о его сегментах. Эти места - специальные сегменты TEB и PEB с метаинформацией.

Число TEB сегментов в памяти процесса соответствует числу его потоков. Каждый TEB содержит базовый адрес сегмента стека, выделенного соответствующему потоку. Большую часть переменных, используемых в потоке, мы можем найти в сегменте стека. Практически вся оставшаяся часть переменных потока хранится в сегменте динаической памяти процесса, выделяемом по-умолчанию. Его базовый адрес хранится в PEB сегменте.

Следовательно, чтобы найти сегменты стека потока и динамической памяти процесса, нам надо найти PEB и соответствующий потоку TEB. Эта задача упрощается тем, что все TEB сегменты содержат базовый адрес PEB.

Таким образом, наша задача сводится к поиску TEB сегмента.

### Доступ к TEB текущего процесса

#### Главный поток 32-битного процесса

Рассмотрим методы доступа к TEB сегменту. Начнём с самого простого варианта этой задачи. У нас есть однопоточное приложение. Как оно может получить доступ к TEB своего главного потока? Существует несколько путей решения этой задачи.

Самый простой и прямолинейный способ - воспользоваться регистром процессора FS на x86 архитектуре и GS на архитектуре x64. Процессор предоставляет ОС решать, как использовать эти регистры. Windows использует их для хранения указателя на TEB сегмент потока, который исполняется в данный момент. Листинг 3-3 демонстрирует этот подход.

**Листинг 3-3.** *Функция `GetTeb`*
```C++
#include <winternl.h>

PTEB GetTeb()
{
    PTEB pTeb;

    __asm {
        mov EAX, FS:[0x18]
        mov pTeb, EAX
    }
    return pTeb;
}
```
Функция `GetTeb` написана с использованием **ассемблерных вставок**. Эта возможность C++ позволяет вставлять код на языке ассемблера, команды которого соответствуют машинным командам процессора. Рассмотрим код функции подробнее. Она начинается с выделения памяти на стеке для локальной переменной `pTeb` типа `PTEB`. Согласно WinAPI документации, `PTEB` - это указатель на структуру, содержащую все данные регистра TEB. Далее идет объявление блока языка ассемблера с двумя командами. Первая команда - запись в регистр `EAX` значения, находящегося по адресу сегмента с базовым адресом равным значению регистра `FS` плюс смещения 0x18 (в шестнадцатеричной системе). Вторая команда - запись в переменную `pTeb` значеня регистра `EAX`. В резульате в `pTeb` оказвыается базовый адрес регистра TEB, который мы возвращаем из функции.

Может быть непоятно, почему `GetTeb` не может просто вернуть значение регистра `FS`? Ведь этот регистр должен указывать на TEB сегмент. Чтобы ответить на этот вопрос, следует рассмотреть, как в Windows происходит доступ к сегментам процесса.

Большинство современных ОС использует [**защищённый режим процессора**](en.wikipedia.org/wiki/Protected_mode) (protected processor mode). В этом режиме [**адресация сегментов**](en.wikipedia.org/wiki/X86_memory_segmentation#Protected_mode) происходит через [**глобальную таблицу дескрипторов**](en.wikipedia.org/wiki/Global_Descriptor_Table) (Global Descriptor Table или GDT). В регистрах FS и GS хранится селектор, который является индексом записи в таблице дескрипторов. В этой записи находится базовый адрес сегмента TEB. Запрос к GDT по селектору выполняется аппаратным **блоком сегментации** (segmentation unit) процессора. Результат этого запроса временно хранится в процессоре и недоступен для приложений или ОС. Таким образом у Windows нет эффективного способа узнать базовый адрес сегмента TEB. Его можно прочитать из таблицы дескрипторов через WinAPI функции `GetThreadSelectorEntry` и `Wow64GetThreadSelectorEntry`, но этот способ неэффективен из-за накладных расходов. Именно поэтому в TEB сегменте хранится его собственный базовый адрес.

Пример использования функции `GetThreadSelectorEntry` приведён в следующем [обсуждении](https://reverseengineering.stackexchange.com/questions/3139/how-can-i-find-the-thread-local-storage-tls-of-a-windows-process-thread) на форуме.

Структура TEB определена в заголовочном файле `winternal.h`, который распространяется с Windows SDK. Её содержимое отличается для разных версий Windows. Поэтому важно, чтобы ваши версии ОС и Windows SDK совпадали. Перед началом работы с TEB структурой всегда уточняйте её поля в заголовочном файле.

Определение структуры TEB из Windows SDK версии 8.1 выглядит следующим образом:

```C++
typedef struct _TEB {
    PVOID Reserved1[12];
    PPEB ProcessEnvironmentBlock;
    PVOID Reserved2[399];
    BYTE Reserved3[1952];
    PVOID TlsSlots[64];
    BYTE Reserved4[8];
    PVOID Reserved5[26];
    PVOID ReservedForOle;  // Windows 2000 only
    PVOID Reserved6[4];
    PVOID TlsExpansionSlots;
} TEB, *PTEB;
```
Среди прочих есть поле `ProcessEnvironmentBlock`, которое указывает на структуру PEB. Мы можем воспользоваться этим указателем, чтобы получить доступ к PEB сегменту.

#### Главный поток 64-битного процесса

Мы не можем воспользоваться функцией аналогичной `GetTeb` из листинга 3-3 на 64-разрядной системе. Проблема в том, что компилятор Visual Studio C++ не поддерживает ассемблерные вставки при компиляции 64-разрядных приложений. Вместо этих вставок должны использоваться **встроенные функции компилятора** (compiler intrinsics).

Листинг 3-4 демонстрирует функцию `GetTeb`, переписанную с использовнием встроенных функций компилятора.

**Листинг 3-4.** *Функция `GetTeb` для архитектур x86 и x64*
```C++
#include <windows.h>
#include <winternl.h>

PTEB GetTeb()
{
#if defined(_M_X64) // x64
    PTEB pTeb = reinterpret_cast<PTEB>(__readgsqword(0x30));
#else // x86
    PTEB pTeb = reinterpret_cast<PTEB>(__readfsdword(0x18));
#endif
    return pTeb;
}
```
Новый вариант функции `GetTeb` работает для архитектур x86 и x64. Чтобы выбрать подходящую реализацию, используется директива условной компиляции [**препроцессора**](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BE%D1%80_%D0%A1%D0%B8). Если макрос `_M_X64` определён, целевая архитектура приложения 64-разряная. В этом случае вызывается встроенная функция компиляора `__readgsqword`, которая читает 64-битное значение со смещением 0x30 от базового адреса сегмента TEB (на него указывает регистр GS через селектор). Для 32-разрядной архитектуры вызывается встроенная функция `__readfsdword`, которая читает 32-битное значение со смщением 0x18 от базового адреса сегмента TEB (на него указывает регистр FS).

Глядя на новую реализацию функции `GetTeb`, возникает вопрос: почему поле структуры TEB с базовым адресом сегмента имеет разные смещения для x86 и x64 архитектур? Чтобы ответить на него, расмотрим определение структуры `NT_TIB`, которая используется для представления части TEB структуры, независимой от версии Windows:
```C++
typedef struct _NT_TIB {
    struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList;
    PVOID StackBase;
    PVOID StackLimit;
    PVOID SubSystemTib;
     union
     {
          PVOID FiberData;
          ULONG Version;
     };
    PVOID ArbitraryUserPointer;
    struct _NT_TIB *Self;
} NT_TIB;
```
Поле с базовым адресом сегмента TEB называется `Self`. До него идут шесть полей, каждое из которых имеет тип `PVOID`. `PVOID` - это указатель на обасть памяти. Его размер зависит от разрядности процессора: 32 бита (или 4 байа) для архитектуры x86 и 64 бита (или 8 байт) для x64. Таким образом, в первом случае поле `Self` окажется смещено на 24 байта (6 * 4), а во втором на 48 байт (6 * 8). Переведём эти числа в шестнадцатеричную систему счислеиния  и получим: 0x18 и 0x30 соответственно.

Вместо того чтобы указывать смещения явно, мы можем использовать стуктуру `NT_TIB`. Листинг 3-5 демонстрирует это решение.

**Листинг 3-5.** *Портируемая версия функции `GetTeb`*
```C++
#include <windows.h>
#include <winternl.h>

PTEB GetTeb()
{
#if defined(_M_X64) // x64
    PTEB pTeb = reinterpret_cast<PTEB>(__readgsqword(reinterpret_cast<DWORD>(
                                       &static_cast<PNT_TIB>(nullptr)->Self)));
#else // x86
    PTEB pTeb = reinterpret_cast<PTEB>(__readfsdword(reinterpret_cast<DWORD>(
                                       &static_cast<PNT_TIB>(nullptr)->Self)));
#endif
    return pTeb;
}
```
Это реализация функции `GetTeb` из [статьи](https://www.autoitscript.com/forum/topic/164693-implementation-of-a-standalone-teb-and-peb-read-method-for-the-simulation-of-getmodulehandle-and-getprocaddress-functions-for-loaded-pe-module). В ней исользуются уже знакомые нам встроенные функции компилятора `__readgsqword` и `__readfsdword`. Теперь мы используем структуру `NT_TIB`, чтобы прочитать смещение поля `Self`, содержащего базовый адрес сегмента TEB. Для этого, мы делаем последовательность **приведений типов**. Сначала мы берём указатель на нулевой асолютный адрес, котоый обозначается литералом `nullptr`. Затем приводим этот нулевой адрес к типу `PNT_TIB` с помощью оператора `static_cast`. Таким образом мы получаем указатель на структуру типа `NT_TIB`, расположенную по адресу 0. После этого мы читаем поле `Self` с помощью оператора доступа к полю `->`. Следующий шаг - операция взятия адреса `&` поля `Self`, которая возвращает его абсолютный адрес. Последний шаг - приведение полученного адреса к типу `DWORD` или `QWORD` (в зависимости от целевой аритектуры) с помощью оператора `reinterpret_cast`. Это действие необходимо, так как встроеные функции компилятора ожидают конкретный тип входного параметра.

Версия функции `GetTeb` из листинга 3-5 позволяет исключить использование явно заданных в коде смещений. Благодаря этому она будет корректно работать для всех версий Windows, даже если эти смещения изменятся.

#### WinAPI функции доступа к TEB

Получить доступ к TEB сегменту можно и через WinAPI. Функция `NtCurrentTeb` реализует тот же алгоритм, что и `GetTeb` из листинга 3-5. С её помощью мы можем получить указатель на струкуру типа `TEB` текущего потока. Листинг 3-6 демонстрирует использование функции `NtCurrentTeb`.

**Листинг 3-6.** *Пример вызова WinAPI функции `NtCurrentTeb`*
```C++
#include <windows.h>
#include <winternl.h>

PTEB pTeb = NtCurrentTeb();
```
Теперь все манипуляции над регистрами FS и GS происходят на уровне системной библиотеки ОС. Мы можем рассчитывать на её корректную работу для всех архитекутур, поддерживаемых Windows (x86, x64, ARM).

До сих пор мы рассматривали случай однопоточного приложения. Если например нам нужно получить TEB вспомогательного потока из функции `main` (то есть гланого потока), то все рассмотренные выше способы не подходят.

WinAPI функция `NtQueryInformationThread` предоставляет доступ к TEB любого потока процесса. Она работает только в контексте вызывающего процесса, т.е. с её помощью вы не сможете прочитать TEB игрового приложения из бота. Но в некоторых случаях `NtQueryInformationThread` может быть полезна. Листинг 3-7 демонстрирует реализацию `GetTeb`, которая использует `NtQueryInformationThread`.

**Листинг 3-7.** *Функция`GetTeb`, вызывающая `NtQueryInformationThread`*
```C++
#include <windows.h>
#include <winternl.h>

#pragma comment(lib,"ntdll.lib")

typedef struct _CLIENT_ID {
    DWORD UniqueProcess;
    DWORD UniqueThread;
} CLIENT_ID, *PCLIENT_ID;

typedef struct _THREAD_BASIC_INFORMATION {
    typedef PVOID KPRIORITY;
    NTSTATUS ExitStatus;
    PVOID TebBaseAddress;
    CLIENT_ID ClientId;
    KAFFINITY AffinityMask;
    KPRIORITY Priority;
    KPRIORITY BasePriority;
} THREAD_BASIC_INFORMATION, *PTHREAD_BASIC_INFORMATION;

typedef enum _THREADINFOCLASS2 {
    ThreadBasicInformation,
    ThreadTimes,
    ThreadPriority,
    ThreadBasePriority,
    ThreadAffinityMask,
    ThreadImpersonationToken,
    ThreadDescriptorTableEntry,
    ThreadEnableAlignmentFaultFixup,
    ThreadEventPair_Reusable,
    ThreadQuerySetWin32StartAddress,
    ThreadZeroTlsCell,
    ThreadPerformanceCount,
    ThreadAmILastThread,
    ThreadIdealProcessor,
    ThreadPriorityBoost,
    ThreadSetTlsArrayAddress,
    _ThreadIsIoPending,
    ThreadHideFromDebugger,
    ThreadBreakOnTermination,
    MaxThreadInfoClass
} THREADINFOCLASS2;

PTEB GetTeb()
{
    THREAD_BASIC_INFORMATION threadInfo;
    if (NtQueryInformationThread(GetCurrentThread(),
                                 (THREADINFOCLASS)ThreadBasicInformation,
                                 &threadInfo, sizeof(threadInfo), NULL))
    {
        printf("NtQueryInformationThread return error\n");
        return NULL;
    }
    return reinterpret_cast<PTEB>(threadInfo.TebBaseAddress);
}
```
Параметры функции `NtQueryInformationThread` рассмотрены в таблице 3-5. 

**Таблица 3-5.** *Параметры функции `NtQueryInformationThread`*

| Параметр | Описание |
| --- | --- |
| `GetCurrentThread()` | Дескриптор целевого потока, TEB которого требуется прочитать. В примере используется дескриптор текущего потока. |
| `ThreadBasicInformation` | Константа типа перечисления (enum) `THREADINFOCLASS`. Она определяет тип структуры, возвращаемой функцией. |
| `threadInfo` | Указатель на структуру, в которую функция запишет свой результат. |
| `sizeof(...)` | Размер структуры с результатом функции. В нашем случае - это размер `threadInfo`. |
| `NULL` | Укзатель на переменную, которая равна числу байт, записанных в структуру с результатом (`threadInfo`). |

Чтобы прочитать структуру `THREAD_BASIC_INFORMATION` для заданного потока, мы должны передать в функцию `NtQueryInformationThread` константу `ThreadBasicInformation` типа `THREADINFOCLASS`. К сожалению, эта константа не документирована. Кроме того она не опеделена в заголовочном файле `winternl.h`. В нём есть только константа `ThreadIsIoPending`.

Чтобы использовать недокументированную константу типа `THREADINFOCLASS`, её над определить самостоятельно. Для этого определим новое перечисление типа `THREADINFOCLASS2`, которое содержит все необходимые нам константы. Подробнее о них, вы можете узнать в [неофициальной докуметации](http://undocumented.ntinternals.net/index.html?page=UserMode/Undocumented%20Functions/NT%20Objects/Thread/THREAD_INFORMATION_CLASS.html).

В нашем новом перечислении типа `THREADINFOCLASS2` не должно быть константы с именем `ThreadIsIoPending`, иначе она будет конфликтовать с определением из заголовочного файла `winternl.h`. Поэтому в листинге 3-7 мы переименовали эту константу на `_ThreadIsIoPending`.

Функция `NtQueryInformationThread` возвращает структуру данных, тип который зависит от переданного вторым параметром константы. Если мы передаём недокументированую константу `ThreadBasicInformation`, то тип возвращаемой структуры будет также недокументирован. Поэтому мы должны самостоятельно определить тип `THREAD_BASIC_INFORMATION`. Вы можете найти его в уже упомянутой неофициальный документации или скопировать из листинга 3-7.

Обратите внимание на определение структуры `THREAD_BASIC_INFORMATION`. Она отличается от структуры `TEB`. Тем не менее её поле `TebBaseAddress` содержит базовый адрес сегмента TEB.

Функция `NtQueryInformationThread` доступна через Native API интерфейс. Она реализована в динамической библиотеке `ntdll.dll`, которая всегда входит в состав дистрибутива Windows. Эта библиотека активно используется системами ОС. Но чтобы вызвать её функции из пользовательского приложения, понадобится библиотека импорта `ntdll.lib` и заголовочны файл `winternl.h`. Windows SDK предоставляет оба этих файла.

Воспользоваться библиотекой импорта можно с помощью **директивы pragma**:
```C++
#pragma comment(lib, "ntdll.lib")
```
Эта строчка добавляет файл `ntdll.lib` в список библиотек импорта, которым воспользуется компоновщик.

В архиве примеров к этой книге вы можете найти файл `TebPebSelf.cpp`, в котором приведены все рассмотренные нами способы доступа к TEB и PEB сегментам.

### Доступ к TEB целевого процесса

Мы рассмотрели методы доступа к TEB сегментам потоков процесса вашего приложения. В большинстве случаев они не нужны, поскольку все переменные доступны по своим именам, и вам не нужно искать их в сегментах стека и динамической памяти. С другой стороны мы разобрались в устройстве сегмента TEB.

Теперь мы рассмотрим методы доступа к сегментам TEB и PEB целевого процесса, в качестве которого воспользуемся любым стандартным Windows приложением.

Для тестирования дальнейших примеров необходимо выполнить следующие шаги:

1. Запустить стандартное Windows приложение (например Блокнот). Помните, что его разрядность совпадает с разрядностью Windows.

2. Прочитайте PID процесса приложения с помощью диспетчера задач.

3. Присвойте прочитанный PID переменной `pid` функии `main` примера:
```C++
DWORD pid = 5356;
```
4. Запустите пример с првами администратора.

#### Повторение базового адреса TEB

Начнём с простейшего случая: целевой процесс - это однопоточное приложение. При старте процесса базовый адрес TEB главного потока назначается ОС. Очень часто этот адрес оказывается одним и тем же для 32-разрядных приожений. Воспользуемся этим наблюдением и составим простой алгоритм чтения TEB сегмнта целевого процесса:

1. Прочитать базовый адрес TEB сегмента главного потока текущего процесса.

2. Прочитать сегмент по этому же базовму адресу в адресном пространстве целевого процесса.

Листинг 3-8 демонстрирует реализацию этого алгоритма.

**Листинг 3-8.** *Приложение `TebPebMirror.cpp`*
```C++
#include <windows.h>
#include <winternl.h>

BOOL SetPrivilege(HANDLE hToken, LPCTSTR lpszPrivilege, BOOL bEnablePrivilege)
{
    // Смотрите реализацию этой функции в листинге 3-1
}

BOOL GetMainThreadTeb(DWORD dwPid, PTEB pTeb)
{
    LPVOID tebAddress = NtCurrentTeb();
    printf("TEB = %p\n", tebAddress);

    HANDLE hProcess = OpenProcess(PROCESS_VM_READ, FALSE, dwPid);
    if (hProcess == NULL)
        return false;

    if (ReadProcessMemory(hProcess, tebAddress, pTeb, sizeof(TEB), NULL) == FALSE)
    {
        CloseHandle(hProcess);
        return false;
    }

    CloseHandle(hProcess);
    return true;
}

int main()
{
    HANDLE hProc = GetCurrentProcess();

    HANDLE hToken = NULL;
    if (!OpenProcessToken(hProc, TOKEN_ADJUST_PRIVILEGES, &hToken))
        printf("Failed to open access token\n");

    if (!SetPrivilege(hToken, SE_DEBUG_NAME, TRUE))
        printf("Failed to set debug privilege\n");

    DWORD pid = 7368;

    TEB teb;
    if (!GetMainThreadTeb(pid, &teb))
        printf("Failed to get TEB\n");

    printf("PEB = %p StackBase = %p\n", teb.ProcessEnvironmentBlock,
           teb.Reserved1[1]);

    return 0;
}
```
После запуска приложения `TebPebMirror.cpp`, в командной строке будут распечатаны базовые адреса трёх сегментов целевого процесса:

* TEB

* PEB

* Сегмент стека главного потока

Мы использовали уже знакомый метод предоставления привилегии `SE_DEBUG_NAME` для маркера доступа текущего процесса с помощью WinAPI функций `OpenProcessToken` и `SetPrivilege`. После этого вызывается функция `GetMainThreadTeb`, которая получает входным параметром PID целевого процесса и вовзращает указатель на структру `TEB`.

Алгоритм `GetMainThreadTeb` следующий:

1. Прочитать базовый адрес TEB сегмента текущего потока с помощью вызова `NtCurrentTeb`.

2. Получить дескриптор целевого процесса с правами достуа `PROCESS_VM_READ`. Для этого используется WinAPI функция `OpenProcess`.

3. Прочитать структуру `TEB` целевого процесса с помощью вызова `ReadProcessMemory`.

В общем случае, при старте нового процесса Windows назначает базовый адрес сегмента TEB произвольно. Для 32-разрядных приложений этот адрес часто оказывается одним и тем же. Но для 64-разрядных приложений, он меняется при каждом запуске. Поэтому рассмотренный нами метод доступа к TEB не рекомендуется применять в реальных ботах. Благодаря своей простоте, он хорош только в качестве обучающего примера.

Для всех примеров этой главы важно помнить, что разрядность целевого процесса и вашего приложения должна быть одинаковой. Чтобы выбрать разрядность компилируемого приложения в Visual Studio, укажите желаемую целевую архитектуру в элементе интерфейса "Solution Platforms".

#### Перебор всех потоков целевого процесса







