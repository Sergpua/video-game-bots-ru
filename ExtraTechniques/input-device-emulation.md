# Эмуляция устройств ввода

Рассмотрим способ эмуляции устройств ввода. Этот подход применяется для обхода защиты от кликеров, которая проверяет состояние клавиатуры. Подробнее об алгоритме такой защиты читайте во второй главе.

Когда мы используем эмулятор клавиатуры или мыши, у ОС нет возможности обнаружить подмену. Эмулятор будет обрабатываться как обычное устройство ввода. Поэтому защита игрового приложения не сможет отличить действия бота от действий игрока.

## Инструменты для разработки

Прежде всего нам следует выбрать устройство, которое будет использоваться в качестве эмулятора. Чтобы сделать правильный выбор, рассмотрим основные требования к такому устройству:

* Невысокая цена.
* Средства разработки (IDE и компилятор) должны быть бесплатны.
* Среда разработки должна предоставлять библиотеки для эмуляции устройств ввода.
* Должна быть доступная подробная документация.

Плата Arduino удовлетворяет всем перечисленным требованиям. Кроме того эта аппаратная платформа — одна из лучших для знакомства с разработкой для встраиваемых систем.

Следующий вопрос, который нам следует решить: какую версию платы Arduino следует выбрать? Чтобы ответить на этот вопрос, обратимся к средствам разработки. Arduino IDE предоставляет [библиотеки](https://www.arduino.cc/reference/en/language/functions/usb/keyboard) для эмуляции клавиатуры и мыши. Согласно документации, некоторые версии плат их не поддерживают, и нам они не подходят. Нас устроит плата Leonardo, Micro или Due. Чтобы начать работать с ней, подключите устройство к компьютеру по USB кабелю. 

У нас есть аппаратная платформа. Теперь самое время установить средства разработки для неё. Компания производитель Arduino плат предоставляет бесплатную IDE с интегрированным C++ компилятором и библиотеками для поддержки периферии. Скачайте её с [официального веб-сайта](https://www.arduino.cc/en/Main/Software) и установите.

Следующий шаг — установка драйвера для платы Arduino. Для этого запустите программу установки из каталога Arduino IDE. Её путь по-умолчанию: `C:\Program Files (x86)\Arduino\drivers`. В каталоге `drivers` есть две программы для 64-разярдной версии Windows и 32-разрядной: `dpinst-amd64.exe` и `dpinst-x86.exe`. Перед установкой драйвера подключите плату к компьютеру.

После установки IDE выполните следующие шаги для её конфигурации:

1. Прочитайте модель вашей платы. Для этого в главном меню IDE выберите пункт “Tools” ➤ ”Get Board Info” ("Инструменты" ➤ ”Информация о плате”). Проверьте, что в пункте меню “Tools” ➤ ”Board:...” ("Инструменты" ➤ ”Плата:...”) модель указана правильно.

2. Укажите порт подключения платы в пункте главного меню “Tools”➤“Port:...” ("Инструменты" ➤ ”Порт:...”).

Теперь Arduino IDE настроена и готова к работе.

Программа, которую мы напишем для Arduino платы, будет эмулировать устройство ввода. Со стороны компьютера ей будет управлять бот кликер, написанный на языке AutoIt. Для этого взаимодействия понадобится набор скриптов [**CommAPI**](https://www.autoitscript.com/wiki/CommAPI).

## Эмуляция клавиатуры

Есть два варианта реализации бота, использующего эмулятор устройства ввода.

В первом случае все алгоритмы бота реализуются в программе, работающей на плате Arduino. После её загрузки на устройство, всё готово к работе. Бот запускается автоматически, как только вы подключаете плату к компьютеру через USB. Такая архитектура лучше всего подходит для "слепых" ботов, которые нажимают кнопки, не проверяя состояние игровых объектов. К сожалению, программа, запущенная на Arduino не имеет доступа к WinAPI интерфейсу. Следовательно, она не сможет прочитать данные из процесса игрового приложения или устройства вывода.

Если ваш бот должен реагировать на игровые события, следует выбрать второй вариант реализации. В этом случае его алгоритмы запускаются и работают на компьютере. Программа платы Arduino отвечает только за симуляцию событий устройства ввода (например нажатие клавиши). В такой схеме бот имеет полный доступ к WinAPI и может читать состояние игровых объектов. После принятия решения, он отправляет команду плате Arduino на выполнение требуемого действия.

Мы рассмотрим пример второго варианта реализации бота. Он более надёжен в работе и универсален.

Протокол взаимодействия платы и бота может быть любым. Предлагаю остановиться на самом простом варианте и использовать [**UART интерфейс**](https://ru.wikipedia.org/wiki/Универсальный_асинхронный_приёмопередатчик) (Universal Asynchronous Receiver-Transmitter). Для его использования не нужны дополнительные расширения платы Arduino. Достаточно подключения по USB кабелю, через который мы загружаем программу на устройство.

Листинг 5-1 демонстрирует программу `keyboard.ino` для платы Arduino, которая симулирует события клавиатуры. Код клавиши, которую требуется нажать, передаётся по UART нтерфейсу.

**Листинг 5-1.** *Программа `keyboard.ino`*
```С++
#include <Keyboard.h>

void setup()
{
  Serial.begin(9600);
  Keyboard.begin();
}

void loop()
{
  if (Serial.available() > 0)
  {
    int incomingByte = Serial.read();
    Keyboard.write(incomingByte);
  }
}
```
Здесь мы используем библиотеку `Keyboard`, которую предоставляет Arduino IDE. Она позволяет генерировать события нажатия клавиш. Подключенный по USB компьютер получает их через [**HID**](https://en.wikipedia.org/wiki/Human_interface_device) (Human Interface Device) интерфейс. Этот интерфейс является стандартом для устройств ввода, использующих USB подключение.

В первой строке программы мы включаем заголовок `Keyboard.h`. В нём создаётся глобальный объект `Keyboard` класса `Keyboard_`. Все возможности библиотеки доступны через его методы.

В нашей программе всего две функции: `setup` и `loop`. В любом C++ приложении обязательно должна быть функция `main`. Она добавляется IDE во времени компиляции. В сгенерированной `main` всего два действия: однократный вызов `setup` и цикличный вызов `loop`. [**Прототипы**](https://ru.wikipedia.org/wiki/Прототип_функции) этих функций предопределены, и поменять их нельзя.

Кроме `Keyboard` мы используем глобальный объект `Serial`. Он предоставляет доступ к интерфейсу UART. Для инициализации объектов в функции `setup` вызываются методы `begin`. Этот метод для `Serial` принимает входным параметром [скорость передачи данных](https://ru.wikipedia.org/wiki/Скорость_передачи_данных) между компьютером и платой, которая в нашем случае равна 9600 бит/c. У метода `begin` объекта `Keyboard` нет входных параметров. Сразу после его вызова плата начинает эмулировать клавиатуру.

После выполнения функции `setup` Arduino плата готова принимать команды по UART интерфейсу и симулировать нажатия соответствующих клавиш. За это отвечает код функции `loop`. Её алгоритм состоит из трёх шагов:

1. С помощью метода `available` объекта `Serial` проверить, были ли получены данные по UART интерфейсу. Метод возвращает количество принятых байт. Если это значение больше нуля, значит передача была.

2. Прочитать первый байт полученных по UART данных с помощью метода `read` объекта `Serial`. Байт интерпретируется как ASCII код клавиши, нажатие которой следует симулировать.

3. Симулировать нажатие клавиши через HID интерфейс с помощью метода `write` объекта `Keyboard`. Подключённые по USB компьютер обработает его как событие обычной клавиатуры.

Чтобы скомпилировать программу `keyboard.ino` и загрузить её на Arduino плату, нажмите комбинацию клавиш Ctrl+U.

Мы подготовили плату. Теперь разработаем AutoIt скрипт, который будет ей управлять. Он должен посылать через UART интерфейс ASCII коды клавиш. Функции работы с UART доступны через WinAPI интерфейс. Обёртки CommAPI могут значительно упростить доступ к этим функциям из языка AutoIt. Скачайте и скопируйте их в каталог вашего скрипта. Проверьте, что у вас есть все необходимые файлы:

* `CommAPI.au3`
* `CommAPIConstants.au3`
* `CommAPIHelper.au3`
* `CommInterface.au3`
* `CommUtilities.au3`

Листинг 5-2 демонстрирует использорвание обёрток CommAPI. Он симулирует набор строки "Hello world!" в активном окне.

**Листинг 5-2.** *Скрипт `ControlKeyboard.au3`*
```AutoIt
#include "CommInterface.au3"

func ShowError()
	MsgBox(16, "Error", "Error " & @error)
endfunc

func OpenPort()
	local const $iPort = 7
	local const $iBaud = 9600
	local const $iParity = 0
	local const $iByteSize = 8
	local const $iStopBits = 1

	$hPort = _CommAPI_OpenCOMPort($iPort, $iBaud, $iParity, $iByteSize, $iStopBits)
	if @error then
		ShowError()
		return NULL
	endif

	_CommAPI_ClearCommError($hPort)
	if @error then
		ShowError()
		return NULL
	endif

	_CommAPI_PurgeComm($hPort)
	if @error then
		ShowError()
		return NULL
	endif

	return $hPort
endfunc

func SendArduino($hPort, $command)
	_CommAPI_TransmitString($hPort, $command)
	if @error then ShowError()
endfunc

func ClosePort($hPort)
	_CommAPI_ClosePort($hPort)
	if @error then ShowError()
endfunc

$hWnd = WinGetHandle("[CLASS:Notepad]")
WinActivate($hWnd)
Sleep(200)

$hPort = OpenPort()

SendArduino($hPort, "Hello world!")

ClosePort($hPort)
```