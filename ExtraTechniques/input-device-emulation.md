# Эмуляция устройств ввода

Рассмотрим способ эмуляции устройств ввода. Этот подход применяется для обхода защиты от кликеров, которая проверяет состояние клавиатуры. Подробнее об алгоритме такой защиты читайте во второй главе.

Когда мы используем эмулятор клавиатуры или мыши, у ОС нет возможности обнаружить подмену. Эмулятор будет обрабатываться как обычное устройство ввода. Поэтому защита игрового приложения не сможет отличить действия бота от действий игрока.

## Инструменты для разработки

Прежде всего нам следует выбрать устройство, которое будет использоваться в качестве эмулятора. Чтобы сделать правильный выбор, рассмотрим основные требования к такому устройству:

* Невысокая цена.
* Средства разработки (IDE и компилятор) должны быть бесплатны.
* Среда разработки должна предоставлять библиотеки для эмуляции устройств ввода.
* Должна быть доступная подробная документация.

Плата Arduino удовлетворяет всем перечисленным требованиям. Кроме того эта аппаратная платформа — одна из лучших для знакомства с разработкой для встраиваемых систем.

Следующий вопрос, который нам следует решить: какую версию платы Arduino следует выбрать? Чтобы ответить на этот вопрос, обратимся к средствам разработки. Arduino IDE предоставляет [библиотеки](https://www.arduino.cc/reference/en/language/functions/usb/keyboard) для эмуляции клавиатуры и мыши. Согласно документации, некоторые версии плат их не поддерживают, и нам они не подходят. Нас устроит плата Leonardo, Micro или Due. Чтобы начать работать с ней, подключите устройство к компьютеру по USB кабелю. 

У нас есть аппаратная платформа. Теперь самое время установить средства разработки для неё. Компания производитель Arduino плат предоставляет бесплатную IDE с интегрированным C++ компилятором и библиотеками для поддержки периферии. Скачайте её с [официального веб-сайта](https://www.arduino.cc/en/Main/Software) и установите.

Следующий шаг — установка драйвера для платы Arduino. Для этого запустите программу установки из каталога Arduino IDE. Её путь по-умолчанию: `C:\Program Files (x86)\Arduino\drivers`. В каталоге `drivers` есть две программы для 64-разярдной версии Windows и 32-разрядной: `dpinst-amd64.exe` и `dpinst-x86.exe`. Перед установкой драйвера подключите плату к компьютеру.

После установки IDE выполните следующие шаги для её конфигурации:

1. Прочитайте модель вашей платы. Для этого в главном меню IDE выберите пункт “Tools” ➤ ”Get Board Info” ("Инструменты" ➤ ”Информация о плате”). Проверьте, что в пункте меню “Tools” ➤ ”Board:...” ("Инструменты" ➤ ”Плата:...”) модель указана правильно.

2. Укажите порт подключения платы в пункте главного меню “Tools”➤“Port:...” ("Инструменты" ➤ ”Порт:...”).

Теперь Arduino IDE настроена и готова к работе.

Программа, которую мы напишем для Arduino платы, будет эмулировать устройство ввода. Со стороны компьютера ей будет управлять бот кликер, написанный на языке AutoIt. Для этого взаимодействия понадобится набор скриптов [**CommAPI**](https://www.autoitscript.com/wiki/CommAPI).

## Эмуляция клавиатуры

Есть два варианта реализации бота, использующего эмулятор устройства ввода.

В первом случае все алгоритмы бота реализуются в программе, работающей на плате Arduino. После её загрузки на устройство, всё готово к работе. Бот запускается автоматически, как только вы подключаете плату к компьютеру через USB. Такая архитектура лучше всего подходит для "слепых" ботов, которые нажимают кнопки, не проверяя состояние игровых объектов. К сожалению, программа, запущенная на Arduino не имеет доступа к WinAPI интерфейсу. Следовательно, она не сможет прочитать данные из процесса игрового приложения или устройства вывода.

Если ваш бот должен реагировать на игровые события, следует выбрать второй вариант реализации. В этом случае его алгоритмы запускаются и работают на компьютере. Программа платы Arduino отвечает только за симуляцию событий устройства ввода (например нажатие клавиши). В такой схеме бот имеет полный доступ к WinAPI и может читать состояние игровых объектов. После принятия решения, он отправляет команду плате Arduino на выполнение требуемого действия.

Мы рассмотрим пример второго варианта реализации бота. Он более надёжен в работе и универсален.

Протокол взаимодействия платы и бота может быть любым. Предлагаю остановиться на самом простом варианте и использовать [**UART интерфейс**](https://ru.wikipedia.org/wiki/Универсальный_асинхронный_приёмопередатчик) (Universal Asynchronous Receiver-Transmitter). Для его использования не нужны дополнительные расширения платы Arduino. Достаточно подключения по USB кабелю, через который мы загружаем программу на устройство.

Листинг 5-1 демонстрирует программу `keyboard.ino` для платы Arduino, которая симулирует события клавиатуры. Код клавиши, которую требуется нажать, передаётся по UART интерфейсу.

**Листинг 5-1.** *Программа `keyboard.ino`*
```С++
#include <Keyboard.h>

void setup()
{
  Serial.begin(9600);
  Keyboard.begin();
}

void loop()
{
  if (Serial.available() > 0)
  {
    int incomingByte = Serial.read();
    Keyboard.write(incomingByte);
  }
}
```
Здесь мы используем библиотеку [**Keyboard**](https://www.arduino.cc/reference/en/language/functions/usb/keyboard), которую предоставляет Arduino IDE. Она позволяет генерировать события нажатия клавиш. Подключенный по USB компьютер получает их через [**HID**](https://en.wikipedia.org/wiki/Human_interface_device) (Human Interface Device) интерфейс. Этот интерфейс является стандартом для устройств ввода, использующих USB подключение.

В первой строке программы мы включаем заголовок `Keyboard.h`. В нём создаётся глобальный объект `Keyboard` класса `Keyboard_`. Все возможности библиотеки доступны через его методы.

В нашей программе всего две функции: `setup` и `loop`. В любом C++ приложении обязательно должна быть функция `main`. Она добавляется IDE во времени компиляции. В сгенерированной `main` всего два действия: однократный вызов `setup` и цикличный вызов `loop`. [**Прототипы**](https://ru.wikipedia.org/wiki/Прототип_функции) этих функций предопределены, и поменять их нельзя.

Кроме `Keyboard` мы используем глобальный объект `Serial`. Он предоставляет доступ к интерфейсу UART. Для инициализации объектов в функции `setup` вызываются методы `begin`. Этот метод для `Serial` принимает входным параметром [скорость передачи данных](https://ru.wikipedia.org/wiki/Скорость_передачи_данных) между компьютером и платой, которая в нашем случае равна 9600 бит/c. У метода `begin` объекта `Keyboard` нет входных параметров. Сразу после его вызова плата начинает эмулировать клавиатуру.

После выполнения функции `setup` Arduino плата готова принимать команды по UART интерфейсу, и симулировать нажатия соответствующих клавиш. За это отвечает код функции `loop`. Её алгоритм состоит из трёх шагов:

1. С помощью метода `available` объекта `Serial` проверить, были ли получены данные по UART интерфейсу. Метод возвращает количество принятых байт. Если это значение больше нуля, значит передача была.

2. Прочитать первый байт полученных по UART данных с помощью метода `read` объекта `Serial`. Байт интерпретируется как ASCII код клавиши, нажатие которой следует симулировать.

3. Симулировать нажатие клавиши через HID интерфейс с помощью метода `write` объекта `Keyboard`. Подключённые по USB компьютер обработает его как событие обычной клавиатуры.

Чтобы скомпилировать программу `keyboard.ino` и загрузить её на Arduino плату, нажмите комбинацию клавиш Ctrl+U.

Мы подготовили плату. Теперь разработаем AutoIt скрипт, который будет ей управлять. Он должен посылать через UART интерфейс ASCII коды клавиш. Функции работы с UART доступны через WinAPI интерфейс. Обёртки CommAPI могут значительно упростить доступ к этим функциям из языка AutoIt. Скачайте и скопируйте их в каталог вашего скрипта. Проверьте, что у вас есть все необходимые файлы:

* `CommAPI.au3`
* `CommAPIConstants.au3`
* `CommAPIHelper.au3`
* `CommInterface.au3`
* `CommUtilities.au3`

Листинг 5-2 демонстрирует использование обёрток CommAPI. Приведённый в нём скрипт печатает строку "Hello world!" в окне Notepad с помощью эмулятора устройства ввода.

**Листинг 5-2.** *Скрипт `ControlKeyboard.au3`*
```AutoIt
#include "CommInterface.au3"

func ShowError()
	MsgBox(16, "Error", "Error " & @error)
endfunc

func OpenPort()
	local const $iPort = 7
	local const $iBaud = 9600
	local const $iParity = 0
	local const $iByteSize = 8
	local const $iStopBits = 1

	$hPort = _CommAPI_OpenCOMPort($iPort, $iBaud, $iParity, $iByteSize, $iStopBits)
	if @error then
		ShowError()
		return NULL
	endif

	_CommAPI_ClearCommError($hPort)
	if @error then
		ShowError()
		return NULL
	endif

	_CommAPI_PurgeComm($hPort)
	if @error then
		ShowError()
		return NULL
	endif

	return $hPort
endfunc

func SendArduino($hPort, $command)
	_CommAPI_TransmitString($hPort, $command)
	if @error then ShowError()
endfunc

func ClosePort($hPort)
	_CommAPI_ClosePort($hPort)
	if @error then ShowError()
endfunc

$hWnd = WinGetHandle("[CLASS:Notepad]")
WinActivate($hWnd)
Sleep(200)

$hPort = OpenPort()

SendArduino($hPort, "Hello world!")

ClosePort($hPort)
```
Общий алгоритм скрипта состоит из следующих шагов:

1. Переключиться на окно Notepad с помощью функции AutoIt `WinActivate`.

2. Установить [**последовательное соединение**](https://ru.wikipedia.org/wiki/Последовательное_соединение_(информатика)) (serial communication) с платой Arduino, используя функцию `OpenPort`.

3. Отправить команду набора строки "Hello world!" на плату с помощью функции `SendArduino`.

4. Закрыть последовательное соединение функцией `ClosePort`.

Рассмотрим подробнее работу пользовательских функций `OpenPort`, `SendArduino` и `ClosePort`.

Функция `OpenPort` устанавливает соединение и подготавливает плату Arduino к взаимодействию. Она возвращает дескриптор соединения. В ней происходят следующие вызовы CommAPI:

1. `_CommAPI_OpenCOMPort` устанавливает последовательное соединение с указанными параметрами. Из них `iParity`, `iByteSize` и `iStopBits` одинаковы для Arduino плат всех моделей. Параметр `iBaud` задаёт скорость передачи данных. Она должна соответствовать скорости, переданной в метод `begin` объекта `Serial` в программе платы. Параметр `iPort` равен номеру [**последовательного порта**](https://ru.wikipedia.org/wiki/Последовательный_порт) (COM порта), через который плата подключена к компьютеру. На самом деле подключение происходит по USB, а COM порт эмулируется. Уточнить номер порта можно в пункте меню “Tools” ➤ “Port:...” (“Инструменты” ➤ “Порт:...”) Arduino IDE. Например, если там указан COM7, параметр `iPort` должен быть равен 7.

2. `_CommAPI_ClearCommError` возвращает код ошибки при передаче данных. Через второй необязательный параметр функции возвращается текущее состояние подключённого устройства. В нашем случае он не используется. Функция вызывается для сброса флага ошибки на стороне устройства. Это действие очень важно, поскольку передача данных будет заблокирована до тех пор, пока флаг ошибки взведён.

3. `_CommAPI_PurgeComm` отменяет все текущие операции по передаче данных, а также очищает входной и выходной буферы подключённого устройства. После завершения работы этой функции Arduino готова принимать команды по UART.

Функция `SendArduino` представляет собой обёртку над вызовом `_CommAPI_TransmitString`, который передаёт указанную строку по UART интерфейсу.

Функция `ClosePort` закрывает соединение по указанному дескриптору.

Вспомогательная функция `ShowError` нужна для отладки. Она выводит сообщение с кодом ошибки, которая может произойти на любом этапе установки соединения.

Чтобы протестировать скрипт, выполните следующие действия:

1. Подключите Arduino плату с прошитой программой `keyboard.ino` к компьютеру с помощью USB кабеля.

2. Запустите приложение Notepad.

3. Запустите скрипт `ControlKeyboard.au3`.

В результате в окне Notepad будет набран текст "Hello world!".

### Сочетание клавиш

Разработанная нами программа `keyboard.ino` успешно справляется с симуляцией нажатия одной клавиши за раз. Однако, в некоторых играх может понадобится симулировать [**сочетание клавиш**](https://ru.wikipedia.org/wiki/Сочетание_клавиш), например Ctrl+Z.

Листинг 5-3 демонстрирует усовершенствованную версию программы.

**Листинг 5-3.** *Программа `keyboard-combo.ino`*
```С++
#include <Keyboard.h>

void setup()
{
  Serial.begin(9600);
  Keyboard.begin();
}

void pressKey(char modifier, char key)
{
  Keyboard.press(modifier);
  Keyboard.write(key);
  Keyboard.release(modifier);
}

void loop()
{
  static const char PREAMBLE = 0xDC;
  static const uint8_t BUFFER_SIZE = 3;

  if (Serial.available() > 0)
  {
    char buffer[BUFFER_SIZE] = {0};
    uint8_t readBytes = Serial.readBytes(buffer, BUFFER_SIZE);

    if (readBytes != BUFFER_SIZE)
      return;

    if (buffer[0] != PREAMBLE)
      return;

     pressKey(buffer[1], buffer[2]);
  }
}
```
В новой программе появилась новая функция `pressKey`. Кроме этого, алгоритм `loop` стал сложнее. Теперь мы получаем не один байт с ASCII кодом клавиши, нажатие которой следует симулировать. Управляющий скрипт должен отправить нам команду, состоящую из трёх байт. Её формат выглядит следующим образом:

1. Байт [**преамбулы**](https://ru.wikipedia.org/wiki/Преамбула_(значения)) - это предопределённое значение, которое сигнализирует о начале команды.

2. Код [**клавиши-модификатора**](https://ru.wikipedia.org/wiki/Клавиша-модификатор), которая должна быть нажата в сочетании с основной.

3. Код основной клавиши.

По-сути мы разработали простейший протокол для передачи двух байт информации по UART интерфейсу. Сейчас он поддерживает сочетания только из двух клавиш. Но его можно легко расширить, чтобы передавались две клавиши-модификатора вместо одной.

Можно ли обойтись без первого байта преамбулы в нашем протоколе? Ведь его передача — это накладные расходы. Преамбула решает проблему, когда приём данных по какой-то причине начинается с середины команды, а не начала. Возможна ли такая ситуация в нашем случае? Если к моменту запуска скрипта Arduino плата подключена к компьютеру, этого не произойдёт. Каждая команда управляющего скрипта будет принята и обработана. Однако, если программа на плате по какой-то причине перезагрузится, управляющий скрипт об этом не узнает. Он будет продолжать посылать данные и ожидать, что их обработают. Когда плата запустится снова и начнёт приём данных, скрипт может уже передавать команду. В этом случае возможно, что получен будет только последний байт. Потеря одной команды — это не критичная проблема. Но из-за случившегося сдвига, программа платы будет интерпретировать все последующие входящие команды неверно. Последний байт текущей команды будет "склеен" с первыми двумя байтам следующей и так далее. Таким образом плата окажется неработоспособной. Преамбула и её проверка гарантирует, что такая ситуация не возникнет.

Рассмотрим пример команды для симуляции нажатия Alt+Tab. Управляющий скрипт отправит три байта:
```
0xDC 0x82 0xB3
```
Первый из них (0xDC) - это преамбула. Дальше идёт код клавиши-модификатора 0x82, который соответствует Alt. Последний байт 0xB3 - это код клавиши Tab.

Чтобы прочитать команду в функции `loop`, мы используем метод `readBytes` объекта `Serial` вместо `read`. Он возвращает количество принятых байт. Первый параметр метода — массив, куда они будут сохранены. Второй параметр — максимальный размер этого массива.

Корректность принятой команды проверяется с помощью `if` условий. Первое из них проверяет длину. Второе — соответствие первого байта принятого массива преамбуле. Если любая из проверок не проходит, обработка команды прекращается.

Симуляция нажатия сочетания клавиш происходит в функции `pressKey`. У неё два входных параметра: код модификатора и клавиши. Чтобы нажать и удерживать модификатор, используется метод `press` объекта `Keyboard`. Затем симулируется нажатие основной клавиши с помощью метода `write`. После этого модификатор отпускается вызовом `release`.

Управляющий AutoIt скрипт должен тоже поддерживать протокол передачи команд. Его исправленная версия приведена в листинге 5-4.

**Листинг 5-4.** *Скрипт `ControlKeyboardCombo.au3`*
```AutoIt
#include "CommInterface.au3"

func ShowError()
	MsgBox(16, "Error", "Error " & @error)
endfunc

func OpenPort()
	local const $iPort = 7
	local const $iBaud = 9600
	local const $iParity = 0
	local const $iByteSize = 8
	local const $iStopBits = 1

	$hPort = _CommAPI_OpenCOMPort($iPort, $iBaud, $iParity, $iByteSize, $iStopBits)
	if @error then
		ShowError()
		return NULL
	endif
 
	_CommAPI_ClearCommError($hPort)
	if @error then
		ShowError()
		return NULL
	endif
 
	_CommAPI_PurgeComm($hPort)
	if @error then
		ShowError()
		return NULL
	endif
	
	return $hPort
endfunc

func SendArduino($hPort, $modifier, $key)
	local $command[3] = [0xDC, $modifier, $key]
	
	_CommAPI_TransmitString($hPort, StringFromASCIIArray($command, 0, UBound($command), 1))

	if @error then ShowError()
endfunc

func ClosePort($hPort)
	_CommAPI_ClosePort($hPort)
	if @error then ShowError()
endfunc

$hWnd = WinGetHandle("[CLASS:Notepad]")
WinActivate($hWnd)
Sleep(200)

$hPort = OpenPort()

SendArduino($hPort, 0x82, 0xB3)

ClosePort($hPort)
```
Единственное отличие от скрипта `ControlKeyboard.au3` в функции `SendArduino`. Теперь вместо строки символов, которые передаются последовательно, она передаёт команду из трёх байт: преамбула, модификатор и клавиша. Для отправки данных используется та же CommAPI функция `_CommAPI_TransmitString`. Сложность заключается в том, что эта функция ожидает входным параметром строку. Команда же представляет собой байтовый массив. Его можно преобразовать в строку с помощью стандартной функции AutoIt `StringFromASCIIArray`.

Для тестирования выполните следующие шаги:

1. Загрузите программу `keyboard-combo.ino` на Arduino плату.
2. Откройте несколько окон на компьютере.
3. Запустите скрипт `ControlKeyboardCombo.au3`.

Скрипт будет симулировать нажатие сочетания клавиш Alt+Tab и переключаться между открытыми окнами.

## Эмуляция мыши

Плата Arduino позволяет нам эмулировать как клавиатуру, так и мышь. Для этой задачи IDE предоставляет библиотеку [**Mouse**](https://www.arduino.cc/reference/en/language/functions/usb/mouse). Она предоставляет возможности разработчикам устройств, сходных с мышью: трекболы, джойстики и т.д. По этой причине в библиотеке используются относительные координаты для позиционирования курсора. Это крайне неудобно для наших целей. В идеале управляющий AutoIt скрипт должен указать абсолютную координату точки экрана, а Arduino плата должна симулировать щелчок мыши в ней. Если же для позиционирования использовать относительные координаты, в каждой команде управляющего скрипта придётся указывать текущее положение курсора и смещение  к целевой точке относительно его. Для решения этой проблемы есть два выхода:

1. На стороне управляющего скрипта - реализовать алгоритм для расчёта относительных координат целевой точки.

2. На стороне программы платы - исправить библиотеку Mouse так, чтобы она работала с абсолютными координатами.

Сообщество пользователей Arduino уже решило проблему исправления библиотеки Mouse. Необходимые для этого изменения описаны в [статье](article forum.arduino.cc/index.php?topic=94140.0). К сожалению, описанное решение подходит для старой версий 1.0 Arduino IDE. В ней библиотеки Keyboard и Mouse были объединены в одну под название HID.

Чтобы исправить библиотеку Mouse в новых версиях IDE, выполните следующие действия:

1. Скачайте файл [`Mouse.cpp`](https://github.com/ellysh/practical-video-game-bots/blob/master/Ch05/InputDeviceEmulation/Mouse.cpp) из архива примеров к этой книге.

2. Скопируйте его с заменой в каталог Arduino IDE. Путь по-умолчанию должен быть `C:\Program Files (x86)\Arduino\libraries\Mouse\src`.

Также вы можете исправить файл `Mouse.cpp` самостоятельно. Для этого объявите макрос `ABSOLUTE_MOUSE_MODE` и измените часть массива `_hidReportDescriptor` следующим образом:
```C++
#define ABSOLUTE_MOUSE_MODE

static const uint8_t _hidReportDescriptor[] PROGMEM = {
...
#ifdef ABSOLUTE_MOUSE_MODE
    0x15, 0x01,                    //     LOGICAL_MINIMUM (1)
    0x25, 0x7F,                    //     LOGICAL_MAXIMUM (127)
    0x75, 0x08,                    //     REPORT_SIZE (8)
    0x95, 0x03,                    //     REPORT_COUNT (3)
    0x81, 0x02,                    //     INPUT (Data,Var,Abs)
#else
    0x15, 0x81,                    //     LOGICAL_MINIMUM (-127)
    0x25, 0x7f,                    //     LOGICAL_MAXIMUM (127)
    0x75, 0x08,                    //     REPORT_SIZE (8)
    0x95, 0x03,                    //     REPORT_COUNT (3)
    0x81, 0x06,                    //     INPUT (Data,Var,Rel)
#endif
```
В массиве `_hidReportDescriptor` перечислены данные, которые плата может отправить и получить от компьютера. Другими словами в нём описан протокол передачи данных. Благодаря ему компьютер может взаимодействовать со всем HID устройствами однообразно.

Если макрос `ABSOLUTE_MOUSE_MODE` объявлен, протокол будет изменён в двух местах:

1. Значение байта `LOGICAL_MINIMUM` с ID равным 0x15 изменено с -127 (0x81 в шестнадцатеричной системе) на 1. Таким образом мы задали минимально допустимое значение координаты курсора. Оно может быть отрицательным для относительной координаты, но не абсолютной.

2. Значение байта `INPUT` с ID равным 0x81 изменено с 0x06 на 0x02. Это означает, что теперь будут передаваться абсолютные координаты, а не относительные.

Чтобы переключиться обратно в режим относительных координат, просто удалите объявление макроса `ABSOLUTE_MOUSE_MODE`:
```C++
#define ABSOLUTE_MOUSE_MODE
```
Программа `mouse.ino` из листинга 5-5 симулирует нажатие кнопки мыши в указанной точке экрана.

**Листинг 5-5.** *Программа `mouse.ino`*
```C++
#include <Mouse.h>

void setup()
{
  Serial.begin(9600);
  Mouse.begin();
}

void click(signed char x, signed char y, char button)
{
  Mouse.move(x, y);
  Mouse.click(button);
}

void loop()
{
  static const char PREAMBLE = 0xDC;
  static const uint8_t BUFFER_SIZE = 4;

  if (Serial.available() > 0)
  {
    char buffer[BUFFER_SIZE] = {0};
    uint8_t readBytes = Serial.readBytes(buffer, BUFFER_SIZE);

    if (readBytes != BUFFER_SIZE)
      return;

    if (buffer[0] != PREAMBLE)
      return;

   click(buffer[1], buffer[2], buffer[3]);
  }  
}
```
Алгоритмы программ `mouse.ino` и `keyboard-combo.ino` из листинга 5-3 очень похожи. От управляющего AutoIt скрипта мы получаем команду, состоящую из четырёх байт:

1. Преамбула.
2. Координата X точки, в которой следует симулировать нажатие кнопки.
3. Координата Y точки.
4. Код кнопки мыши, которая будет нажата.

Получив команду по UART интерфейсу, мы проверяем её длину и корректность первого байта преамбулы. Если оба условия выполнены, вызываем функцию `click`. Для симуляции действий мыши используем глобальный объект `Mouse`. Он инициализируется с помощью метода `begin` точно так же, как и `Keyboard`. Перед тем как нажать кнопку, необходимо переместить курсор в заданную координату. Для этого вызываем метод `move` объекта `Mouse`, в который передаём координаты X и Y целевой точки. Затем с помощью метода `click` симулируем нажатие в текущей позиции курсора.

Внимательный читатель заметит, что максимально допустимые значения координат X и Y ограничены числом 127. В шестнадцатеричном виде оно равно 0x7F. Это максимальное положительное число со знаком, которое может быть передано в одном байте. Это ограничение продиктовано протоколом HID. Обратите внимание на значение байта `LOGICAL_MAXIMUM` в массиве `_hidReportDescriptor`:
```C++
    0x25, 0x7f,                    //     LOGICAL_MAXIMUM (127)
```
Следовательно, максимальные координаты, на которые может переместить курсор Arduino плата, равны 127×127. Однако, разрешение современных мониторов значительно превышает эти числа. Перекладка координат HID устройства в координаты монитора происходит на уровне ОС. Чтобы правильно спозиционировать курсор, нам придётся повторить её в нашем управляющем AutoIt скрипте. Скрипт знает абсолютные координаты точки экрана, в которой следует симулировать нажатие кнопки мыши. Задача заключается в том, чтобы перевсти эти координаты в шкалу Arduino платы.

Формулы перевода координат выглядят следующим образом:
```
Xa = 127 * X / Xres
Ya = 127 * Y / Yres
```
Значения переменных приведены в таблице 5-1.

**Таблица 5-1.** *Переменные в формулах перевода координат*

| Переменные | Значение |
| --- | --- |
| Xa, Ya | Координаты X, Y в шкале Arduino. |
| X, Y | Координаты X, Y в шкале экрана. |
| Xres, Yres | Разрешение экрана в пикселях. |

Рассмотрим пример перевода координат с помощью формул. Предположим, что разрешение нашего экрана 1366×768. Управляющий скрипт симулирует нажатие кнопки мыши в точке с координатами экрана X = 250 и Y = 300. Тогда ему надо отправить плате Arduino следующие координаты:
```
Xa = 127 * 250 / 1366 = 23
Ya = 127 * 300 / 768 = 49
```
Команда целиком будет выглядеть следующим образом:
```
0xDC 0x17 0x31 0x1
```
Координата X = 23 в шестнадцатеричном виде равна 0x17, а Y = 49 равна 0x31.

Листинг 5-6 демонстрирует управляющий скрипт для программы `mouse.ino`.

**Листинг 5-6.** *Скрипт `ControlMouse.au3`*
```AutoIt
#include "CommInterface.au3"

func ShowError()
	MsgBox(16, "Error", "Error " & @error)
endfunc

func OpenPort()
	local const $iPort = 8
	local const $iBaud = 9600
	local const $iParity = 0
	local const $iByteSize = 8
	local const $iStopBits = 1

	$hPort = _CommAPI_OpenCOMPort($iPort, $iBaud, $iParity, $iByteSize, $iStopBits)
	if @error then
		ShowError()
		return NULL
	endif
 
	_CommAPI_ClearCommError($hPort)
	if @error then
		ShowError()
		return NULL
	endif
 
	_CommAPI_PurgeComm($hPort)
	if @error then
		ShowError()
		return NULL
	endif

	return $hPort
endfunc

func GetX($x)
	return (127 * $x / 1366)
endfunc

func GetY($y)
	return (127 * $y / 768)
endfunc

func SendArduino($hPort, $x, $y, $button)
	local $command[4] = [0xDC, GetX($x), GetY($y), $button]

	_CommAPI_TransmitString($hPort, StringFromASCIIArray($command, 0, UBound($command), 1))

	if @error then ShowError()
endfunc

func ClosePort($hPort)
	_CommAPI_ClosePort($hPort)
	if @error then ShowError()
endfunc

$hWnd = WinGetHandle("[CLASS:MSPaintApp]")
WinActivate($hWnd)
Sleep(200)

$hPort = OpenPort()

SendArduino($hPort, 250, 300, 1)

ClosePort($hPort)
```
Этот скрипт очень похож на `ControlKeyboardCombo.au3` из листинга 5-4. Теперь в функцию `SendArduino` передаются четыре параметра: номер порта, координаты курсора X и Y, код кнопки для нажатия. Кроме этого появились две новые функции: `GetX` и `GetY`. Они переводят соответствующие координаты из шкалы экрана в шкалу Arduino платы.

---
В функциях `GetX` и `GetY` используется текущее расширение экрана. В нашем примере оно равно 1366×768. Не забудьте поменять его на актуальное значение для вашего монитора.
---

Для тестирования выполните следующие шаги:

1. Загрузите программу `mouse.ino` на Arduino плату.
2. Запустите приложение Paint. Переключитесь в нём на инструмент Brush (кисть).
3. Запустите скрипт `ControlMouse.au3`.

Скрипт симулирует щелчёк левой кнопки мыши в точке с абсолютными координатами 250×300 в окне Paint. В неё должна появиться чёрная точка.

## Эмуляция клавиатуры и мыши
