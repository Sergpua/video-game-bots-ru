# Эмуляция устройств ввода

Рассмотрим технику эмуляции устройств ввода. Этот подход применяется для обхода защит от кликеров, которые проверяют состояние клавиатуры. Подробнее об их алгоритме читайте во второй главе.

Когда мы используем вместо клавиатуры или мыши эмулятор, у ОС нет возможности обнаружить подмену. Симулируемые эмулятором события (например нажатия клавиш) будут обрабатываться ОС точно так же, как и для настоящей клавиатуры. Поэтому защите игрового приложения будет намного сложнее различать действия бота и игрока.

## Инструменты для разработки

Прежде всего нам следует выбрать устройство, которое будет выполнять роль эмулятора. Рассмотрим основные требования к нему:

* Невысокая цена.
* Средства разработки (IDE и компилятор) должны быть бесплатны.
* Среда разработки должна предоставлять библиотеки для эмуляции устройств ввода.
* Должна быть доступная подробная документация.

Плата Arduino удовлетворяет всем перечисленным требованиям. Кроме того эта аппаратная платформа — одна из лучших для знакомства с разработкой программ для встраиваемых систем.

Следующий вопрос, который следует решить: какую версию платы Arduino выбрать? Чтобы ответить на него, изучим возможности средств разработки. Arduino IDE предоставляет [библиотеки](https://www.arduino.cc/reference/en/language/functions/usb/keyboard) для эмуляции клавиатуры и мыши. Согласно документации, некоторые версии плат их не поддерживают. Следовательно, нам они не подойдут. Нас устроят следующие модели: Leonardo, Micro и Due.

У нас есть аппаратная платформа. Теперь самое время установить средства разработки для неё. Компания производитель Arduino плат предоставляет бесплатную IDE с интегрированным C++ компилятором и библиотеками для поддержки периферии. Скачайте её с [официального веб-сайта](https://www.arduino.cc/en/Main/Software) и установите.

Теперь установим драйвер для работы с платой Arduino. Для этого нужна программа установки из каталога Arduino IDE. Её путь по-умолчанию: `C:\Program Files (x86)\Arduino\drivers`. В каталоге `drivers` есть две программы: `dpinst-amd64.exe` для 64-разрядной версии Windows и `dpinst-x86.exe` для 32-разрядной. Выберите подходящую вам и перед её запуском подключите плату к компьютеру с помощью USB кабеля.

После установки драйвера и IDE выполните заключительные шаги конфигурации:

1. Прочитайте модель вашей платы. Для этого в главном меню IDE выберите пункт “Tools” ➤ ”Get Board Info” ("Инструменты" ➤ ”Информация о плате”). Проверьте, что в пункте меню “Tools” ➤ ”Board:...” ("Инструменты" ➤ ”Плата:...”) модель указана правильно.

2. Укажите порт подключения платы в пункте главного меню “Tools”➤“Port:...” ("Инструменты" ➤ ”Порт:...”).

Теперь Arduino IDE настроена и готова к работе.

Самой по себе Arduino платы недостаточно для эмуляции устройств ввода. Мы должны написать для неё программу, которая посылала бы ОС события о симулируемых действиях. Со стороны компьютера этой программой будет управлять бот кликер, написанный на языке AutoIt. Для такого взаимодействия понадобится набор AutoIt скриптов [**CommAPI**](https://www.autoitscript.com/wiki/CommAPI).

## Эмуляция клавиатуры

Есть два варианта реализации бота, использующего эмулятор устройства ввода.

В первом случае все алгоритмы бота реализуются в программе, работающей на плате Arduino. После её загрузки на устройство, всё готово к работе. Бот запускается автоматически, как только вы подключаете плату к компьютеру через USB. Такая архитектура лучше всего подходит для "слепых" ботов, которые нажимают кнопки, не проверяя состояние игровых объектов. К сожалению, программа, запущенная на Arduino не имеет доступа к WinAPI интерфейсу. Следовательно, она не сможет прочитать данные из процесса игрового приложения или устройства вывода.

Если ваш бот должен реагировать на игровые события, следует выбрать второй вариант реализации. В этом случае его алгоритмы запускаются и работают на компьютере. Программа платы Arduino отвечает только за симуляцию событий устройства ввода (например нажатие клавиши). В такой схеме бот имеет полный доступ к WinAPI и может читать состояние игровых объектов. После принятия решения, он отправляет команду плате Arduino на выполнение требуемого действия.

Мы рассмотрим пример второго варианта реализации бота. Он более надёжен в работе и универсален.

Протокол взаимодействия платы и бота может быть любым. Предлагаю остановиться на самом простом варианте и использовать [**UART интерфейс**](https://ru.wikipedia.org/wiki/Универсальный_асинхронный_приёмопередатчик) (Universal Asynchronous Receiver-Transmitter). Для его использования не нужны дополнительные расширения платы Arduino. Достаточно подключения по USB кабелю, через который мы загружаем программу на устройство.

Листинг 5-1 демонстрирует программу `keyboard.ino` для платы Arduino, которая симулирует события клавиатуры. Код клавиши, которую требуется нажать, передаётся по UART интерфейсу.

**Листинг 5-1.** *Программа `keyboard.ino`*
```С++
#include <Keyboard.h>

void setup()
{
  Serial.begin(9600);
  Keyboard.begin();
}

void loop()
{
  if (Serial.available() > 0)
  {
    int incomingByte = Serial.read();
    Keyboard.write(incomingByte);
  }
}
```
Здесь мы используем библиотеку [**Keyboard**](https://www.arduino.cc/reference/en/language/functions/usb/keyboard), которую предоставляет Arduino IDE. Она позволяет генерировать события нажатия клавиш. Подключенный по USB компьютер получает их через [**HID**](https://en.wikipedia.org/wiki/Human_interface_device) (Human Interface Device) интерфейс. Этот интерфейс является стандартом для устройств ввода, использующих USB подключение.

В первой строке программы мы включаем заголовок `Keyboard.h`. В нём создаётся глобальный объект `Keyboard` класса `Keyboard_`. Все возможности библиотеки доступны через его методы.

В нашей программе всего две функции: `setup` и `loop`. В любом C++ приложении обязательно должна быть функция `main`. Она добавляется IDE во времени компиляции. В сгенерированной `main` всего два действия: однократный вызов `setup` и цикличный вызов `loop`. [**Прототипы**](https://ru.wikipedia.org/wiki/Прототип_функции) этих функций предопределены, и поменять их нельзя.

Кроме `Keyboard` мы используем глобальный объект `Serial`. Он предоставляет доступ к интерфейсу UART. Для инициализации объектов в функции `setup` вызываются методы `begin`. Этот метод для `Serial` принимает входным параметром [скорость передачи данных](https://ru.wikipedia.org/wiki/Скорость_передачи_данных) между компьютером и платой, которая в нашем случае равна 9600 бит/c. У метода `begin` объекта `Keyboard` нет входных параметров. Сразу после его вызова плата начинает эмулировать клавиатуру.

После выполнения функции `setup` Arduino плата готова принимать команды по UART интерфейсу, и симулировать нажатия соответствующих клавиш. За это отвечает код функции `loop`. Её алгоритм состоит из трёх шагов:

1. С помощью метода `available` объекта `Serial` проверить, были ли получены данные по UART интерфейсу. Метод возвращает количество принятых байт. Если это значение больше нуля, значит передача была.

2. Прочитать первый байт полученных по UART данных с помощью метода `read` объекта `Serial`. Байт интерпретируется как ASCII код клавиши, нажатие которой следует симулировать.

3. Симулировать нажатие клавиши через HID интерфейс с помощью метода `write` объекта `Keyboard`. Подключённые по USB компьютер обработает его как событие обычной клавиатуры.

Чтобы скомпилировать программу `keyboard.ino` и загрузить её на Arduino плату, нажмите комбинацию клавиш Ctrl+U.

Мы подготовили плату. Теперь разработаем AutoIt скрипт, который будет ей управлять. Он должен посылать через UART интерфейс ASCII коды клавиш. Функции работы с UART доступны через WinAPI интерфейс. Обёртки CommAPI могут значительно упростить доступ к этим функциям из языка AutoIt. Скачайте и скопируйте их в каталог вашего скрипта. Проверьте, что у вас есть все необходимые файлы:

* `CommAPI.au3`
* `CommAPIConstants.au3`
* `CommAPIHelper.au3`
* `CommInterface.au3`
* `CommUtilities.au3`

Листинг 5-2 демонстрирует использование обёрток CommAPI. Приведённый в нём скрипт печатает строку "Hello world!" в окне Notepad с помощью эмулятора устройства ввода.

**Листинг 5-2.** *Скрипт `ControlKeyboard.au3`*
```AutoIt
#include "CommInterface.au3"

func ShowError()
	MsgBox(16, "Error", "Error " & @error)
endfunc

func OpenPort()
	local const $iPort = 7
	local const $iBaud = 9600
	local const $iParity = 0
	local const $iByteSize = 8
	local const $iStopBits = 1

	$hPort = _CommAPI_OpenCOMPort($iPort, $iBaud, $iParity, $iByteSize, $iStopBits)
	if @error then
		ShowError()
		return NULL
	endif

	_CommAPI_ClearCommError($hPort)
	if @error then
		ShowError()
		return NULL
	endif

	_CommAPI_PurgeComm($hPort)
	if @error then
		ShowError()
		return NULL
	endif

	return $hPort
endfunc

func SendArduino($hPort, $command)
	_CommAPI_TransmitString($hPort, $command)
	if @error then ShowError()
endfunc

func ClosePort($hPort)
	_CommAPI_ClosePort($hPort)
	if @error then ShowError()
endfunc

$hWnd = WinGetHandle("[CLASS:Notepad]")
WinActivate($hWnd)
Sleep(200)

$hPort = OpenPort()

SendArduino($hPort, "Hello world!")

ClosePort($hPort)
```
Общий алгоритм скрипта состоит из следующих шагов:

1. Переключиться на окно Notepad с помощью функции AutoIt `WinActivate`.

2. Установить [**последовательное соединение**](https://ru.wikipedia.org/wiki/Последовательное_соединение_(информатика)) (serial communication) с платой Arduino, используя функцию `OpenPort`.

3. Отправить команду набора строки "Hello world!" на плату с помощью функции `SendArduino`.

4. Закрыть последовательное соединение функцией `ClosePort`.

Рассмотрим подробнее работу пользовательских функций `OpenPort`, `SendArduino` и `ClosePort`.

Функция `OpenPort` устанавливает соединение и подготавливает плату Arduino к взаимодействию. Она возвращает дескриптор соединения. В ней происходят следующие вызовы CommAPI:

1. `_CommAPI_OpenCOMPort` устанавливает последовательное соединение с указанными параметрами. Из них `iParity`, `iByteSize` и `iStopBits` одинаковы для Arduino плат всех моделей. Параметр `iBaud` задаёт скорость передачи данных. Она должна соответствовать скорости, переданной в метод `begin` объекта `Serial` в программе платы. Параметр `iPort` равен номеру [**последовательного порта**](https://ru.wikipedia.org/wiki/Последовательный_порт) (COM порта), через который плата подключена к компьютеру. На самом деле подключение происходит по USB, а COM порт эмулируется. Уточнить номер порта можно в пункте меню “Tools” ➤ “Port:...” (“Инструменты” ➤ “Порт:...”) Arduino IDE. Например, если там указан COM7, параметр `iPort` должен быть равен 7.

2. `_CommAPI_ClearCommError` возвращает код ошибки при передаче данных. Через второй необязательный параметр функции возвращается текущее состояние подключённого устройства. В нашем случае он не используется. Функция вызывается для сброса флага ошибки на стороне устройства. Это действие очень важно, поскольку передача данных будет заблокирована до тех пор, пока флаг ошибки взведён.

3. `_CommAPI_PurgeComm` отменяет все текущие операции по передаче данных, а также очищает входной и выходной буферы подключённого устройства. После завершения работы этой функции Arduino готова принимать команды по UART.

Функция `SendArduino` представляет собой обёртку над вызовом `_CommAPI_TransmitString`, который передаёт указанную строку по UART интерфейсу.

Функция `ClosePort` закрывает соединение по указанному дескриптору.

Вспомогательная функция `ShowError` нужна для отладки. Она выводит сообщение с кодом ошибки, которая может произойти на любом этапе установки соединения.

Чтобы протестировать скрипт, выполните следующие действия:

1. Подключите Arduino плату с прошитой программой `keyboard.ino` к компьютеру с помощью USB кабеля.

2. Запустите приложение Notepad.

3. Запустите скрипт `ControlKeyboard.au3`.

В результате в окне Notepad будет набран текст "Hello world!".

### Сочетание клавиш

Разработанная нами программа `keyboard.ino` успешно справляется с симуляцией нажатия одной клавиши за раз. Однако, в некоторых играх может понадобится симулировать [**сочетание клавиш**](https://ru.wikipedia.org/wiki/Сочетание_клавиш), например Ctrl+Z.

Листинг 5-3 демонстрирует усовершенствованную версию программы.

**Листинг 5-3.** *Программа `keyboard-combo.ino`*
```С++
#include <Keyboard.h>

void setup()
{
  Serial.begin(9600);
  Keyboard.begin();
}

void pressKey(char modifier, char key)
{
  Keyboard.press(modifier);
  Keyboard.write(key);
  Keyboard.release(modifier);
}

void loop()
{
  static const char PREAMBLE = 0xDC;
  static const uint8_t BUFFER_SIZE = 3;

  if (Serial.available() > 0)
  {
    char buffer[BUFFER_SIZE] = {0};
    uint8_t readBytes = Serial.readBytes(buffer, BUFFER_SIZE);

    if (readBytes != BUFFER_SIZE)
      return;

    if (buffer[0] != PREAMBLE)
      return;

     pressKey(buffer[1], buffer[2]);
  }
}
```
В новой программе появилась новая функция `pressKey`. Кроме этого, алгоритм `loop` стал сложнее. Теперь мы получаем не один байт с ASCII кодом клавиши, нажатие которой следует симулировать. Управляющий скрипт должен отправить нам команду, состоящую из трёх байт. Её формат выглядит следующим образом:

1. Байт [**преамбулы**](https://ru.wikipedia.org/wiki/Преамбула_(значения)) - это предопределённое значение, которое сигнализирует о начале команды.

2. Код [**клавиши-модификатора**](https://ru.wikipedia.org/wiki/Клавиша-модификатор), которая должна быть нажата в сочетании с основной.

3. Код основной клавиши.

По-сути мы разработали простейший протокол для передачи двух байт информации по UART интерфейсу. Сейчас он поддерживает сочетания только из двух клавиш. Но его можно легко расширить, чтобы передавались две клавиши-модификатора вместо одной.

Можно ли обойтись без первого байта преамбулы в нашем протоколе? Ведь его передача — это накладные расходы. Преамбула решает проблему, когда приём данных по какой-то причине начинается с середины команды, а не начала. Возможна ли такая ситуация в нашем случае? Если к моменту запуска скрипта Arduino плата подключена к компьютеру, этого не произойдёт. Каждая команда управляющего скрипта будет принята и обработана. Однако, если программа на плате по какой-то причине перезагрузится, управляющий скрипт об этом не узнает. Он будет продолжать посылать данные и ожидать, что их обработают. Когда плата запустится снова и начнёт приём данных, скрипт может уже передавать команду. В этом случае возможно, что получен будет только последний байт. Потеря одной команды — это не критичная проблема. Но из-за случившегося сдвига, программа платы будет интерпретировать все последующие входящие команды неверно. Последний байт текущей команды будет "склеен" с первыми двумя байтам следующей и так далее. Таким образом плата окажется неработоспособной. Преамбула и её проверка гарантирует, что такая ситуация не возникнет.

Рассмотрим пример команды для симуляции нажатия Alt+Tab. Управляющий скрипт отправит три байта:
```
0xDC 0x82 0xB3
```
Первый из них (0xDC) - это преамбула. Дальше идёт код клавиши-модификатора 0x82, который соответствует Alt. Последний байт 0xB3 - это код клавиши Tab.

Чтобы прочитать команду в функции `loop`, мы используем метод `readBytes` объекта `Serial` вместо `read`. Он возвращает количество принятых байт. Первый параметр метода — массив, куда они будут сохранены. Второй параметр — максимальный размер этого массива.

Корректность принятой команды проверяется с помощью `if` условий. Первое из них проверяет длину. Второе — соответствие первого байта принятого массива преамбуле. Если любая из проверок не проходит, обработка команды прекращается.

Симуляция нажатия сочетания клавиш происходит в функции `pressKey`. У неё два входных параметра: код модификатора и клавиши. Чтобы нажать и удерживать модификатор, используется метод `press` объекта `Keyboard`. Затем симулируется нажатие основной клавиши с помощью метода `write`. После этого модификатор отпускается вызовом `release`.

Управляющий AutoIt скрипт должен тоже поддерживать протокол передачи команд. Его исправленная версия приведена в листинге 5-4.

**Листинг 5-4.** *Скрипт `ControlKeyboardCombo.au3`*
```AutoIt
#include "CommInterface.au3"

func ShowError()
	MsgBox(16, "Error", "Error " & @error)
endfunc

func OpenPort()
	local const $iPort = 7
	local const $iBaud = 9600
	local const $iParity = 0
	local const $iByteSize = 8
	local const $iStopBits = 1

	$hPort = _CommAPI_OpenCOMPort($iPort, $iBaud, $iParity, $iByteSize, $iStopBits)
	if @error then
		ShowError()
		return NULL
	endif
 
	_CommAPI_ClearCommError($hPort)
	if @error then
		ShowError()
		return NULL
	endif
 
	_CommAPI_PurgeComm($hPort)
	if @error then
		ShowError()
		return NULL
	endif
	
	return $hPort
endfunc

func SendArduino($hPort, $modifier, $key)
	local $command[3] = [0xDC, $modifier, $key]
	
	_CommAPI_TransmitString($hPort, StringFromASCIIArray($command, 0, UBound($command), 1))

	if @error then ShowError()
endfunc

func ClosePort($hPort)
	_CommAPI_ClosePort($hPort)
	if @error then ShowError()
endfunc

$hWnd = WinGetHandle("[CLASS:Notepad]")
WinActivate($hWnd)
Sleep(200)

$hPort = OpenPort()

SendArduino($hPort, 0x82, 0xB3)

ClosePort($hPort)
```
Единственное отличие от скрипта `ControlKeyboard.au3` в функции `SendArduino`. Теперь вместо строки символов, которые передаются последовательно, она передаёт команду из трёх байт: преамбула, модификатор и клавиша. Для отправки данных используется та же CommAPI функция `_CommAPI_TransmitString`. Сложность заключается в том, что эта функция ожидает входным параметром строку. Команда же представляет собой байтовый массив. Его можно преобразовать в строку с помощью стандартной функции AutoIt `StringFromASCIIArray`.

Для тестирования выполните следующие шаги:

1. Загрузите программу `keyboard-combo.ino` на Arduino плату.
2. Откройте несколько окон на компьютере.
3. Запустите скрипт `ControlKeyboardCombo.au3`.

Скрипт будет симулировать нажатие сочетания клавиш Alt+Tab и переключаться между открытыми окнами.

## Эмуляция мыши

Плата Arduino позволяет нам эмулировать как клавиатуру, так и мышь. Для этой задачи IDE предоставляет библиотеку [**Mouse**](https://www.arduino.cc/reference/en/language/functions/usb/mouse). Она предоставляет возможности разработчикам устройств, сходных с мышью: трекболы, джойстики и т.д. По этой причине в библиотеке используются относительные координаты для позиционирования курсора. Это крайне неудобно для наших целей. В идеале управляющий AutoIt скрипт должен указать абсолютную координату точки экрана, а Arduino плата должна симулировать щелчок мыши в ней. Если же для позиционирования использовать относительные координаты, в каждой команде управляющего скрипта придётся указывать текущее положение курсора и смещение  к целевой точке относительно его. Для решения этой проблемы есть два выхода:

1. На стороне управляющего скрипта - реализовать алгоритм для расчёта относительных координат целевой точки.

2. На стороне программы платы - исправить библиотеку Mouse так, чтобы она работала с абсолютными координатами.

Сообщество пользователей Arduino уже решило проблему исправления библиотеки Mouse. Необходимые для этого изменения описаны в [статье](article forum.arduino.cc/index.php?topic=94140.0). К сожалению, описанное решение подходит для старой версий 1.0 Arduino IDE. В ней библиотеки Keyboard и Mouse были объединены в одну под название HID.

Чтобы исправить библиотеку Mouse в новых версиях IDE, выполните следующие действия:

1. Скачайте файл [`Mouse.cpp`](https://github.com/ellysh/practical-video-game-bots/blob/master/Ch05/InputDeviceEmulation/Mouse.cpp) из архива примеров к этой книге.

2. Скопируйте его с заменой в каталог Arduino IDE. Путь по-умолчанию должен быть `C:\Program Files (x86)\Arduino\libraries\Mouse\src`.

Также вы можете исправить файл `Mouse.cpp` самостоятельно. Для этого объявите макрос `ABSOLUTE_MOUSE_MODE` и измените часть массива `_hidReportDescriptor` следующим образом:
```C++
#define ABSOLUTE_MOUSE_MODE

static const uint8_t _hidReportDescriptor[] PROGMEM = {
...
#ifdef ABSOLUTE_MOUSE_MODE
    0x15, 0x01,                    //     LOGICAL_MINIMUM (1)
    0x25, 0x7F,                    //     LOGICAL_MAXIMUM (127)
    0x75, 0x08,                    //     REPORT_SIZE (8)
    0x95, 0x03,                    //     REPORT_COUNT (3)
    0x81, 0x02,                    //     INPUT (Data,Var,Abs)
#else
    0x15, 0x81,                    //     LOGICAL_MINIMUM (-127)
    0x25, 0x7f,                    //     LOGICAL_MAXIMUM (127)
    0x75, 0x08,                    //     REPORT_SIZE (8)
    0x95, 0x03,                    //     REPORT_COUNT (3)
    0x81, 0x06,                    //     INPUT (Data,Var,Rel)
#endif
```
В массиве `_hidReportDescriptor` перечислены данные, которые плата может отправить и получить от компьютера. Другими словами в нём описан протокол передачи данных. Благодаря ему компьютер может взаимодействовать со всем HID устройствами однообразно.

Если макрос `ABSOLUTE_MOUSE_MODE` объявлен, протокол будет изменён в двух местах:

1. Значение байта `LOGICAL_MINIMUM` с ID равным 0x15 изменено с -127 (0x81 в шестнадцатеричной системе) на 1. Таким образом мы задали минимально допустимое значение координаты курсора. Оно может быть отрицательным для относительной координаты, но не абсолютной.

2. Значение байта `INPUT` с ID равным 0x81 изменено с 0x06 на 0x02. Это означает, что теперь будут передаваться абсолютные координаты, а не относительные.

Чтобы переключиться обратно в режим относительных координат, просто удалите объявление макроса `ABSOLUTE_MOUSE_MODE`:
```C++
#define ABSOLUTE_MOUSE_MODE
```
Программа `mouse.ino` из листинга 5-5 симулирует нажатие кнопки мыши в указанной точке экрана.

**Листинг 5-5.** *Программа `mouse.ino`*
```C++
#include <Mouse.h>

void setup()
{
  Serial.begin(9600);
  Mouse.begin();
}

void click(signed char x, signed char y, char button)
{
  Mouse.move(x, y);
  Mouse.click(button);
}

void loop()
{
  static const char PREAMBLE = 0xDC;
  static const uint8_t BUFFER_SIZE = 4;

  if (Serial.available() > 0)
  {
    char buffer[BUFFER_SIZE] = {0};
    uint8_t readBytes = Serial.readBytes(buffer, BUFFER_SIZE);

    if (readBytes != BUFFER_SIZE)
      return;

    if (buffer[0] != PREAMBLE)
      return;

   click(buffer[1], buffer[2], buffer[3]);
  }  
}
```
Алгоритмы программ `mouse.ino` и `keyboard-combo.ino` из листинга 5-3 очень похожи. От управляющего AutoIt скрипта мы получаем команду, состоящую из четырёх байт:

1. Преамбула.
2. Координата X точки, в которой следует симулировать нажатие кнопки.
3. Координата Y точки.
4. Код кнопки мыши, которая будет нажата.

Получив команду по UART интерфейсу, мы проверяем её длину и корректность первого байта преамбулы. Если оба условия выполнены, вызываем функцию `click`. Для симуляции действий мыши используем глобальный объект `Mouse`. Он инициализируется с помощью метода `begin` точно так же, как и `Keyboard`. Перед тем как нажать кнопку, необходимо переместить курсор в заданную координату. Для этого вызываем метод `move` объекта `Mouse`, в который передаём координаты X и Y целевой точки. Затем с помощью метода `click` симулируем нажатие в текущей позиции курсора.

Внимательный читатель заметит, что максимально допустимые значения координат X и Y ограничены числом 127. В шестнадцатеричном виде оно равно 0x7F. Это максимальное положительное число со знаком, которое может быть передано в одном байте. Это ограничение продиктовано протоколом HID. Обратите внимание на значение байта `LOGICAL_MAXIMUM` в массиве `_hidReportDescriptor`:
```C++
    0x25, 0x7f,                    //     LOGICAL_MAXIMUM (127)
```
Следовательно, максимальные координаты, на которые может переместить курсор Arduino плата, равны 127×127. Однако, разрешение современных мониторов значительно превышает эти числа. Перекладка координат HID устройства в координаты монитора происходит на уровне ОС. Чтобы правильно спозиционировать курсор, нам придётся повторить её в нашем управляющем AutoIt скрипте. Скрипт знает абсолютные координаты точки экрана, в которой следует симулировать нажатие кнопки мыши. Задача заключается в том, чтобы перевсти эти координаты в шкалу Arduino платы.

Формулы перевода координат выглядят следующим образом:
```
Xa = 127 * X / Xres
Ya = 127 * Y / Yres
```
Значения переменных приведены в таблице 5-1.

**Таблица 5-1.** *Переменные в формулах перевода координат*

| Переменные | Значение |
| --- | --- |
| Xa, Ya | Координаты X, Y в шкале Arduino. |
| X, Y | Координаты X, Y в шкале экрана. |
| Xres, Yres | Разрешение экрана в пикселях. |

Рассмотрим пример перевода координат с помощью формул. Предположим, что разрешение нашего экрана 1366×768. Управляющий скрипт симулирует нажатие кнопки мыши в точке с координатами экрана X = 250 и Y = 300. Тогда ему надо отправить плате Arduino следующие координаты:
```
Xa = 127 * 250 / 1366 = 23
Ya = 127 * 300 / 768 = 49
```
Команда целиком будет выглядеть следующим образом:
```
0xDC 0x17 0x31 0x1
```
Координата X = 23 в шестнадцатеричном виде равна 0x17, а Y = 49 равна 0x31.

Листинг 5-6 демонстрирует управляющий скрипт для программы `mouse.ino`.

**Листинг 5-6.** *Скрипт `ControlMouse.au3`*
```AutoIt
#include "CommInterface.au3"

func ShowError()
	MsgBox(16, "Error", "Error " & @error)
endfunc

func OpenPort()
	local const $iPort = 8
	local const $iBaud = 9600
	local const $iParity = 0
	local const $iByteSize = 8
	local const $iStopBits = 1

	$hPort = _CommAPI_OpenCOMPort($iPort, $iBaud, $iParity, $iByteSize, $iStopBits)
	if @error then
		ShowError()
		return NULL
	endif
 
	_CommAPI_ClearCommError($hPort)
	if @error then
		ShowError()
		return NULL
	endif
 
	_CommAPI_PurgeComm($hPort)
	if @error then
		ShowError()
		return NULL
	endif

	return $hPort
endfunc

func GetX($x)
	return (127 * $x / 1366)
endfunc

func GetY($y)
	return (127 * $y / 768)
endfunc

func SendArduino($hPort, $x, $y, $button)
	local $command[4] = [0xDC, GetX($x), GetY($y), $button]

	_CommAPI_TransmitString($hPort, StringFromASCIIArray($command, 0, UBound($command), 1))

	if @error then ShowError()
endfunc

func ClosePort($hPort)
	_CommAPI_ClosePort($hPort)
	if @error then ShowError()
endfunc

$hWnd = WinGetHandle("[CLASS:MSPaintApp]")
WinActivate($hWnd)
Sleep(200)

$hPort = OpenPort()

SendArduino($hPort, 250, 300, 1)

ClosePort($hPort)
```
Этот скрипт очень похож на `ControlKeyboardCombo.au3` из листинга 5-4. Теперь в функцию `SendArduino` передаются четыре параметра: номер порта, координаты курсора X и Y, код кнопки для нажатия. Кроме этого появились две новые функции: `GetX` и `GetY`. Они переводят соответствующие координаты из шкалы экрана в шкалу Arduino платы.

---
В функциях `GetX` и `GetY` используется текущее расширение экрана. В нашем примере оно равно 1366×768. Не забудьте поменять его на актуальное значение для вашего монитора.
---

Для тестирования выполните следующие шаги:

1. Загрузите программу `mouse.ino` на Arduino плату.
2. Запустите приложение Paint. Переключитесь в нём на инструмент Brush (кисть).
3. Запустите скрипт `ControlMouse.au3`.

Скрипт симулирует щелчок левой кнопки мыши в точке с абсолютными координатами 250×300 в окне Paint. В неё должна появиться чёрная точка.

## Эмуляция клавиатуры и мыши

Мы разработали программы для Arduino платы, чтобы эмулировать клавиатуру и мышь по отдельности. Следовательно, если для управления персонажем в игре требуется оба устройства ввода, нам надо иметь две платы для эмуляции каждого из них. Возникает вопрос: можем ли мы совместить эти функции в одном устройстве? HID интерфейс это позволяет. Единственная сложность заключается в протоколе передачи данных по UART интерфейсу. Нам придётся его расширить.

Прежде всего программа платы должна понять, какое именно действие требует выполнить управляющий AutoIt скрипт. Назначим каждому из возможных действий код. Например, как предложено в таблице 5-2.

**Таблица 5-2.** *Коды симулируемых действий*

| Код | Действие |
| --- | --- |
| 0x1 | Нажатие клавиши без модификатора. |
| 0x2 | Нажатие клавиши с модификатором. |
| 0x3 | Щелчок мыши. |

В команде код действия должен идти сразу после байта преамбулы. Благодаря этому программа сможет правильно интерпретировать оставшиеся данные. Если код равен 0x1 или 0x2, применяется алгоритм симуляции нажатия клавиши из программы `keyboard-combo.ino` (листинг 5-3). В случае кода 0x3, отрабатывает код программы `mouse.ino` (листинг 5-5).

Листинг 5-7 демонстрирует конечное решение для платы.

**Листинг 5-7.** *Программа `keyboard-mouse.ino`*
```C++
#include <Mouse.h>
#include <Keyboard.h>

void setup()
{
  Serial.begin(9600);
  Keyboard.begin();
  Mouse.begin();
}

void pressKey(char key)
{
  Keyboard.write(key);
}

void pressKey(char modifier, char key)
{
  Keyboard.press(modifier);
  Keyboard.write(key);
  Keyboard.release(modifier);
}

void click(signed char x, signed char y, char button)
{
  Mouse.move(x, y);
  Mouse.click(button);
}

void loop()
{
  static const char PREAMBLE = 0xDC;
  static const uint8_t BUFFER_SIZE = 5;
  enum
  {
    KEYBOARD_COMMAND = 0x1,
    KEYBOARD_MODIFIER_COMMAND = 0x2,
    MOUSE_COMMAND = 0x3
  };
  
  if (Serial.available() > 0)
  {
    char buffer[BUFFER_SIZE] = {0};
    uint8_t readBytes = Serial.readBytes(buffer, BUFFER_SIZE);
    
    if (readBytes != BUFFER_SIZE)
      return;

    if (buffer[0] != PREAMBLE)
      return;

    switch(buffer[1])
    {
      case KEYBOARD_COMMAND:
        pressKey(buffer[3]);
        break;

      case KEYBOARD_MODIFIER_COMMAND:
        pressKey(buffer[2], buffer[3]);
        break;

      case MOUSE_COMMAND:
        click(buffer[2], buffer[3], buffer[4]);
        break;
    }
  }  
}
```
Чтобы корректно обрабатывать различные действия, мы добавили оператор `switch` в функцию `loop`. С его помощью выбирается функция обработки байтов команды, следующих за преамбулой и кодом действия.

Возможно, вы заметили, что для команды на нажатие клавиши управляющий скрипт передаёт данные. Метод `readBytes` объекта `Serial` всегда читает 4 байта (это константа `BUFFER_SIZE`) по UART. Но используются из них только 2 в случае нажатия без модификатора или 3 - с модификатором. Можно ли оптимизировать эти накладные расходы и не передавать лишние данные? Предположим, что мы исправили управляющий скрипт. В результате длина команды будет зависеть от кода действия, указанного во втором байте. Проблема в том, что мы должны передать в метод `readBytes` число байт для чтения из входного буфера UART. На момент его вызова, эта информация неизвестна. Поэтому нам придётся воспользоваться другим методом объекта `Serial`.

Метод `readBytesUntil` позволяет читать байты из входного буфера до тех пор, пока не встретится символ ограничитель или терминатор. Ограничитель - это предопределённое значение, которое сигнализирует об окончании передачи. Этот подход выглядит перспективным. Единственный вопрос, на который осталось ответить: какой ограничитель выбрать? Если вы задумаетесь над ним, то придёте к выводу, что однозначного ответа нет. Ограничитель, как и преамбула, - это один байт. Кроме того его значение не должно встречаться в данных команды. Какие данные у нас есть? Координаты позиции курсора мыши от 0x00 до 0x7F. Код клавиши от 0x00 до 0xFF. К сожалению, код клавиши может быть любым из диапазона значений, помещающихся в один байт. Поэтому мы не можем гарантировать уникальность ограничителя. Мы могли бы увеличить его длину до двух байт. Это бы решило проблему, но тогда мы ничего не выиграем от команд переменной длины. Нам придётся передвавать столько же байт, а иногда и больше, как и в случае с четырёх байтными командами.

Объект `Serial` предоставляет ещё метод `read`. Он читает все байты, находящиеся во входном буфере UART. Он мог бы решить нашу проблему, но только в том случае, если управляющий скрипт будет делать задержки между командами. Длительности задержки должно быть достаточно, чтобы программа Arduino успела прочитать буфер. В противном случае в буфер будут попадать несколько команд за раз и их будет невозможно различить. Этот подход ненадёжен, поскольку скрипт может генерировать запросы к плате очень часто.

В результате мы приходим к выводу, что накладные расходы, связанные с фиксированной длиной команды, приемлемы. Ими мы расплачиваемся за надёжную передачи данных.

Листинг 5-8 демонстриурует управляющий скрипт для программы `keyboard-mouse.ino`.

**Листинг 5-8.** *Скрипт `ControlKeyboardMouse.au3`*
```AutoIt
#include "CommInterface.au3"

func ShowError()
	MsgBox(16, "Error", "Error " & @error)
endfunc

func OpenPort()
	local const $iPort = 10
	local const $iBaud = 9600
	local const $iParity = 0
	local const $iByteSize = 8
	local const $iStopBits = 1

	$hPort = _CommAPI_OpenCOMPort($iPort, $iBaud, $iParity, $iByteSize, $iStopBits)
	if @error then
		ShowError()
		return NULL
	endif
 
	_CommAPI_ClearCommError($hPort)
	if @error then
		ShowError()
		return NULL
	endif
 
	_CommAPI_PurgeComm($hPort)
	if @error then
		ShowError()
		return NULL
	endif

	return $hPort
endfunc

func SendArduinoKeyboard($hPort, $modifier, $key)
	if $modifier == NULL then
		local $command[5] = [0xDC, 0x1, 0xFF, $key, 0xFF]
	else
		local $command[5] = [0xDC, 0x2, $modifier, $key, 0xFF]
	endif

	_CommAPI_TransmitString($hPort, StringFromASCIIArray($command, 0, UBound($command), 1))

	if @error then ShowError()
endfunc

func GetX($x)
	return (127 * $x / 1366)
endfunc

func GetY($y)
	return (127 * $y / 768)
endfunc

func SendArduinoMouse($hPort, $x, $y, $button)
	local $command[5] = [0xDC, 0x3, GetX($x), GetY($y), $button]

	_CommAPI_TransmitString($hPort, StringFromASCIIArray($command, 0, UBound($command), 1))

	if @error then ShowError()
endfunc

func ClosePort($hPort)
	_CommAPI_ClosePort($hPort)
	if @error then ShowError()
endfunc

$hPort = OpenPort()

$hWnd = WinGetHandle("[CLASS:MSPaintApp]")
WinActivate($hWnd)
Sleep(200)

SendArduinoMouse($hPort, 250, 300, 1)

Sleep(1000)

$hWnd = WinGetHandle("[CLASS:Notepad]")
WinActivate($hWnd)
Sleep(200)

SendArduinoKeyboard($hPort, Null, 0x54) ; T
SendArduinoKeyboard($hPort, Null, 0x65) ; e
SendArduinoKeyboard($hPort, Null, 0x73) ; s
SendArduinoKeyboard($hPort, Null, 0x74) ; t

Sleep(1000)

SendArduinoKeyboard($hPort, 0x82, 0xB3) ; Alt+Tab

ClosePort($hPort)
```
В этом скрипте мы реализовали две отдельные функции для симулирования действий клавиатуры и мыши. `SendArduinoKeyboard` отправляет на плату команду для симуляции нажатия клавиши. Её алгоритм почти такой же, как у функции `SendArduino` из скрипта `ControlKeyboardCombo.au3` (листинг 5-4). Отличие в формате команды - появился байт с кодом действия. Также мы дополняем байтовый массив на выдачу до необходимой длины в пять байт с помощью константного значения 0xFF. Если нажатие симулируется без модификатора, то третий байт сообщения также заменяется на 0xFF.

Функция `SendArduinoMouse` отправляет команду для симуляции щелчка мыши. Единственное её отличие от аналога из скрипта `ControlMouse.au3` (листинг 5-6) - код действия во втором байте.

Чтобы протестировать скрипт `ControlKeyboardMouse.au3`, выполните следующие действияЖ

1. Загрузите программу `keyboard-mouse.ino` на Arduino плату.

2. Запустите приложение Paint.

3. Запустите приложение Notepad.

4. Запустите скрипт.

Скрипт последовательно выполнит три действия:

1. Щелчок левой кнопкой мыши в окне Paint.

2. Набор строки "Test" в окне Notepad.

3. Переключение между открытыми окнами с помощью комбинации клавиш Alt+Tab.

Может возникнуть вопрос: почему мы использовали константное значение 0xFF для дополнения команд до нужной длины? Разумнее было бы подставлять 0x00. Это решение продиктовано особенностью AutoIt функции `StringFromASCIIArray`, с помощью которой мы конвертируем массив в строку. Она обрабатывает значение 0x00, как ограничитель строки. Другими словами, результирующая строка будет обрезана до этого символа. Эта особенность наводит на другую мысль - наши команды не должны содержать нулевых байтов. Следовательно, мы не сможем симулировать нажатие клавиши с кодом 0x00.

## Выводы

Мы рассмотрели технику эмуляции клавиатуры и мыши с помощью платы Arduino. Управляющий AutoIt скрипт, в котором реализованы все алгоритмы бота, может управлять ею через UART интерфейс. Такми образом вы можете совместить возможности анализа изображения на экране и симуляции действий устройств ввода. Благодаря этому вашего кликера будет невозможно обнаружить с помощью защит, основанных на прверке состояния клавиатуры и мыши.