# Эмуляция устройств ввода

Рассмотрим способ эмуляции устройств ввода. Этот подход применяется для обхода защиты от кликеров, которая проверяет состояние клавиатуры. Подробнее об алгоритме такой защиты читайте во второй главе.

Когда мы используем эмулятор клавиатуры или мыши, у ОС нет возможности обнаружить подмену. Эмулятор будет обрабатываться как обычное устройство ввода. Поэтому защита игрового приложения не сможет отличить действия бота от действий игрока.

## Инструменты для разработки

Прежде всего нам следует выбрать устройство, которое будет использоваться в качестве эмулятора. Чтобы сделать правильный выбор, рассмотрим основные требования к такому устройству:

* Невысокая цена.
* Средства разработки (IDE и компилятор) должны быть бесплатны.
* Среда разработки должна предоставлять библиотеки для эмуляции устройств ввода.
* Должна быть доступная подробная документация.

Плата Arduino удовлетворяет всем перечисленным требованиям. Кроме того эта аппаратная платформа — одна из лучших для знакомства с разработкой для встраиваемых систем.

Следующий вопрос, который нам следует решить: какую версию платы Arduino следует выбрать? Чтобы ответить на этот вопрос, обратимся к средствам разработки. Arduino IDE предоставляет [библиотеки](https://www.arduino.cc/reference/en/language/functions/usb/keyboard) для эмуляции клавиатуры и мыши. Согласно документации, некоторые версии плат их не поддерживают, и нам они не подходят. Нас устроит плата Leonardo, Micro или Due. Чтобы начать работать с ней, подключите устройство к компьютеру по USB кабелю. 

У нас есть аппаратная платформа. Теперь самое время установить средства разработки для неё. Компания производитель Arduino плат предоставляет бесплатную IDE с интегрированным C++ компилятором и библиотеками для поддержки периферии. Скачайте её с [официального веб-сайта](https://www.arduino.cc/en/Main/Software) и установите.

Следующий шаг — установка драйвера для платы Arduino. Для этого запустите программу установки из каталога Arduino IDE. Её путь по-умолчанию: `C:\Program Files (x86)\Arduino\drivers`. В каталоге `drivers` есть две программы для 64-разярдной версии Windows и 32-разрядной: `dpinst-amd64.exe` и `dpinst-x86.exe`. Перед установкой драйвера подключите плату к компьютеру.

После установки IDE выполните следующие шаги для её конфигурации:

1. Прочитайте модель вашей платы. Для этого в главном меню IDE выберите пункт “Tools” ➤ ”Get Board Info” ("Инструменты" ➤ ”Информация о плате”). Проверьте, что в пункте меню “Tools” ➤ ”Board:...” ("Инструменты" ➤ ”Плата:...”) модель указана правильно.

2. Укажите порт подключения платы в пункте главного меню “Tools”➤“Port:...” ("Инструменты" ➤ ”Порт:...”).

Теперь Arduino IDE настроена и готова к работе.

Программа, которую мы напишем для Arduino платы, будет эмулировать устройство ввода. Со стороны компьютера ей будет управлять бот кликер, написанный на языке AutoIt. Для этого взаимодействия понадобится набор скриптов [**CommAPI**](https://www.autoitscript.com/wiki/CommAPI).

## Эмуляция клавиатуры

Есть два варианта реализации бота, использующего эмулятор устройства ввода.

В первом случае все алгоритмы бота реализуются в программе, работающей на плате Arduino. После её загрузки на устройство, всё готово к работе. Бот запускается автоматически, как только вы подключаете плату к компьютеру через USB. Такая архитектура лучше всего подходит для "слепых" ботов, которые нажимают кнопки, не проверяя состояние игровых объектов. К сожалению, программа, запущенная на Arduino не имеет доступа к WinAPI интерфейсу. Следовательно, она не сможет прочитать данные из процесса игрового приложения или устройства вывода.

Если ваш бот должен реагировать на игровые события, следует выбрать второй вариант реализации. В этом случае его алгоритмы запускаются и работают на компьютере. Программа платы Arduino отвечает только за симуляцию событий устройства ввода (например нажатие клавиши). В такой схеме бот имеет полный доступ к WinAPI и может читать состояние игровых объектов. После принятия решения, он отправляет команду плате Arduino на выполнение требуемого действия.

Мы рассмотрим пример второго варианта реализации бота. Он более надёжен в работе и универсален.

Протокол взаимодействия платы и бота может быть любым. Предлагаю остановиться на самом простом варианте и использовать [**UART интерфейс**](https://ru.wikipedia.org/wiki/Универсальный_асинхронный_приёмопередатчик) (Universal Asynchronous Receiver-Transmitter). Для его использования не нужны дополнительные расширения платы Arduino. Достаточно подключения по USB кабелю, через который мы загружаем программу на устройство.

Листинг 5-1 демонстрирует программу `keyboard.ino` для платы Arduino, которая симулирует события клавиатуры. Код клавиши, которую требуется нажать, передаётся по UART нтерфейсу.

**Листинг 5-1.** *Программа `keyboard.ino`*
```С++
#include <Keyboard.h>

void setup()
{
  Serial.begin(9600);
  Keyboard.begin();
}

void loop()
{
  if (Serial.available() > 0)
  {
    int incomingByte = Serial.read();
    Keyboard.write(incomingByte);
  }
}
```
Здесь мы используем библиотеку `Keyboard`, которую предоставляет Arduino IDE. Она позволяет генерировать события нажатия клавиш. Подключенный по USB компьютер получает их через [**HID**](https://en.wikipedia.org/wiki/Human_interface_device) (Human Interface Device) интерфейс. Этот интерфейс является стандартом для устройств ввода, использующих USB подключение.

В первой строке программы мы включаем заголовок `Keyboard.h`. В нём создаётся глобальный объект `Keyboard` класса `Keyboard_`. Все возможности библиотеки доступны через его методы.

В нашей программе всего две функции: `setup` и `loop`. В любом C++ приложении обязательно должна быть функция `main`. Она добавляется IDE во времени компиляции. В сгенерированной `main` всего два действия: однократный вызов `setup` и цикличный вызов `loop`. [**Прототипы**](https://ru.wikipedia.org/wiki/Прототип_функции) этих функций предопределены, и поменять их нельзя.

Кроме `Keyboard` мы используем глобальный объект `Serial`. Он предоставляет доступ к интерфейсу UART. Для инициализации объектов в функции `setup` вызываются методы `begin`. Этот метод для `Serial` принимает входным параметром [скорость передачи данных](https://ru.wikipedia.org/wiki/Скорость_передачи_данных) между компьютером и платой, которая в нашем случае равна 9600 бит/c. У метода `begin` объекта `Keyboard` нет входных параметров. Сразу после его вызова плата начинает эмулировать клавиатуру.

После выполнения функции `setup` Arduino плата готова принимать команды по UART интерфейсу и симулировать нажатия соответствующих клавиш. За это отвечает код функции `loop`. Её алгоритм состоит из трёх шагов:

1. С помощью метода `available` объекта `Serial` проверить, были ли получены данные по UART интерфейсу. Метод возвращает количество принятых байт. Если это значение больше нуля, значит передача была.

2. Прочитать первый байт полученных по UART данных с помощью метода `read` объекта `Serial`. Байт интерпретируется как ASCII код клавиши, нажатие которой следует симулировать.

3. Симулировать нажатие клавиши через HID интерфейс с помощью метода `write` объекта `Keyboard`. Подключённые по USB компьютер обработает его как событие обычной клавиатуры.

Чтобы скомпилировать программу `keyboard.ino` и загрузить её на Arduino плату, нажмите комбинацию клавиш Ctrl+U.

Мы подготовили плату. Теперь разработаем AutoIt скрипт, который будет ей управлять. Он должен посылать через UART интерфейс ASCII коды клавиш. Функции работы с UART доступны через WinAPI интерфейс. Обёртки CommAPI могут значительно упростить доступ к этим функциям из языка AutoIt. Скачайте и скопируйте их в каталог вашего скрипта. Проверьте, что у вас есть все необходимые файлы:

* `CommAPI.au3`
* `CommAPIConstants.au3`
* `CommAPIHelper.au3`
* `CommInterface.au3`
* `CommUtilities.au3`

Листинг 5-2 демонстрирует использорвание обёрток CommAPI. Приведённый в нём скрипт печатает строку "Hello world!" в окне Notepad с помощью эмулятора устройства ввода.

**Листинг 5-2.** *Скрипт `ControlKeyboard.au3`*
```AutoIt
#include "CommInterface.au3"

func ShowError()
	MsgBox(16, "Error", "Error " & @error)
endfunc

func OpenPort()
	local const $iPort = 7
	local const $iBaud = 9600
	local const $iParity = 0
	local const $iByteSize = 8
	local const $iStopBits = 1

	$hPort = _CommAPI_OpenCOMPort($iPort, $iBaud, $iParity, $iByteSize, $iStopBits)
	if @error then
		ShowError()
		return NULL
	endif

	_CommAPI_ClearCommError($hPort)
	if @error then
		ShowError()
		return NULL
	endif

	_CommAPI_PurgeComm($hPort)
	if @error then
		ShowError()
		return NULL
	endif

	return $hPort
endfunc

func SendArduino($hPort, $command)
	_CommAPI_TransmitString($hPort, $command)
	if @error then ShowError()
endfunc

func ClosePort($hPort)
	_CommAPI_ClosePort($hPort)
	if @error then ShowError()
endfunc

$hWnd = WinGetHandle("[CLASS:Notepad]")
WinActivate($hWnd)
Sleep(200)

$hPort = OpenPort()

SendArduino($hPort, "Hello world!")

ClosePort($hPort)
```
Общий алгоритм скрипта состоит из следующих шагов:

1. Переключиться на окно Notepad с помощью функции AutoIt `WinActivate`.

2. Установить [**последовательное соединение**](https://ru.wikipedia.org/wiki/Последовательное_соединение_(информатика)) (serial communication) с платой Arduino, используя функцию `OpenPort`.

3. Отправить команду набора строки "Hello world!" на плату с помощью функции `SendArduino`.

4. Закрыть последовательное соединение функцией `ClosePort`.

Рассмотрим подробнее работу пользовательскх функций `OpenPort`, `SendArduino` и `ClosePort`.

Функция `OpenPort` устанавливает соединение и подготавливает плату Arduino к взаимодействию. Она возвращает дескриптор соединения. В ней происходят следующие вызовы CommAPI:

1. `_CommAPI_OpenCOMPort` устанавливает последовательное соединение с указанными параметрами. Из них `iParity`, `iByteSize` и `iStopBits` одинаковы для Arduino плат всех моделей. Параметр `iBaud` задаёт скорость передачи данных. Она должна соответствовать скорости, переданной в метод `begin` объекта `Serial` в программе платы. Параметр `iPort` равен номеру [**последовательного порта**](https://ru.wikipedia.org/wiki/Последовательный_порт) (COM порта), через который плата подключена к компьютеру. На самом деле подключение происходит по USB, а COM порт эмулируется. Уточнить номер порта можно в пункте меню “Tools” ➤ “Port:...” (“Инструменты” ➤ “Порт:...”) Arduino IDE. Например, если там указан COM7 , параметр `iPort` должен быть равен 7.

2. `_CommAPI_ClearCommError` возвращает код ошибки при передаче данных. Через второй необязательный параметр функции возвращается текущее состояние подключённого устройства. В нашем случае он не используется. Функция вызывается для сброса флага ошибки на стороне устройства. Это действие очень важно, поскольку передача данных будет заблокирована до тех пор, пока флаг ошибки взведён.

3. `_CommAPI_PurgeComm` отменяет все текущие операции по передаче данных, а также очищает входной и выходной буферы подключённого устройства. После завершения работы этой функции Arduino готова принимать команды по UART.

Функция `SendArduino` представляет собой обёртку над вызовом `_CommAPI_TransmitString`, который передаёт указанную строку по UART интерфейсу.

Функция `ClosePort` закрывает соединение по указанному дескриптору.

Вспомогательная функция `ShowError` нужна для отладки. Она выводит сообщение с кодом ошибки, которая может произойти на любом этапе установки соединения.

Чтобы протестировать скрипт, выполните следующие действия:

1. Подключите Arduino плату с прошитой программой `keyboard.ino` к компьютеру с помощью USB кабеля.

2. Запустите приложение Notepad.

3. Запустите скрипт `ControlKeyboard.au3`.

В результате в окне Notepad будет набран текст "Hello world!".

## Сочетание клавиш

Разработанная нами программа `keyboard.ino` успешно справляется с симуляцией нажатия одной клавиши за раз. Однако, в некоторых играх может понадобится симулировать [**сочетание клавиш**](https://ru.wikipedia.org/wiki/Сочетание_клавиш), например Ctrl+Z.

Листинг 5-3 демонстрирует усовершенствованную версию программы.

**Листинг 5-3.** *Программа `keyboard-combo.ino`*
```С++
#include <Keyboard.h>

void setup()
{
  Serial.begin(9600);
  Keyboard.begin();
}

void pressKey(char modifier, char key)
{
  Keyboard.press(modifier);
  Keyboard.write(key);
  Keyboard.release(modifier);
}

void loop()
{
  static const char PREAMBLE = 0xDC;
  static const uint8_t BUFFER_SIZE = 3;

  if (Serial.available() > 0)
  {
    char buffer[BUFFER_SIZE] = {0};
    uint8_t readBytes = Serial.readBytes(buffer, BUFFER_SIZE);

    if (readBytes != BUFFER_SIZE)
      return;

    if (buffer[0] != PREAMBLE)
      return;

     pressKey(buffer[1], buffer[2]);
  }
}
```
В новой программе появилась новая функция `pressKey`. Кроме этого, алгоритм `loop` стал сложнее. Теперь мы получаем не один байт с ASCII кодом клавиши, нажатие которой следует симулировать. Управляющий скрипт должен отправить нам команду, состоящую из трёх байт. Её формат выглядит следующим образом:

1. Байт [**преамбулы**](https://ru.wikipedia.org/wiki/Преамбула_(значения)) - это предопределённое значение, которое сигнализирует о начале команды.

2. Код [**клавиши-модификатора**](https://ru.wikipedia.org/wiki/Клавиша-модификатор), которая должна быть нажата в сочетании с основной.

3. Код основной клавиши.

По-сути мы разработали простейший протокол для передачи двух байт информации по UART интерфейсу. Сейчас он поддерживает сочетания только из двух клавиш. Но его можно легко расширить, чтобы передавались две клавиши-модификатора вместо одной.

Можно ли обойтись без первого байта преамбулы в нашем протоколе? Ведь его передача - это накладные расходы. Преамбула решает проблему, когда приём данных по какой-то причине начинается с середины команды, а не начала. Возможна ли такая ситуация в нашем случае? Если к моменту запуска скрипта Arduino плата подключена к компьютеру, этого не произойдёт. Каждая команда управляющего скрипта будет принята и обработана. Однако, если программа на плате по какой-то причине перезагрузится, управляющий скрипт об этом не узнает. Он будет продолжать посылать данные и ожидать, что их обработают. Когда плата запустится снова и начнёт приём данных, скрипт может уже передавать команду. В этом случае возможно, что получен будет только последний байт. Потеря одной команды - это не критичная проблема. Но из-за случившегося сдвига, программа платы будет интерпретировать все последующие входящие команды неверно. Последний байт текущей команды будет "склеен" с первыми двумя байтам следующей и так далее. Таким образом плата окажется неработоспособной. Преамбула и её проверка гарантирует, что такая ситуация не возникнет.

Рассмотрим пример команды для симуляции нажатия Alt+Tab. Управляющий скрипт отправит три байта:
```
0xDC 0x82 0xB3
```
Первый из них (0xDC) - это преамбула. Дальше идёт код клавиши-модификатора 0x82, который соответствует Alt. Последний байт 0xB3 - это код клавиши Tab.

Чтобы прочитать команду в функции `loop`, мы используем метод `readBytes` объекта `Serial` вместо `read`. Он возвращает количество принятых байт. Первый параметр метода - массив, куда они будут сохранены. Второй параметр - максимальный размер этого массива.