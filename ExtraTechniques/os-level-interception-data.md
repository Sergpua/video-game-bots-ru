# Перехват данных на уровне ОС

В третьей главе мы рассмотрели методы чтения состояний игровых объектов из памяти процесса игрового приложения. Хорошо продуманная защита может значительно усложнить использование этих методов. В этом случае имеет смысл попробовать альтернативный подход. Подмена или модификация системных библиотек ОС позволит вам изменить точку перехвата данных. Вместо чтения памяти процесса, информацию об игровых объектах будут предоставлять динамические библиотеки, которые не контролируются защитой.

## Инструменты для разработки

Нам предстоит работа с WinAPI функциями и системными библиотеками. Лучшим языком для этой задачи является C++. Для компиляции примеров воспользуемся Visual Studio IDE. Инструкцию по её установке вы можете найти в третьей главе.

Есть несколько решений с открытым исходным кодом для перехвата вызовов WinAPI. Первое из них называется [**DLL Wrapper Generator**](https://m4v3n.wordpress.com/2012/08/08/dll-wrapper-generator) (генератор обёрток DLL). Мы будем использовать его, чтобы создавать обёртки для системных библиотек.

Для установки генератора выполните следующие шаги:

1. Скачайте архив со скриптами со [страницы проекта на Github](https://github.com/mavenlin/Dll_Wrapper_Gen/archive/master.zip).

2. Скачайте и установите [Python версии 2.7](http://www.python.org/downloads).

Второе решение, которым мы воспользуемся, называется [**Deviare**](http://www.nektra.com/products/deviare-api-hook-windows). Это [**фреймворк**](https://ru.wikipedia.org/wiki/Фреймворк) для перехвата вызовов DLL библиотек.

Для установке Deviare выполните следующее:

1. Скачайте [архив](http://github.com/nektra/Deviare2/releases/download/v2.8.0/Deviare.2.8.0.zip) с уже собранным в исполняемые файлы фреймворком.

2. Скачайте [архив](http://github.com/nektra/Deviare2/archive/v2.8.0.zip) с исходным кодом той же версии.

3. Распакуйте оба архива в разные каталоги.

Список сборок Deviare доступен на [Github странице проекта](http://github.com/nektra/Deviare2/releases). Ещё раз проверьте, что версии скачанной сборки и исходного кода совпадают.

## Тестовое приложение

Нам понадобится тестовое приложение, чтобы протестировать методы перехвата WinAPI вызовов. Предлагаю воспользоваться приложением, которое мы использовали в разделе "Методы защиты от внутриигровых ботов" третьей главы.

Немного изменённая версия исходного кода приложения приведена в листинге 5-9.

**Листинг 5-9.** *Исходный код тестового приложения*
```C++
#include <stdio.h>
#include <stdint.h>
#include <windows.h>
#include <string>

static const uint16_t MAX_LIFE = 20;
volatile uint16_t gLife = MAX_LIFE;

int main()
{
    SHORT result = 0;

    while (gLife > 0)
    {
        result = GetAsyncKeyState(0x31);
        if (result != 0xFFFF8001)
            --gLife;
        else
            ++gLife;

        std::string str(gLife, '#');
        TextOutA(GetDC(NULL), 0, 0, str.c_str(), str.size());

        printf("life = %u\n", gLife);
        Sleep(1000);
    }
    printf("stop\n");
    return 0;
}
```
Алгоритм работы приложения не изменился. Каждую секунду значение глобальной переменной `gLife` уменьшается на единицу, если клавиша "1" не была нажата. Если же была, `gLife` увеличивается на единицу. Теперь вместо вывода на консоль с помощью функции `printf`, мы делаем WinAPI вызов `TextOutA`. Он печатает строку, переданную в качестве входного параметра, в левом верхнем углу экрана. Строка состоит из символов решетки, число которых соответствует значению переменной `gLife`.

Зачем мы изменили функцию вывода информации? Наша цель заключается в перехвате WinAPI вызовов. Функция `printf` предоставляется на WinAPI, а [**библиотекой времени выполнения**](https://ru.wikipedia.org/wiki/Библиотека_среды_выполнения) языка C. В этой библиотеке реализованы низкоуровневые функции, описанные в стандарте языка. Доступ к ним возможен как из приложений, написанных на C, так и C++. После замены `printf` на `TextOutA` мы можем перехватить этот вызов. Прочитав переданные в него параметры, мы узнаем значение переменной `gLife`.

Согласно документации WinAPI, функция `TextOutA` реализована в системной библиотеке `gdi32.dll`. Эта информация пригодится нам в дальнейшем.

## Загрузка DLL библиотек

Мы собираемся рассмотреть техники перехвата WinAPI вызовов. Перед этим было бы полезно узнать, как приложение взаимодействуют с DLL библиотеками, к которым относятся и системные.

Когда мы запускаем приложение, [**загрузчик программ Windows**](https://ru.wikipedia.org/wiki/Загрузчик_программ) (PE-загрузчик) читает содержимое исполняемого файла в оперативную память. Стандартным форматом таких файлов в Windows является [**PE**](https://ru.wikipedia.org/wiki/Portable_Executable). Он определяет структуру данных, которая хранится в начале файла и содержит всю необходимую информацию для запуска его кода. Список используемых DLL библиотек является частью этой информации.

Следующий шаг PE-загрузчика