# Перехват данных на уровне ОС

В третьей главе мы рассмотрели методы чтения состояний игровых объектов из памяти процесса игрового приложения. Хорошо продуманная защита может значительно усложнить использование этих методов. В этом случае имеет смысл попробовать альтернативный подход. Подмена или модификация системных библиотек ОС позволит вам изменить точку перехвата данных. Вместо чтения памяти процесса, информацию об игровых объектах будут предоставлять динамические библиотеки, которые не контролируются защитой.

## Инструменты для разработки

Нам предстоит работа с WinAPI функциями и системными библиотеками. Лучшим языком для этой задачи является C++. Для компиляции примеров воспользуемся Visual Studio IDE. Инструкцию по её установке вы можете найти в третьей главе.

Есть несколько решений с открытым исходным кодом для перехвата вызовов WinAPI. Первое из них называется [**DLL Wrapper Generator**](https://m4v3n.wordpress.com/2012/08/08/dll-wrapper-generator) (генератор обёрток DLL). Мы будем использовать его, чтобы создавать обёртки для системных библиотек.

Для установки генератора выполните следующие шаги:

1. Скачайте архив со скриптами со [страницы проекта на Github](https://github.com/mavenlin/Dll_Wrapper_Gen/archive/master.zip).

2. Скачайте и установите [Python версии 2.7](http://www.python.org/downloads).

Второе решение, которым мы воспользуемся, называется [**Deviare**](http://www.nektra.com/products/deviare-api-hook-windows). Это [**фреймворк**](https://ru.wikipedia.org/wiki/Фреймворк) для перехвата вызовов DLL библиотек.

Для установке Deviare выполните следующее:

1. Скачайте [архив](http://github.com/nektra/Deviare2/releases/download/v2.8.0/Deviare.2.8.0.zip) с уже собранным в исполняемые файлы фреймворком.

2. Скачайте [архив](http://github.com/nektra/Deviare2/archive/v2.8.0.zip) с исходным кодом той же версии.

3. Распакуйте оба архива в разные каталоги.

Список сборок Deviare доступен на [Github странице проекта](http://github.com/nektra/Deviare2/releases). Ещё раз проверьте, что версии скачанной сборки и исходного кода совпадают.

## Тестовое приложение

Нам понадобится тестовое приложение, чтобы протестировать методы перехвата WinAPI вызовов. Предлагаю воспользоваться приложением, которое мы использовали в разделе "Методы защиты от внутриигровых ботов" третьей главы.

Немного изменённая версия исходного кода приложения приведена в листинге 5-9.

**Листинг 5-9.** *Исходный код тестового приложения*
```C++
#include <stdio.h>
#include <stdint.h>
#include <windows.h>
#include <string>

static const uint16_t MAX_LIFE = 20;
volatile uint16_t gLife = MAX_LIFE;

int main()
{
    SHORT result = 0;

    while (gLife > 0)
    {
        result = GetAsyncKeyState(0x31);
        if (result != 0xFFFF8001)
            --gLife;
        else
            ++gLife;

        std::string str(gLife, '#');
        TextOutA(GetDC(NULL), 0, 0, str.c_str(), str.size());

        printf("life = %u\n", gLife);
        Sleep(1000);
    }
    printf("stop\n");
    return 0;
}
```
Алгоритм работы приложения не изменился. Каждую секунду значение глобальной переменной `gLife` уменьшается на единицу, если клавиша "1" не была нажата. Если же была, `gLife` увеличивается на единицу. Теперь вместо вывода на консоль с помощью функции `printf`, мы делаем WinAPI вызов `TextOutA`. Он печатает строку, переданную в качестве входного параметра, в левом верхнем углу экрана. Строка состоит из символов решетки, число которых соответствует значению переменной `gLife`.

Зачем мы изменили функцию вывода информации? Наша цель заключается в перехвате WinAPI вызовов. Функция `printf` предоставляется на WinAPI, а [**библиотекой времени выполнения**](https://ru.wikipedia.org/wiki/Библиотека_среды_выполнения) языка C. В этой библиотеке реализованы низкоуровневые функции, описанные в стандарте языка. Доступ к ним возможен как из приложений, написанных на C, так и C++. После замены `printf` на `TextOutA` мы можем перехватить этот вызов. Прочитав переданные в него параметры, мы узнаем значение переменной `gLife`.

Согласно документации WinAPI, функция `TextOutA` реализована в системной библиотеке `gdi32.dll`. Эта информация пригодится нам в дальнейшем.

## Загрузка DLL библиотек

Мы собираемся рассмотреть техники перехвата WinAPI вызовов. Перед этим было бы полезно узнать, как приложение взаимодействуют с DLL библиотеками, к которым относятся и системные.

Когда мы запускаем приложение, [**загрузчик программ Windows**](https://ru.wikipedia.org/wiki/Загрузчик_программ) (PE-загрузчик) читает содержимое исполняемого файла в оперативную память. Точнее в область памяти нового процесса. Загруженный код называется **EXE модулем**. Стандартным форматом исполняемых файлов в Windows является [**PE**](https://ru.wikipedia.org/wiki/Portable_Executable). Он определяет структуру данных (известную как **PE-заголовок**), которая хранится в начале файла и содержит всю необходимую информацию для запуска его кода. Список используемых DLL библиотек является частью этой информации.

На следующем шаге PE-загрузчик ищет файлы необходимых DLL библиотек на жёстком диске. Их содержимое читается с диска и записывается в память процесса запускаемого приложения. Загруженный код библиотеки называется **DLL модулем**. Было бы логично размещать DLL модули по одним и тем же адресам на каждом запуске приложения. К сожалению, всё не так просто. Эти адреса выбираются случайно механизмом Windows под названием [**Address Space Load Randomization**](https://blogs.msdn.microsoft.com/winsdk/2009/11/30/how-to-disable-address-space-layout-randomization-aslr) (ASLR). Он защищает ОС от некоторых видов вредоносного ПО. Минус такого подхода в том, что компилятор не может использовать статические адреса для вызова функций библиотеки из EXE модуля.

Проблема решается с помощью [**Import Table**](http://sandsprite.com/CodeStuff/Understanding_imports.html) (таблица импорта). Кроме неё есть так называемая **Thunk Table** (таблица переходов). Эти таблицы часто путают. Рассмотрим, чем же они отличаются.

Import Table представляет собой массив структур типа `IMAGE_IMPORT_DESCRIPTOR`: 
```C++
typedef struct _IMAGE_IMPORT_DESCRIPTOR {
    DWORD   OriginalFirstThunk;
    DWORD   TimeDateStamp;
    DWORD   ForwarderChain;
    DWORD   Name;
    DWORD   FirstThunk;
} IMAGE_IMPORT_DESCRIPTOR, *PIMAGE_IMPORT_DESCRIPTOR;
```
Каждая такая структура соответствует одной DLL библиотеке. В поле `Name` хранится имя её файла. Число `OriginalFirstThunk` на самом деле является указателем на первый элемент массива структур типа `IMAGE_THUNK_DATA`:
```C++
typedef struct _IMAGE_IMPORT_BY_NAME {
    WORD    Hint;
    BYTE    Name[1];
} IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;

typedef struct _IMAGE_THUNK_DATA {
    union {
        PDWORD                 Function;
        PIMAGE_IMPORT_BY_NAME  AddressOfData;
    } u1;
} IMAGE_THUNK_DATA, *PIMAGE_THUNK_DATA;
```
Ключевое слово `union` в определении `IMAGE_THUNK_DATA` говорит о том, что данные могут интерпретироваться двумя способами. Во-первых, как указатель типа `PDWORD` на функцию в памяти запущенного процесса. Во-вторых, как указатель на структуру типа `IMAGE_IMPORT_BY_NAME`, которая содержит порядковый номер функции в библиотеке и её символьное имя.

Поле `FirstThunk` структуры `IMAGE_IMPORT_DESCRIPTOR` указывает на первый элемента массива, известного как **Import Address Table** (IAT). Это таблица импорта адресов. PE-загрузчик перезаписывает её адресами функций из соответствующей загруженной DLL библиотеки. Более подробно структура Import Table описана в [русской](https://rsdn.org/article/baseserv/peloader.xml#EVH) и [английской](https://web.archive.org/web/20180616013724/http://www.ntcore.com/files/inject2it.htm#IntoImportTable1) статьях.

Import Table является частью PE-заголовка. Она содержит общую информацию о загружаемых DLL библиотеках. Всё содержимое PE-заголовка загружается в сегмент памяти процесса с правами только на чтение. Thunk Table является частью исполняемого кода. Она содержит переходы (**thunk**) на импортируемые функции, которые представляют собой ассемблерные `JMP` инструкции. Thunk Table загружается в `.text` сегмент с правами на чтение и исполнение. В этом сегменте также хранится исполняемый код приложения. Import Address Table, на которую указывает `FirstThunk` элементов Import Table, помещается в сегмент `.idata` с правами только на чтение.

Некоторые компиляторы генерируют код, который не использует Thunk Table. Благодаря этому удаётся избежать накладных расходов, связанных с дополнительным `JMP` переходом. Код сгенерированный MinGW компилятором использует Thunk Table. Схема вызова импортируемой функции `TextOutA` приведена на иллюстрации 5-1.

![Вызов функции из MinGW кода](dll-call-mingw.png)

**Иллюстрация 5-1.** *Вызов функции `TextOutA` из приложения, скомпилированного MinGW*

Алгоритм вызова выглядит следующим образом:

1. Процессор выполняет инструкцию ассемблера `CALL 40839C`. Она выполняет вызов функции. При этом адрес возврата из неё помещается в стек, а управление передаётся элементу Thunk Table по адресу 40839C.

2. Элемент Thunk Table содержит единственную инструкцию `JMP`. Она выполняет безусловный переход на функцию `TextOutA` DLL модуля gdi32, загруженном в память исполняемого процесса. Линейный адрес функции извлекается из Import Address Table. Для доступа к ней используется регистр DS, указывающий на сегмент `.idata`. Для расчёт адреса элемента Import Address Table используется сдвиг (в нашем случае равный 0x278):
```
DS + 0x278 = 0x422000 + 0x278 = 0x422278
```

3. Процессор выполняет код `TextOutA`. Последняя инструкция функции — это `RETN`. Она извлекает адрес возврата из стека и выполняет переход на инструкцию следующую сразу за `CALL` в EXE модуле, откуда начинался вызов.

Компилятор Visual C++ генерирует код, который не использует Thunk Table. Схема вызова функции `TextOutA` в этом случае выглядит как на иллюстрации 5-2. Алгоритм вызова состоит из двух шагов:

1. Процессор выполняет инструкцию ассемблера `CALL DWORD PTR DS:[0x10C]`. В ней происходит чтение линейного адреса функции из Import Address Table. Затем на стек помещается адрес возврата. После этого управление передаётся в функцию `TextOutA` DLL модуля gdi32.

2. Процессор выполняет код `TextOutA`. Возврат из неё в EXE модуль происходит по `RETN` инструкции.

![Вызов функции из Visual C++ кода](dll-call-visual-cpp.png)

**Иллюстрация 5-2.** *Вызов функции `TextOutA` из приложения, скомпилированного Visual C++*

## Техники перехвата WinAPI вызовов

Игровые приложения взаимодействуют с ОС и её ресурсами через системные DLL библиотеки. Например, чтобы вывести на экран текст, вызывается функция `TextOutA` или аналогичная. Если мы перехватим этот вызов, мы будем знать текст, который приложение пытается вывести. Такой подход чем-то напоминает перехват данных устройства вывода. Только в данном случае мы получаем эти данные до того, как они будут отображены на экране.

Инструмент API Monitor, который мы использовали во второй главе, хорошо демонстрирует принцип перехвата WinAPI вызовов. Результат перехвата выводится в окне "Summary" приложения. Мы можем реализовать бота, который будет вести себя как API Monitor. Но вместо вывода перехваченных вызовов, он будет симулировать действия игрока.

Рассмотрим на примерах самые часто используемые техники перехвата вызовов.

### Proxy DLL

Первая техника заключается в подмене системной библиотеке Windows. Мы могли бы подготовить DLL библиотеку, которая выглядит как оригинальная с точки зрения PE-загрузчика и игрового приложения. В этом случае она будет загружена в память процесса приложения. Игра будет взаимодействовать с подложной библиотекой точно также, как если бы это была системная. Благодаря этому наш код будет получать управление при каждом вызове функции из неё. Подложная библиотека называется **proxy DLL**.

В большинстве случаев надо перехватить только несколько определённых WinAPI вызовов. Все остальные функции замещаемой системной библиотеки нам не интересны и должны работать как обычно. Кроме того при подмене системных библиотек помните важное правило: процесс должен вести себя с proxy DLL точно так же, как и с системной библиотекой. В противном случае нельзя гарантировать его корректную работу. Эти два обстоятельства наводят на мысль, что proxy DLL должна уметь перенаправлять в системную библиотеку все вызовы приложения.

Когда процесс игрового приложения вызывает функцию proxy DLL, наш код получает управление. Он может симулировать действия игрока или просто читать для бота состояние игровых объектов. После этого обязательно надо передать управление WinAPI функции, выполнение которой ожидает приложение. В противном случае оно просто завершится с ошибкой или продолжит работу в неконсистентном состоянии (его данные окажутся несогласованы).

Итак, если мы не собираемся перехватывать какую-то WinAPI функцию, мы просто перенаправляем вызов в системную библиотеку. Если же мы перехватываем вызов, сначала отрабатывает наш код, а потом опять управление передаётся в системную библиотеку. Это означает, что она должна быть загружена в адресное пространство. В противном случае код оригинальных WinAPI функций будет недоступен. Очевидно, что PE-загрузчик ничего не знает про оригинальную библиотеку. Он загрузил proxy DLL, и на этом его работа выполнена. Оригинальную библиотеку загружать proxy DLL с помощью WinAPI функции `LoadLibrary`.

Иллюстрация 5-3 демонстрирует схему вызова WinAPI функции `TextOutA` через proxy DLL в случае компиляции приложения Visual C++.

![Вызов функции через proxy DLL](proxy-dll.png)

**Иллюстрация 5-3.** *Вызов функции `TextOutA` через proxy DLL*

Алгоритм вызова функции следующий:

1. PE-загрузчик загружает proxy DLL вместо системной библиотеки `gdi32.dll`. При этом он зхаписывает линейный адрес всех функций, экспортируемыъ proxy DLL, В Import Address Table модуля EXE.

2. Исполнение кода модуля EXE достигает точки вызова функции `TextOutA`. Дальше отрабатывает стандартный алгоритм вызова функции из импортируемой DLL. Инструкция `CALL` сохраняет адрес возврата на стеке и передаёт управление по адресу из Import Address Table. Единственное отличие в том, что теперь управление передаётся не в системную библиотеку, а в замещающую proxy DLL.

3. В proxy DLL есть Thunk Table, элемент которой получает управление от `CALL` инструкции EXE модуля. Именно линейные адреса элементов Thunk Table записываются загрузчиком в Import Address Table модуля EXE.

4. Инструкция `JMP` элемента Thunk Table выполняет безусловный переход в обёртку для функции `TextOutA`, которая реализована в proxy DLL. В ней выполняется код бота.

5. В конце кода обёртки находится инструкция `CALL`, которая сохраняет на стеке адрес возврата и передаёт управление оригинальной функции `TextOutA` из DLL модуля gdi32.

6. После отработки оригинальной функции `TextOutA`, она возвращает управление в обёртку proxy DLL через инструкцию `RETN`.

7. Инструкция `RETN` в обёртке возвращает управление обратно в EXE модуль.

Может возникнуть вопрос: как proxy DLL узнаёт линейные адреса функций, которые экспортируются системной библиотекой gdi32? В обычной ситуации эти адреса читаются PE-загрузчиком. Но сейчас мы не можем его задействовать, ведь он загружает только proxy DLL. Опять же эта задача должна выполняться proxy DLL самостоятельно. WinAPI функция `GetProcAddress` возвращает линейный адрес функции из указанного модуля по её имени или порядковому номеру.

Ещё один момент остаётся неясным. Что нужно сделать, чтобы PE-загрузчик выбрал proxy DLL вместо системной? У Windows есть механизм поиска динамических библиотек. Пути всех системных DLL хранятся в реестре и только по ним происходит поиск. Мы не можем просто подменить системную библиотеку в каталоге `Windows`. Скоре всего её спользуют многие сервисы и службы ОС. Велика вероятность, что система окажется неработоспособной после такой подмены. Кроме того оригинальная библиотека должна хранится в месте известном всем её клиентам. Ведь все вызовы proxy DLL должны перенаправлятся в неё. Правильное решение заключается в том, чтобы поместить proxy DLL в каталог приложения, вызовы которого мы собираемся перехватывать. Чтобы отключить механизм защиты Windows, надо отредактировать реестр.

Преимущества использования proxy DLL перед другими техниками перехвата WinAPI вызовов:

1. Сгенерировать proxy DLL с помощью существующих бесплатных утилит.

2. Подмена библиотеки происходит только для одного конкретного приложения. Все остальные системные сервисы и службы используют оригинальную DLL.

3. Защитить приложение от такого перехвата вызовов может быть сложно.

Недостатки подхода propxy DLL:

1. Некоторые системные библиотеки невозможно подменить (например `kernel32.dll`). Причина этого ограничения в том, что обе WinAPI функции `LoadLibrary` и `GetProcAddress` предоставляются `kernel32.dll`. Это значит, что они должны быть доступны в момент, когда proxy DLL загружает системную библиотеку.

2. Сложно сделать обёртки для некоторых WinAPI функций потому, что они не документированы.