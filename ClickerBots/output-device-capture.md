# Перехват устройств вывода

В этом разделе мы рассмотрим методы перехвата данных с устройств вывода. Сначала мы изучим возможности Windows для вывода изображений на экран, которыми пользуются игровые приложения. Затем рассмотрим способы доступа к этим изображениям.

## Интерфейс графических устройств Windows

**Интерфейс графических устройств** (Graphics Device Interface или GDI) - один из основных компонентов Windows, который отвечает за представление графических объектов и передачу их на устройства вывода. Обычно все элементы интерфейса окна приложения конструируются с использованием графических объектов, таких как **контекст устройства** (device context или DC), битовое изображение (bitmap), кисти, цвета, шрифты.

Ключевая концепция GDI - это контекст устройства. Он представляет собой абстракцию, благодаря которой разработчики могут единообразно работать с графическими объектами независимо от устройства вывода. Примеры таких устройств: монитор, принтер, плоттер (графопостроитель) и т.д. Сначала все операции по подготовке изображения выполняются над контекстом устройства в памяти. Затем готовый результат отправляется на устройство вывода.

На иллюстрации 2-7 изображены два контекста устройств, которые содержат изображения окон двух приложений. Так же есть DC, который соответствует итоговому изображению всего рабочего стола. ОС может получить это изображение путем комбинации всех видимых окон и визуальных элементов рабочего стола (например панели задач). Когда этот контекст устройства готов, ОС выводит его содержимое на экран.

![GDI](gdi-scheme.png)

**Иллюстрация 2-7.** *Отображение графических объектов на устройства вывода*

Предположим, вам нужно напечатать документ, открытый в текстовом редакторе. В этом случае ОС просто отправляет DC окна этого приложения на принтер. Контексты устройств, связанные с другими откртыми в данный момент окнами игнорируются.

Контекст устройства представляет собой структуру в памяти. Разработчики могу работать с ней только через WinAPI функции. Каждый DC содержит **аппаратно-зависимое битовое изображение** (Device Depended Bitmap или DDB). **Битовое изображение** - это представление поверхности для рисования в памяти. Все операции над графическими объектами в контексте устройства отражаются на соответствующем битовом изображении. Следовательно оно хранит результат всех этих операцй.

Битовое изображение состоит из массива битов, описывающих его элементы (известные как пиксели), и метаинформации. У каждого пикселя есть два параметра: координаты и цвет. Соответствие этих двух параметров задаётся двумерным массивом. Номера элементов массива (индексы) соответствуют координатам пикселя по осям X и Y. Числовое значение элемента массива соответствует коду цвета в палитре, которая сязана с данным битовым изображением. Для анализа изображения все элементы двумерного массива должны быть обработаны последовательно.

Когда изображение подготовлено в контексте устройства, оно передается на настоящее устройство вывода. Как правило, подпрограммы системных библиотек выполняют необходимые преобразования изображения. Например, библиотека `vga.dll` выполняет эти преобразования для вывода на экран. Блгодаря им, драйвер устройства получает картинку в удобном для него формате.

## Функции AutoIt для анализа изображений

AutoIt предоставляет несколько функций, которые упрощают анализ текущего изображения на экране. Все они оперируют объектами GDI. Сейчас мы подробно рассмотрим эти функции.

### Анализа отдельного пикселя

Самая простая задача по анализу изображения - это чтение цвета одного пикселя. Для этого необходимо указать его координаты. AutoIt поддерживает несколько режимов координат представленных в Таблице 2-2. Они соответствуют режимам координат позиционирования курсора мыши, которые мы рассмотрели в прошлом разделе.

**Таблица 2-1.** *Режимы координат функций анализа изображений AutoIt*
| Режим | Описание |
| -- | -- |
| 0 | Координаты относительно левой-верхней точки активного окна. |
| 1 | Абсолютные координаты экрана. Это режим по-умолчанию. |
| 2 | Координаты относительно левой-верхней точки клиентской части окна (без заголовка, меню и границ). |

Выбрать нужный режим координат можно с помощью функции `Opt`, вызванной с первым параметром `PixelCoordMode`. Следующий вызов демонстрирует выбор второго режима:
```
Opt("PixelCoordMode", 2)
```
Простейшая функция AutoIt для чтения цвета пикселя - это `PixelGetColor`. Её входные параметры - это координаты пикселя по осям X и Y. Функция возвращает код цвета в **десятичной системе счисления**. Блок кода 2-10 демонстрирует её использование.

**Блок кода 2-10.** *Скрипт `PixelGetColor.au3`*
```AutoIt
$color = PixelGetColor(200, 200)
MsgBox(0, "", "Цвет пикселя " & Hex($color, 6))
```
Скрипт `PixelGetColor.au3` читает цвет пикселя с координатами x = 200, y = 200. После этого функция `MsgBox` выводи диалоговое окно с результатом. После запуска скрипта, вы увидете сообщение "Цвет пикселя 0355BB".

Код цвета 0355BB - это представление числа в **шестнадцатеричной системе счисления**. Функция `Hex` выполняет конвертирование результата вызова `PixelGetColor` из десятичной системы в шестнадцатеричную. Такое представление цвета повсеместно распространено и связано со способом кодирования RGB. Любой цвет представляется смесью трех основных: красный (Red), зелений (Green) и синий (Blue). Код можно представить набором из трех чисел. В нашем случае это: 03, 55 и BB. Каждое из них представляет интенсивность основного цвета в указаном ранее порядке (R, G, B). Большинство графических редакторов и утилит используют этот способ кодирования.

Если вы откроете окно Блокнота и перекроете им координату x = 200, y = 200 рабочего стола, результат возвращаемый скриптом `PixelGetColor.au3` изменится. Это означает, что он анализирует не конкретное окно, а весь рабочий стол.

