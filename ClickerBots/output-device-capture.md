# Перехват устройств вывода

В этом разделе мы рассмотрим методы перехвата данных с устройств вывода. Сначала мы изучим возможности Windows для вывода изображений на экран, которыми пользуются игровые приложения. Затем рассмотрим способы доступа к этим изображениям.

## Интерфейс графических устройств Windows

**Интерфейс графических устройств** (Graphics Device Interface или GDI) - один из основных компонентов Windows, который отвечает за представление графических объектов и передачу их на устройства вывода. Обычно все элементы интерфейса окна приложения конструируются с использованием графических объектов, таких как **контекст устройства** (device context или DC), битовое изображение (bitmap), кисти, цвета, шрифты.

Ключевая концепция GDI - это контекст устройства. Он представляет собой абстракцию, благодаря которой разработчики могут единообразно работать с графическими объектами независимо от устройства вывода. Примеры таких устройств: монитор, принтер, плоттер (графопостроитель) и т.д. Сначала все операции по подготовке изображения выполняются над контекстом устройства в памяти. Затем готовый результат отправляется на устройство вывода.

На иллюстрации 2-7 изображены два контекста устройств, которые содержат изображения окон двух приложений. Так же есть DC, который соответствует итоговому изображению всего рабочего стола. ОС может получить это изображение путем комбинации всех видимых окон и визуальных элементов рабочего стола (например панели задач). Когда этот контекст устройства готов, ОС выводит его содержимое на экран.

![GDI](gdi-scheme.png)

**Иллюстрация 2-7.** *Отображение графических объектов на устройства вывода*

Предположим, вам нужно напечатать документ, открытый в текстовом редакторе. В этом случае ОС просто отправляет DC окна этого приложения на принтер. Контексты устройств, связанные с другими откртыми в данный момент окнами игнорируются.

Контекст устройства представляет собой структуру в памяти. Разработчики могу работать с ней только через WinAPI функции. Каждый DC содержит **аппаратно-зависимое битовое изображение** (Device Depended Bitmap или DDB). **Битовое изображение** - это представление поверхности для рисования в памяти. Все операции над графическими объектами в контексте устройства отражаются на соответствующем битовом изображении. Следовательно оно хранит результат всех этих операцй.

Битовое изображение состоит из массива битов, описывающих его элементы (известные как пиксели), и метаинформации. У каждого пикселя есть два параметра: координаты и цвет. Соответствие этих двух параметров задаётся двумерным массивом. Номера элементов массива (индексы) соответствуют координатам пикселя по осям X и Y. Числовое значение элемента массива соответствует коду цвета в палитре, которая сязана с данным битовым изображением. Для анализа изображения все элементы двумерного массива должны быть обработаны последовательно.

Когда изображение подготовлено в контексте устройства, оно передается на настоящее устройство вывода. Как правило, подпрограммы системных библиотек выполняют необходимые преобразования изображения. Например, библиотека `vga.dll` выполняет эти преобразования для вывода на экран. Блгодаря им, драйвер устройства получает картинку в удобном для него формате.

## Функции AutoIt для анализа изображений

AutoIt предоставляет несколько функций, которые упрощают анализ текущего изображения на экране. Все они оперируют объектами GDI. Сейчас мы подробно рассмотрим эти функции.

### Анализ отдельного пикселя

Самая простая задача по анализу изображения - это чтение цвета одного пикселя. Для этого необходимо указать его координаты. AutoIt поддерживает несколько режимов координат представленных в Таблице 2-2. Они соответствуют режимам координат позиционирования курсора мыши, которые мы рассмотрели в прошлом разделе.

**Таблица 2-1.** *Режимы координат функций анализа изображений AutoIt*
| Режим | Описание |
| -- | -- |
| 0 | Координаты относительно левой-верхней точки активного окна. |
| 1 | Абсолютные координаты экрана. Это режим по-умолчанию. |
| 2 | Координаты относительно левой-верхней точки клиентской части окна (без заголовка, меню и границ). |

Выбрать нужный режим координат можно с помощью функции `Opt`, вызванной с первым параметром `PixelCoordMode`. Следующий вызов демонстрирует выбор второго режима:
```
Opt("PixelCoordMode", 2)
```
Простейшая функция AutoIt для чтения цвета пикселя - это `PixelGetColor`. Её входные параметры - это координаты пикселя по осям X и Y. Функция возвращает код цвета в **десятичной системе счисления**. Блок кода 2-10 демонстрирует её использование.

**Блок кода 2-10.** *Скрипт `PixelGetColor.au3`*
```AutoIt
$color = PixelGetColor(200, 200)
MsgBox(0, "", "Цвет пикселя: " & Hex($color, 6))
```
Скрипт `PixelGetColor.au3` читает цвет пикселя с координатами x = 200, y = 200. После этого функция `MsgBox` выводи диалоговое окно с результатом. После запуска скрипта, вы увидете сообщение "Цвет пикселя 0355BB".

Код цвета 0355BB - это представление числа в **шестнадцатеричной системе счисления**. Функция `Hex` выполняет конвертирование результата вызова `PixelGetColor` из десятичной системы в шестнадцатеричную. Такое представление цвета повсеместно распространено и связано со способом кодирования RGB. Любой цвет представляется смесью трех основных: красный (Red), зелений (Green) и синий (Blue). Код можно представить набором из трех чисел. В нашем случае это: 03, 55 и BB. Каждое из них представляет интенсивность основного цвета в указаном ранее порядке (R, G, B). Большинство графических редакторов и утилит используют этот способ кодирования.

Если вы откроете окно Блокнота и перекроете им координату x = 200, y = 200 рабочего стола, результат возвращаемый скриптом `PixelGetColor.au3` изменится. Это означает, что он анализирует не конкретное окно, а весь рабочий стол.

Иллюстрация 2-8 демонстрирует перехваченные WinAPI вызовы скрипта `PixelGetColor.au3`.

![WinAPI вызовы PixelGetColor](winapi-get-pixel.png)

**Иллюстрация 2-8.** *WinAPI вызовы скрипта `PixelGetColor.au3`*

Функция `PixelGetColor` вызывает внутри себя три WinAPI подпрограммы в следующей последовательности: `GetDC`, `GetPixel`, `ReleaseDC`. `GetDC` получает входным параметром значение "NULL". Таким образом мы выбираем контекст устройства всего экрана для дальнейших операций. Если мы передадим в функцию `GetDC` дескриптор окна, мы получим DC его клиентской области. Таким образом наш скрипт сможет анализировать неактивные или перекрытые окна.

Дескриптор окна можно передать третьим параметром в AutoIt функцию `PixelGetColor`. Блок кода 2-11 демонстрирует это решение.

**Блок кода 2-11.** *Скрипт `PixelGetColorWindow.au3`*
```AutoIt
$hWnd = WinGetHandle("[CLASS:MSPaintApp]")
$color = PixelGetColor(200, 200, $hWnd)
MsgBox(0, "", "Цвет пикселя: " & Hex($color, 6))
```
Скрипт `PixelGetColorWindow.au3` должен вернуть цвет пикселя в окне Paint, даже если оно неактивно. Мы ожидаем прочитать белый цвет с кодом “FFFFFF”, потому что область для рисования по-умолчанию пуста.

Скрипт работает корректно, если окно Paint активно. Теперь попробуем перекрыть его окном другого приложения (например интерпретатором командной строки CMD, которое имеет преимущественно чёрный цвет). Скрипт прочитает чёрный цвет вместо белого.

Сравним WinAPI вызовы скриптов `PixelGetColorWindow.au3` и `PixelGetColor.au3`, перехваченные с помощью приложения API Monitor. В обоих случаях подпрограмма `GetDC` получает "NULL" входным параметром. Такое поведение похоже на ошибку в реализации функции `PixelGetColor` версии 3.3.14.1 AutoIt. Возможно, она будет исправлена в следующий версиях. Попробуем обойти эту ошибку.

Проблема функции `PixelGetColor` в некорректном параметре при вызове `GetDC`. Мы знаем какие WinAPI подпрограммы вызывает `PixelGetColor`. Поэтому можем вызвать их напрямую из нашего скрипта, но с корректными параметрами. Результат приведен в блоке кода 2-12.

**Блок кода 2-12.** *Скрипт `GetPixel.au3`*
```AutoIt
#include <WinAPIGdi.au3>

$hWnd = WinGetHandle("[CLASS:MSPaintApp]")
$hDC = _WinAPI_GetDC($hWnd)
$color = _WinAPI_GetPixel($hDC, 200, 200)
MsgBox(0, "", "Цвет пикселя: " & Hex($color, 6))
```
Скрипт `GetPixel.au3` начинается с ключевого слова `include`. С его помощью мы включаем файл `WinAPIGdi.au3`, который содержит обертки `_WinAPI_GetDC` и `_WinAPI_GetPixel` для соответствующих WinAPI подпрограмм. Этот скрипт читает цвет пикселя окна Paint, независимо от того перекрыто оно или нет.

У рассмотренного нами решения есть одна проблема. Если вы свернете окно Paint и запустите скрипт, он вернет белый цвет. Этот результат выглядит корректным. Теперь попрбуем изменить цвет рабочей области Paint, залив её для примера красным цветом. Свернем окно снова и запустим скрипт. Он опять прочитает белый цвет, хотя мы ожидаем красный. Рассмотрим, почему это происходит.

У каждого окна есть клиентская область. В этой области находятся все элементы интерфейса кроме заголовка окна, его границ и главного меню. Наша проблема с чтением цвета пикселя возникла из-за того, что клиентская область свернутого окна имеет нулевой размер. Следовательно контекст устройства, связанный с окном, имеет пустое битовое изображение. При попытке чтения несуществующего пикселя, подпрограмма WinAPI `GetPixel` возвращает белый цвет.

Мы можем прочитать клиентскую область окна с помощью скрипта, представленного в блоке кода 2-13.

**Блок кода 2-13.** *Скрипт `GetClientRect.au3`*
```AutoIt
#include <WinAPI.au3>

$hWnd = WinGetHandle("[CLASS:MSPaintApp]")
$tRECT = _WinAPI_GetClientRect($hWnd)
MsgBox(0, "Прямоугольник", _
            "Левый край: " & DllStructGetData($tRECT, "Left") & @CRLF & _
            "Правый край: " & DllStructGetData($tRECT, "Right") & @CRLF & _
            "Верхний край: " & DllStructGetData($tRECT, "Top") & @CRLF & _
            "Нижний край: " & DllStructGetData($tRECT, "Bottom"))
```
Скрипт `GetClientRect.au3` выводит X и Y координаты верхней-левой и правой-нижней точки клиентской области окна Paint. Если оно свёрнуто, все координаты равны нулю. В противном случае, вы получите ненулевые числа.

Ограничение при работе со свёрнутым окном крайне неудобно, если вы планируете запускать бота и переключаться на другие приложения. У этой проблемы есть решение. Windows позволяет восстановить свернутое окно в прозрачном режиме. После этого можно скопировать битовое изображение клиентской области этого окна в DC, связанный с оперативной памятью, и свернуть его снова. Для копирования можно воспользоваться WinAPI подпрограммой `PrintWindow`. После этого мы можем анализорвать копию с помощью известной нам AutoIt обертки `_WinAPI_GetPixel`. 

Следующая статья подробно рассматривает описаный подход (www.codeproject.com/Articles/20651/Capturing-Minimized-Window-A-Kid-s-Trick).

### Анализ изменений картинки

Мы рассмотрели методы чтения цвета отдельно взятого пикселя. Однако, в большинстве случаев точные координаты нужного пикселя в окне игрового приложения неизвестны. Причина этого в том, что мы имеем не статическую картинку, а изображения движущихся игровых объектов. Следовательно мы должны найти способ анализа изменений на экране. AutoIt предоставляет несколько функций для этой цели.

Предположим, что мы ищем конкретный игровой объект на экране. Мы знаем его цвет, но не координаты. Эта задача является обратной той, которую решает функция AutoIt `PixelGetColor`. Для поиска координат игрового объекта по его цвету можно воспользоваться функцией `PixelSearch`. Её использование демонстрирует блок кода 2-14.

**Блок кода 2-14.** *Скрипт `PixelSearch.au3`*
```AutoIt
$coord = PixelSearch(0, 207, 1000, 600, 0x000000)
If @error = 0 then
    MsgBox(0, "", "Координата чёрной точки: x = " & $coord[0] & " y = " &
$coord[1])
else
    MsgBox(0, "", "Чёрная точка не найдена")
endif
```
Скрипт `PixelSearch.au3` ищет пиксель чёрного цвета с кодом 0x000000 в прямоугольной области экрана с координатами верхнего-левого угла x = 0, y = 207 и правого-нижнего - x = 1000, y = 600. Если в процессе поиска происходит ошибка, мы обрабатываем её с помощью **макроса** `@error`. В этом случае выводится сообщение об ошибке.

Макрос `@error` можно рассматривать, как глобальную переменную. Если в процессе работы AutoIt функции происходит ошибка, её код будет записан в `@error`. При обработке ошибки важно проверять макрос сразу после вызова функции, поскольку последующие вызовы могут перезаписать его значение.

Воспользуемся приложением Paint, чтобы протестировать скрипт `PixelSearch.au3`. Сначала поставим чёрную точку с помощью карандаша или кисти в области для рисования. Затем запустим скрипт. Он выведет в диалоговом окне координаты точки. Если этого не произошло, проверьте что Paint не перекрывают другие окна.

Проверим, какие WinAPI вызовы делает функция `PixelSearch`. Для этого запустим скрипт `PixelSearch.au3` из приложения API Monitor. Подождём пока он отработает. После этого будем искать текст "0, 207" в окне "Summary". Вы должны найти вызов WinAPI подпрограммы `StretchBlt`, как показано на иллюстрации 2-9.

![PixelSearch WinAPI Functions](winapi-pixel-search.png)

**Иллюстрация 2-9.** *WinAPI вызовы функции PixekSearch*

Функция `StretchBlt` копирует битовое изображение из DC экрана в контекст устройства памяти, который так же известен как **совместимый контекст устройства** (compatible device context). Чтобы проверить это предположение, сравним входные параметры вызовов `GetDC`, `CreateCompatibleBitmap`, `CreateCompatibleDC`, `SelectObject` и `StretchBlt` в окне API Monitor.

Функция `GetDC` возвращает дескриптор DC экрана, в нашем случае равный 0x5a011146. Что означает это число? Воспользуемся документацией WinAPI, чтобы уточнить определение типа `HDC`, которое соответствует дескриптору DC:
```C
typedef void *PVOID;
typedef PVOID HANDLE;
typedef HANDLE HDC;
```
`HDC` представляет собой указатель на область памяти. Следовательно, 0x5a011146 - это адрес памяти, где хранится дескриптор.

Вызов `CreateCompatibleBitmap` идёт после `GetDC`. С помощью него мы создаем битовое изображение для работы над ним в памяти. Первый входной параметр `CreateCompatibleBitmap` - наш дескриптор DC экрана. Далее с помощью `CreateCompatibleDC` создаем совместимый контекст устройства. Вызовом `SelectObject` мы загружаем в него битовое изображение. После этого вызов `StretchBlt` может выполнить копирование изображения из контекста экрана (дескриптор 0x5a011146) в совместимый DC в памяти.

Следующий шаг AutoIt функции `PixelSearch` - это вызов WinAPI подпрограммы `GetDIBits`. Она конвертирует аппаратно-зависимое битовое изображение (DDB) в **аппаратно-независимое** (DIB). Зачем это нужно? DIB формат более удобен, потому что позволяет работать с изображениями как с обычным массивом.

Заключительный шаг функции `PixelSearch` - проход по всем пикселям DIB и сравнение цвета каждого из них с заданным. Для этой операции вызовы WinAPI не нужны.

Пример C++ реализации захвата изображений с экрана доступен в WinAPI документации (https://docs.microsoft.com/en-us/windows/desktop/gdi/capturing-an-image). Эта реализация демонстрирует копирование битового изображения в совместимый DC и преобразование DDB в DIB.

В функцию `PixelSearch` можно передать дескриптор окна пятым параметром. Тогда поиск пикселя происходит именно в нём. Иначе функция ищет на всём экране.

Блок кода 2-15 демонстрирует поиск пикселя в заданном окне.

**Блок кода 2-15.** *Скрипт `PixelSearchWindow.au3`*
```AutoIt
$hWnd = WinGetHandle("[CLASS:MSPaintApp]")
$coord = PixelSearch(0, 207, 1000, 600, 0x000000, 0, 1, $hWnd)
If @error = 0 then
    MsgBox(0, "", "Координата чёрной точки: x = " & $coord[0] & " y = " &
$coord[1])
else
    MsgBox(0, "", "Чёрная точка не найдена")
endif
```
Согласно документации AutoIt, скрипт `PixelSearchWindow.au3` должен искать пиксель в перекрытом окне Paint, но этого не происходит. Похоже, что мы снова столкнулись с ошибкой, которая проявлялась ранее в `PixelGetColor` функции. API Monitor подтверждает, что в подпрограмму WinAPI `GetDC` снова передается "NULL" вместо дескриптора окна. По этой причине `PixelSearch` всегда обрабатывает DC экрана, независимо от своего пятого параметра. Вы можете обойти эту ошибку, если будете работать с WinAPI напрямую. Пример такого решения - рассмотренный ранее скрипт `GetPixel.au3`. В этом случае вам необходимо полностью повторить алгоритм функции `PixelSearch`.

Другая функция AutoIt для анализа движущихся изображений - это `PixelChecksum`. Рассмотренные нами ранее функции `PixelGetColor` и `PixelSearch` позволяют получить информацию о единственном пикселе. `PixelChecksum` работает иначе. Она позволяет обнаружить изменение изображения в заданной области экрана. Это может быть полезно, когда бот должен реагировать на игровые события.

Функция `PixelChecksum` рассчитывает **контрольную сумму** (или checksum) для пикселей в указанной области. Эта сумма представляет собой число, полученное в результате применения определённого алгоритма к набору данных. Простейший пример - суммирование кодов цветов пикселей. Если цвет хотя бы одного пикселя изменится, результирующая контроольная сумма также будет отличаться.

Блок кода 2-16 демонстрирует применение функции `PixelChecksum`.

**Блок кода 2-16.** *Скрипт `PixelChecksum.au3`*
```AutoIt
$checkSum = PixelChecksum(0, 0, 50, 50)
while $checkSum = PixelChecksum(0, 0, 50, 50)
    Sleep(100)
wend
MsgBox(0, "", "Изображение в области экрана изменилось")
```
Скрипт `PixelChecksum.au3` выводит диалоговое окно, если меняется изображение в области экрана между точками с координатами x = 0, y = 0 и x = 50, y = 50. Функция `PixelChecksum` вызывается дважды. Первый раз она вычисляет начальное значение контрольной суммы. После этого функция вызывается каждые 100 миллисекунд в цикле `while`. Временная задержка выполняется с помощью вызова `Sleep`. Цикл продолжается до тех пор, пока контрольная сумма не изменится. Как только это происходит, цикл прерывается и выводится диалоговое окно.

Рассмотрим внутренние вызовы функции `PixelChecksum`. API Monitor покажет нам ту же самую последовательность WinAPI вызовов, что и для функции `PixelSearch`. Это означает что AutoIt следует одному и тому же алгоритму для получения DIB из изображения на экране. Однако, последний шаг этих двух функций отличается. `PixelChecksum` вычисляет контрольную сумму по указанному алгоритму. Им может быть **ADLER** или **CRC32**. Любой алгоритм расечта контрольных сумм имеет **коллизии**. Коллизия - это два разных набора входных данных, для которых функция возвращает одинаковый результат. Алгоритмы предлагаемые AutoIt отличаются скоростью и надежностью. CRC32 работает медленнее, но имеет меньше коллизий.

Все рассмотренные AutoIt функции для анализа пикселей работают в полноэкранных окнах DirectX приложений. Поэтому вы можете использовать их для разработки своих ботов.





