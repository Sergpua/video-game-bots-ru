# Пример кликера для Lineage 2

Сейчас мы напишем простого бота кликера для MMORPG Lineage 2. В нём мы применим уже известные техники нам по перехвату и внедрению данных в игровое приложение.

## Обзор игры Lineage 2

Игровой процесс Lineage 2 очень типичен для жанра RPG. Вначале надо выбрать одного из нескольких доступных персонажей. Для получения новых умений и покупки предметов игрок должен выполнять задания (или квесты) и охотиться на монстров. Этот процесс получения ресурсов называется "фарминг" (farming). При этом у игроков всегда есть возможность общаться и взаимодействовать между собой, как и в любой MMORPG. Они могут помогать или мешать друг другу. Если несколько игроков хотят получить один и тот же нужный им ресурс, они должны сражаться за него. Этот элемент соперничества представляет наиболее привлекательную часть игрового процесса. Поэтому пользователи стремятся как можно быстрее и лучше развить своего персонажа, чтобы сражаться между собой.

Самый прямолинейный путь развития персонажа – это охота на монстров. После убийства каждого из них, игрок получает очки опыта для улучшения умений персонажа, а также золото для покупки новых предметов. Мы попытаемся автоматизировать именно этот процесс, поскольку он ведёт к разностороннему развитию героя. В то же время есть и другие пути получения игровых ресурсов: торговля, рыбалка, создание предметов и выполнение заданий.

Рассмотрим элементы игрового интерфейса, изображенные на иллюстрации 2-12:

1. Окно состояния с параметрами персонажа игрока. Наиболее важные из них – это очки здоровья (health points или HP) и очки маны (mana points или MP).

2. Окно цели с информацией о выделенном в данный момент монстре. В нём есть полоска с HP цели.

3. Панель горячих клавиш с иконками возможных действий и доступных умений.

4. Окно чата для ввода команд и отправки сообщений другим игрокам.

![Интерфейс Lineage 2](lineage-interface.png)

**Иллюстрация 2-12.** *Интерфейс Lineage 2*

Тщательное изучение интерфейса поможет вам разработать наиболее простой и эффективный алгоритм взаимодействия бота с игрой. Более подробно интерфейс Lineage 2 описан на [Wiki страничке](l2wiki.com/Game_Interface).

В интернете есть множество серверов Lineage 2. Они отличаются версией игры, дополнительными возможностями и системами защиты, которые предотвращают использование ботов. Наиболее эффектины такие системы на [официальных серверах](www.lineage2.eu), созданных разработчиками игры. Кроме них есть так называемые пиратские сервера, которые поддерживаются энтузиастами. Как правило их защита значительно слабее. В нашем примере мы будем подключаться к серверу [Rpg-Club](www.rpg-club.com).

## Реализация бота

Чтобы понять лучше механику игры, попробуйте убить нескольких монстров самостоятельно. Вы заметите, что почти всё время нажимаете одни и те же кнопки панели горячих клавиш. 

Теперь попробуем составить алгоритм действий, которые мы хотим автоматизировать. Моя версия выглядит следующим образом:

1. Выбрать монстра для атаки левым щелчком мыши по нему. Альтернативный способ – ввести следующую команду в окно чата:
```
/target ИмяМонстра

```
Полный лист игровых команд приведён на [официальном сайте](l2wiki.com/classic/Commands). Также игрок может назначать несколько действий на одну клавишу с помощью [макросов](l2wiki.com/classic/Macros).

2. Нажать кнопку "атака" на панели горячих клавиш. Это же действие можно выполнить с помощью клавиши F1.

3. Ожидать пока персонаж убьет монстра.

4. Нажать кнопку "подобрать" для сбора выпавших из монстра предметов и золота. Это действие также можно выполнить по горячей клавише.

Этот алгоритм выглядит достаточно просто и не содержит сложных условий. Напишем скрипт, который будет по нему работать.

### Слепой бот

В качестве первой попытки мы будем строго следовать нашему алгоритму охоты на монстров. На каждом его шаге бот будет симулировать нажатие клавиши. Такой кликер можно считать "слепым", потому что он не читает с экрана информацию о состоянии игровых объектов.

Перед тем как мы начнём писать код, рассмотрим конфигурацию панели горячих клавиш. Вам нужно настроить её так же как на иллюстрации 2-13.

![Панель горячих клавиш](lineage-hotbar.png)

**Иллюстрация 2-12.** *Панель горячих клавиш*

Таблица 2-6 описывает конфигурацию панели.

**Таблица 2-6.** *Действия и соответствующие им горячие клавиши*

| Клавиша | Действие |
| --- | --- |
| F1 | Атаковать выделенного в данный момент монстра. |
| F2 | Использовать наступательной умение по текущей цели. |
| F5 | Использовать зелье лечения для восстановления HP. |
| F8 | Подобрать с земли предметы, лежащие около персонажа. |
| F9 | Макрос с командой `/target ИмяМонстра` для выбора цели. |
| F10 | Выбор ближайшего монстра. |

Теперь связать горячие клавиши с шагами алгоритма достаточно просто. Скрипт `BlindBot.au3`, приведённый в листинге 2-21, делает это.

**Листинг 2-21.** *Скрипт `BlindBot.au3`*
```AutoIt
#RequireAdmin

Sleep(2000)

while True
    Send("{F9}")
    Sleep(200)
    Send("{F1}")
    Sleep(5000)
    Send("{F8}")
    Sleep(1000)
wend
```
В первой строчке скрипта стоит ключевое слово `#RequireAdmin`. Благодаря ему, скрипт потребует прав администратора при запуске. Получив эти права, он сможет взаимодействовать с другими приложениями независимо от того, какой пользователь их запустил. Некоторые клиенты Lineage 2 также требуют прав администратора. Поэтому к ним не смогут получить доступ скрипты AutoIt, запущенные от имени пользователя с меньшими правами. Я рекомендую всегда использовать `#RequireAdmin` в ваших кликерах.

Первое действие скрипта – это двухсекундная задержка. Она нужна, чтобы вы успели переключится на окно Lineage 2. Текущая версия бота работает только с активным окном игры.

После вызова `Sleep` идёт бесконечный цикл `while`, в котором выполняются все действия бота:

1. `Send("{F9}")` – выбрать монстра с помощью макроса, настроенного на клавишу F9.

2. `Sleep(200)` – подождать 200 миллисекунд. Это время требуется клиенту Lineage 2, чтобы выделить монстра и отрисовать окно цели.

---
Помните, что все действия в окне игрового приложения происходят не мгновенно. Часто время на их выполнение намного меньше скорости реакции человека. Поэтому вы его не замечаете.
---

3. `Send("{F1}")` – атаковать выбранного монстра.

4. `Sleep(5000)` – ожидать пять секунд, пока персонаж не подбежит к монстру и не убьёт его.

5. `Send("{F8}")` – подобрать один выпавший предмет.

5. `Sleep(1000)` – ждать одну секунду, пока персонаж подбирает предмет.

В нашем примере последовательность действий бота строго определена. Поэтому каждое действие может завершиться успешно только в том случае, если предыдущее было также успешно. Прежде всего, макрос выбора монстра должен отработать правильно. Если этот шаг не удался, все дальнейшие действия не имеют смысла. Затем персонаж должен подбежать к монстру и убить его за пять секунд. Это время может меняться в зависимости от расстояния до цели. Наконец, из монстра может выпасть более одного предмета. Наш скрипт будет работать правильно только если все перечисленные условия выполняются, иначе неизбежны ошибки.

Вы можете запустить скрипт и проверить, как он работает. Часто бот будет совершать не те действия, которые нужны в данный момент, потому что одно из условий было нарушено. С другой стороны, такие ошибки не критичны для бота, поскольку он продолжает свою работу. Это возможно благодаря особенности команды `/target` и механизму атаки цели. Если выполнить макрос `/target` дважды, бот будет атаковать уже выбранного монстра. Таким образом он добьёт цель. Даже если монстр выжил после первой итерации цикла `while`, атака на него продолжится в следующих итерациях. Кроме того, команда "поднять предмет" не прерывает атаку, если поблизости от персонажа нет предметов. Поэтому он будет продолжать бить цель и после пятисекундной задержки.

Единственная проблема, которую бот не сможет решить – это собирание выпадающих предметов. Число их случайно и зависит от вида монстра, поэтому иногда они будут оставаться лежать на земле. Лучшее, что можно сделать в такой ситуации – повторять действие "поднять" несколько раз, чтобы наверняка собрать всё. Даже если зачастую число нажатий будет больше необходимого.

Мы можем сделать скрипт более удобным для чтения и изменений, если вынесем каждый шаг алгоритма в отдельную функцию с говорящим названием. Результат приведён в скрипте `BlindBotFunc.au3` из листинга 2-22.

**Листинг 2-22.** *Скрипт `BlindBotFunc.au3`*
```AutoIt
#RequireAdmin

func SelectTarget()
    Send("{F9}")
    Sleep(200)
endfunc

func Attack()
    Send("{F1}")
    Sleep(5000)
endfunc

func Pickup()
    Send("{F8}")
    Sleep(1000)
endfunc

Sleep(2000)

while True
    SelectTarget()
    Attack()
    Pickup()
wend
```
Теперь скрипт выглядит намного понятнее. Он начинается свою работу с вызова `Sleep`. Весь код выше – это объявления функций. Он будет выполнен только в местах их вызова, то есть в цикле `while`. Алгоритмы этого скрипта и `BlindBot.au3` идентичны.

### Бот с условиями

Попробуем улучшить нашего бота и сделать его более эффективным. Он будет реже ошибаться, если сможет проверять результат каждого своего действия. Применим функцию анализа пикселей для чтения состояния окружающих объектов.

Перед тем как мы продолжим, будет полезно добавить механизм вывода диагностических сообщений. Техника вывода сообщений в местах принятия программой важных решений известна как **трассировка** (tracing). С её помощью мы сможем отследить, какие решения принимает бот.

Реализация функции вывода сообщений в файл представлена в листинге 2-23.

**Листинг 2-23.** *Реализация функции `LogWrite`*
```AutoIt
global const $LogFile = "debug.log"

func LogWrite($data)
    FileWrite($LogFile, $data & chr(10))
endfunc

LogWrite("Hello world!")
```
После выполнения этого скрипта в папке с ним будет создан файл `debug.log`, который содержит строку "Hello world!". Функция `LogWrite` – это обёртка над подпрограммой AutoIt `FileWrite`. Обёртка удобна, если вам понадобиться отключить вывод в лог файл. Для этого достаточно будет закомментировать в ней вызов `FileWrite`. Вы можете изменить путь до файла и его имя с помощью константы `LogFile`.

---
Всегда следует предусматривать способ отладки (обнаружения и устранения ошибок) вашего приложения. Самый простой подход – печатать на консоль или в файл наиболее важные решения его алгоритма.
---

Первое условие, которое бот должен проверить – это результат выбора цели. Попробуйте выделять монстров с помощью мыши самостоятельно. Заметили ли вы элемент интерфейса, который отличается при наличии и отсутствии цели? Этот элемент – окно цели. Оно появляется каждый раз при выборе цели и пропадает при её убийстве. Найти это окно на экране мы можем с помощью функции `FFBestSpot` библиотеки FastFind.

Мы должны выбрать цвет, который был бы уникальным только для окна цели. Бот должен отличать его от всех остальных окон. Для этой задачи подошёл бы красный цвет полосы HP монстра. Код из листинга 2-24 проверяет, есть ли окно цели на экране.

**Листинг 2-24.** *Функция `IsTargetExist`*
```AutoIt
func IsTargetExist()
    const $SizeSearch = 80
    const $MinNbPixel = 3
    const $OptNbPixel = 10
    const $PosX = 688
    const $PosY = 67

    $coords = FFBestSpot($SizeSearch, $MinNbPixel, $OptNbPixel, $PosX, $PosY, _
                         0x871D18, 10)

    const $MaxX = 800
    const $MinX = 575
    const $MaxY = 100

    if not @error then
        if $MinX < $coords[0] and $coords[0] < $MaxX and $coords[1] < $MaxY then
            LogWrite("IsTargetExist() - Success, coords = " & $coords[0] & _
                     ", " & $coords[1] & " pixels = " & $coords[2])
            return True
        else
            LogWrite("IsTargetExist() - Fail #1")
            return False
        endif
    else
        LogWrite("IsTargetExist() - Fail #2")
        return False
    endif
endfunc
```
Рассмотрим функцию `IsTargetExist` подробнее. Константы PosX и PosY – это примерные координаты полосы HP цели. Мы передаём их и красный цвет полосы (равный 871D18) в функцию `FFBestSpot` в качестве входных параметров. Она ищет указанную область по всему экрану. Следовательно, вместо окна цели может быть найдено окно состояния персонажа. Это будет происходить независимо от наличия окна цели, и бот может их перепутать. Чтобы избежать этой ошибки, следует проверять координаты области, найденной функцией. Для этого мы сравниваем координаты, возвращаемые `FFBestSpot` (coords[0] и coords[1]) с максимальными и минимальными допустимыми значениями (MinX/MaxX и MaxY). Эти значения определяют ожидаемую область экрана, где должно появиться окно цели. Они зависят от разрешения экрана, и вам придётся подбирать их самостоятельно.

Мы вызываем функцию `LogWrite` в каждой ветви оператора `if`, чтобы отследить принятое `IsTargetExist` решение. Благодаря этому мы сможем обнаружить возможные ошибки.

Новая функция `IsTargetExist` решает сразу две задачи. С её помощью мы можем определить, успешно ли отработал выбор цели в `SelectTarget`. Также `IsTargetExist` позволяет проверить, жив ли атакуемый ботом монстр или нет.

Скрипт `AnalysisBot.au3`, представленный в листинге 2-25, проверяет наличие цели с помощью функции `IsTargetExist`.

**Листинг 2-25.** *Скрипт `AnalysisBot.au3`*
```AutoIt
#include "FastFind.au3"

#RequireAdmin

Sleep(2000)

global const $LogFile = "debug.log"

func LogWrite($data)
    FileWrite($LogFile, $data & chr(10))
endfunc

func IsTargetExist()
    ; Смотрите реализацию в листинге 2-24
endfunc

func SelectTarget()
    LogWrite("SelectTarget()")
    while not IsTargetExist()
        Send("{F9}")
        Sleep(200)
    wend
endfunc

func Attack()
    LogWrite("Attack()")
    while IsTargetExist()
        Send("{F1}")
        Sleep(1000)
    wend
endfunc

func Pickup()
    Send("{F8}")
    Sleep(1000)
endfunc

while True
    SelectTarget()
    Attack()
    Pickup()
wend
```
Обратите внимание на новую реализацию функций `SelectTarget` и `Attack`. В `SelectTarget` мы пытаемся выделить цель до тех пор, пока функция `IsTargetExist` не вернёт значение `True`. Только после этого мы переходим в функцию `Attack`. Теперь бот атакует монстра (выбирая действие "атака" по клавише F1) до тех пор, пока тот жив.

Мы печатаем в лог файл названия функций `SelectTarget` и `Attack`, когда они получают управление. Этот вывод позволяет определить, кто из них вызывает `IsTargetExist`.

### Дальнейшие улучшения

Теперь наш кликер выбирает действие, согласно игровой ситуации. Тем не менее, возможны несколько случаев, когда бот допустит критическую ошибку и умрёт.

Первая проблема заключается в агрессивных монстрах. Большинство из них остаются в одной и той же области карты и не реагируют на приближение игрока. Но некоторые в этом случае атакуют.

Наш бот выбирает цель для атаки и бежит к ней. При этом он игнорирует всех других существ, которые встретятся ему по пути. Можно сказать, что они "не видимы" для бота, поскольку его алгоритм их не учитывает. Таким образом, монстры могут напасть на бота, бегущего к своей цели. Он будет думать что сражается с одним противником, но на самом деле их может оказаться три или больше. Вместе они легко убьют бота.

Чтобы решить эту проблему, воспользуемся командой "выбор ближайшей цели". На нашей панели горячих клавиш она доступна по нажатию F10. Листинг 2-26 демонстрирует дополненную версию функции `SelectTarget`.

**Листинг 2-26.** *Функция `SelectTarget`*
```AutoIt
func SelectTarget()
    LogWrite("SelectTarget()")
    while not IsTargetExist()
        Send("{F10}")
        Sleep(200)
        
        if IsTargetExist() then
            exitloop
        endif
        
        Send("{F9}")
        Sleep(200)
    wend
endfunc
```
Теперь бот в первую очередь пытается найти ближайшую цель по клавише F10. Только после того, как ему это не удалось, он применяет команду `/target`. Таким образом, бот всегда будет выбирать ближайшего к нему монстра. Если тот окажется агрессивным, то побежит на встречу и будет ближе всего.

Вторая проблема – это преграды на карте. Пока бот двигается к своей цели, он может зацепиться за камень или дерево и застрять. Самое простое решение – сделать таймаут для атаки. Если отведённое на атаку время прошло, но цель осталась жива, мы можем предположить, что бот застрял. Тогда ему могут помочь обойти препятствие случайные перемещения. Новые версии функций `Move` и `Attack` из листинга 2-27 демонстрируют это решение.

**Листинг 2-27.** *Функции `Move` и `Attack`*
```AutoIt
func Move()
    SRandom(@MSEC)
    MouseClick("left", Random(300, 800), Random(170, 550), 1)
endfunc

func Attack()
    LogWrite("Attack()")

    const $TimeoutMax = 10
    $timeout = 0
    while IsTargetExist() and $timeout < $TimeoutMax
        Send("{F1}")
        Sleep(2000)

        Send("{F2}")
        Sleep(2000)

        $timeout += 1
    wend

    if $timeout == $TimeoutMax then
        Move()
    endif
endfunc
```
Мы добавили счётчик `timeout` в функцию `Attack`. На каждой итерации цикла `while` он инкрементируется и сравнивается с пороговым значением константы `TimeoutMax`. Когда счётчик достигает `TimeoutMax`, бот делает вывод, что застрял. В этом случае вызывается функция `Move`, которая симулирует щелчок левой кнопки мыши по точке со случайной координатой. Чтобы получить случайное число мы использовали функции AutoIt `SRandom` и `Random`. Первая из них инициализирует генератор псевдослучайных чисел. Вторая возвращает следующее число из очереди сгенерированных. В качестве параметров функция `Random` принимает границы интервала для случайного числа.

Возможно, вы заметили дополнительное действие, появившееся в новой функции `Attack`. Это симуляция нажатия клавиши F2. Мы можем назначить на неё любое атакующее умение, и бот будет применять его в сражении. Благодаря этому он будет быстрее убивать монстров.

Теперь наш кликер может самостоятельно работать достаточно долгое время. Он умеет обходить препятствия и первым атаковать агрессивных монстров. Но есть одно улучшение, способное сделать бота еще более живучим. Это использование зелья восстановления здоровья, которое привязано к горячей клавише F5. Чтобы правильно его применять, необходимо анализировать полосу HP персонажа в окне состояния. Вы можете реализовать этот механизм самостоятельно в качестве упражнения. Алгоритм поиска области экрана будет похож на функцию `IsTargetExist`.

## Выводы

Мы реализовали бота кликера для игры Lineage 2. Он использует самые распространённые техники симуляции действий и анализа окна игрового приложения. Попробуем оценить их эффективность и обобщить результат на всех ботов этого типа.

Преимущества кликеров:

1. Простота разработки, отладки и расширения функциональности.

2. Просто адаптировать под любую версию игры, даже если её интерфейс поменялся.

3. Защититься от этого типа ботов достаточно сложно.

Недостатки кликеров:

1. Каждому пользователю приходится подгонять цвета и координаты искомых пикселей под своё разрешение экрана.

2. Бот может зависнуть в некоторых непредвиденных случаях (смерть персонажа, отключение от сервера и т.д.).

3. Таймауты на симулируемые действия часто приводят к потере времени и низкой эффективности.

4. При анализе изображений на экране возможны ошибки. Поэтому в некоторых случаях бот будет выбирать неподходящие действия.

Кликер хорошо подходит для автоматизации задач, состоящих из строгой последовательности шагов с минимальным количеством условий. Также обязательное требование для его стабильной работы – это относительно невысокая цена ошибки. То есть при выборе нескольких неверных действия, бот должен иметь возможность вернуться в известное ему состояние.

