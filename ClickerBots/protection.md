# Приёмы защиты от кликеров

Мы узнали основные принципы работы кликеров. Теперь попробуем поменять сторону и посмотреть на них с позиции разработчиков систем защиты. Как можно обнаружить ботов этого типа? На этот вопрос мы попробуем ответить в этом разделе.

В первой главе мы рассмотрели архитектуру типичного игрового приложения. Как вы помните, оно имеет две части: клиентскую и серверную. Зачастую, система защиты придерживается той же архитектуры и разделена на две части. Клиентская часть контролирует точки перехвата и внедрения данных на стороне пользователя (драйвера, ОС, приложение). Серверная часть следит за взаимодействием игрового приложения и сервером. Большинство техник по обнаружению кликеров работают на клиентской стороне.

Главная цель любой системы защиты - обнаружить факт несанкционированного чтения или модификации игровых данных. Именно этим занимаются все боты.

Когда обнаружить нарушение удалось, у системы защиты есть несколько вариантов реакции:

1. Уведомить администратора игрового сервера о подозрительных действиях игрока. Для этого достаточно сделать запись в лог файл на стороне сервера.

2. Разорвать соединение между подозрительным пользователем и сервером.

3. Заблокировать подозрительного игрока по IP адресу. Это предотвратит его дальнейшие попытки подключения к серверу.

Мы рассмотрим только алгоритмы обнаружения ботов, но не способы блокировки их работы. Также уделим внимание возможным уязвимостям этих алгоритмов.

## Тестовое приложение

Для тестирования наших алгоритмов обнаружения ботов, мы воспользуемся приложением Блокнот. Предположим, что это игровое приложение, которое мы должны защитить. Напишем простейший AutoIt скрипт, который выполняет роль кликера и вводит текст в Блокнот. Наша цель - его обнаружить.

Листинг 2-28 демонстрирует скрипт `SimpleBot.au3`, который печатает буквы "a", "b", "c" в окне Блокнота.

**Листинг 2-28.** *Скрипт `SimpleBot.au3`*
```AutoIt
$hWnd = WinGetHandle("[CLASS:Notepad]")
WinActivate($hWnd)
Sleep(200)

while True
    Send("a")
    Sleep(1000)
    Send("b")
    Sleep(2000)
    Send("c")
    Sleep(1500)
wend
```
Для тестирования запустите Блокнот, а затем скрипт `SimpleBot.au3`. Он переключится на нужное окно и будет вводить буквы в бесконечном цикле.

`SimpleBot.au3` - это отправная точка нашего исследования. Его цель отличить симулируемые этим скриптом нажатия клавиш от действий пользователя в окне Блокнота. Для написания наших прототипов алгоритмов обнаружения, мы также воспользуемся языком AutoIt. Это позволит писать простой и компактный код. Для реальных систем защиты предпочтительнее использовать компилируемые языки вроде C или C++.

## Анализ действий

### Вычисление временных задержек

Скрипт `SimpleBot.au3` симулирует одни и те же действия в цикле. Их систематичность - это первое, что бросается в глаза. Еще раз обратимся к коду скрипта. Между каждым действием и предыдущим стоят задержки. Человек не может выдерживать временные интервалы настолько точно, как это делает программа. Более того, такая чёткость в задержках не имеет никакого смысла в компьютерной игре, потому что зачастую пользователь должен реагировать на различные ситуации. Если кто-то ведёт себя подобным образом, очень вероятно что это программа.

Алгоритм защиты может замерять задержки между двумя одинаковыми действиями. Если задержка между ними отличается не более чем на 100 миллисекунд, они симулируются ботом. Попробуем реализовать такую защиту.

---
Скорость реакции среднестатистического человека примерно равна 300 миллисекундам. У профессиональных игроков она меньше (порядка 150 миллисекунд).
---

Наш скрипт должен выполнять две задачи: перехватывать действия пользователя и измерять временные задержки между ними. Код в листинге 2-29 реализует перехват нажатия клавиш.

**Листинг 2-29.** *Перехват нажатия клавиш*
```AutoIt
global const $gKeyHandler = "_KeyHandler"

func _KeyHandler()
    $keyPressed = @HotKeyPressed

    LogWrite("_KeyHandler() - asc = " & asc($keyPressed) & " key = " & $keyPressed)
    AnalyzeKey($keyPressed)

    HotKeySet($keyPressed)
    Send($keyPressed)
    HotKeySet($keyPressed, $gKeyHandler)
endfunc

func InitKeyHooks($handler)
    for $i = 0 to 255
        HotKeySet(Chr($i), $handler)
    next
endfunc

InitKeyHooks($gKeyHandler)

while true
    Sleep(10)
wend
```
Мы применили функцию AutoIt `HotKeySet`, чтобы назначить обработчик (handler или hook) для нажимаемых клавиш. В пользовательской функции `InitKeyHooks` мы вызываем `HotKeySet` для кода каждой клавиши в `for` цикле от 0 до 255. Таким образом, при нажатии любой клавиши будет вызван обработчик `_KeyHandler`. Он выполняет следующие шаги:

1. Вызывает функцию `AnalyzeKey`, передавая ей код нажатой клавиши. Этот код хранится в макросе `@HotKeyPressed`.

2. Выключает перехват следующего нажатия обрабатываемой клавиши. Для этого снова вызывается функция `HotKeySet`. Данный шаг нужен, чтобы нажатие дошло до приложения Блокнот.

3. Вызывает функцию `Send` для симуляции нажатия обрабатываемой клавиши в Блокноте.

4. Включает перехват последующих нажатий.

Листинг 2-30 демонстрирует код функции `AnalyzeKey`.

**Листинг 2-30.** *Функция `AnalyzeKey`*
```AutoIt
global $gTimeSpanA = -1
global $gPrevTimestampA = -1

func AnalyzeKey($key)
    local $timestamp = (@SEC * 1000 + @MSEC)
    LogWrite("AnalyzeKey() - key = " & $key & " msec = " & $timestamp)
    if $key <> 'a' then
        return
    endif

    if $gPrevTimestampA = -1 then
        $gPrevTimestampA = $timestamp
        return
    endif

    local $newTimeSpan = $timestamp - $gPrevTimestampA
    $gPrevTimestampA = $timestamp

    if $gTimeSpanA = -1 then
        $gTimeSpanA = $newTimeSpan
        return
    endif

    if Abs($gTimeSpanA - $newTimeSpan) < 100 then
        MsgBox(0, "Alert", "Clicker bot detected!")
    endif
endfunc
```
В функции `AnalyzeKey` мы замеряем задержки между нажатиями клавиши "a". Две глобальные переменные хранят текущее состояние алгоритма:

1. `gPrevTimestampA` - это момент времени (timestamp) первого нажатия.

2. `gTimeSpanA` - это задержка между первым и вторым нажатиями.

При старте скрипта обоим переменным присваивается значение "-1", которое соответствует неинициализированному состоянию. Нашему алгоритму требуется перехватить минимум три нажатия клавиши, чтобы обнаружить бота. Первое нажатие инициализирует переменную `gPrevTimestampA`:
```AutoIt
    if $gPrevTimestampA = -1 then
        $gPrevTimestampA = $timestamp
        return
    endif
```
Момент времени второго нажатия мы используем для расчета переменной `gTimeSpanA`. Она равна разности между временем первого и второго нажатий:
```AutoIt
    local $newTimeSpan = $timestamp - $gPrevTimestampA
    $gPrevTimestampA = $timestamp

    if $gTimeSpanA = -1 then
        $gTimeSpanA = $newTimeSpan
        return
    endif
```
После третьего нажатия мы можем рассчитать задержку второй раз (переменная `newTimeSpan`) и сранить её со значением `gTimeSpanA`:
```AutoIt
    if Abs($gTimeSpanA - $newTimeSpan) < 100 then
        MsgBox(0, "Alert", "Clicker bot detected!")
    endif
```
Если разница между первой и второй задержкой менее 100 миллисекунд, алгоритм защиты выводит сообщение об обнаружении бота.

Полный код защиты представлен в скрипте `TimeSpanProtection.au3` из листинга 2-31. В нём мы опустили реализацию функций `_KeyHandler` и `AnalyzeKey`, поскольку рассмотрели их ранее.

**Листинг 2-31.** *Скрипт `TimeSpanProtection.au3`*
```AutoIt
global const $gKeyHandler = "_KeyHandler"
global const $kLogFile = "debug.log"

global $gTimeSpanA = -1
global $gPrevTimestampA = -1

func LogWrite($data)
    FileWrite($kLogFile, $data & chr(10))
endfunc

func _KeyHandler()
    ; См листинг 2-29
endfunc

func InitKeyHooks($handler)
    for $i = 0 to 256
        HotKeySet(Chr($i), $handler)
    next
endfunc

func AnalyzeKey($key)
    ; См листинг 2-30
endfunc

InitKeyHooks($gKeyHandler)

while true
    Sleep(10)
wend
```

### Анализ последовательности действий

Мы можем незначительно изменить скрипт `SimpleBot.au3`, чтобы обойти защиту `TimeSpanProtection.au3`. Для этого вместо фиксированных задержек между действиями сделаем случайные. Листинг 2-32 демонстрирует исправленную версию бота.

**Листинг 2-32.** *Скрипт `RandomDelayBot.au3`*
```AutoIt
SRandom(@MSEC)

$hWnd = WinGetHandle("[CLASS:Notepad]")
WinActivate($hWnd)
Sleep(200)

while true
    Send("a")
    Sleep(Random(800, 1200))
    Send("b")
    Sleep(Random(1700, 2300))
    Send("c")
    Sleep(Random(1300, 1700))
wend
```
Каждый раз, в вызов `Sleep` мы передаём случайное число, полученное из функции `Random`. Попробуйте протестировать нового бота вместе с защитой `TimeSpanProtection.au3`. Теперь она не может обнаружить кликера.

У скрипта `RandomDelayBot.au3` по-прежнему есть закономерность, которая очевидна человеку, следящему за его работой. Эта закономерность - последовательность нажимаемых кнопок. Очевидно, что игрок не способен безошибочно повторять свои действия сотни и тысячи раз. Даже если он захочет это сделать, в какой-то момент он ошибется и нажмёт не на ту клавишу.

Перепишем скрипт защиты так, чтобы вместо временных задержек он анализировал последовательность нажатых пользователем клавиш. Для этого надо изменить функцию `AnalyzeKey`, как показано в листинге 2-33.

**Листинг 2-33.** *Функция `AnalyzeKey`*
```AutoIt
global const $gActionTemplate[3] = ['a', 'b', 'c']
global $gActionIndex = 0
global $gCounter = 0

func Reset()
    $gActionIndex = 0
    $gCounter = 0
endfunc

func AnalyzeKey($key)
    LogWrite("AnalyzeKey() - key = " & $key);

    $indexMax = UBound($gActionTemplate) - 1
    if $gActionIndex <= $indexMax and $key <> $gActionTemplate[$gActionIndex] then
        Reset()
        return
    endif

    if $gActionIndex < $indexMax and $key = $gActionTemplate[$gActionIndex] then
        $gActionIndex += 1
        return
    endif

    if $gActionIndex = $indexMax and $key = $gActionTemplate[$gActionIndex] then
        $gCounter += 1
        $gActionIndex = 0

        if $gCounter = 3 then
            MsgBox(0, "Alert", "Clicker bot detected!")
            Reset()
        endif
    endif
endfunc
```
Новый вариант функции `AnalyzeKey` использует глобальную константу и две переменные:

1. 	`gActionTemplate` – это последовательность действий, которую выполняет предполагаемыей бот.

2. `gActionIndex` - индекс в массива `gActionTemplate`, который соответствует последнему перехваченному нажатию.

3. `gCounter` - число обнаруженных повторений последовательности действий.

В функции `AnalyzeKey` есть три основных условия для обработки нажатия клавиши. Первое условие выполняется, если нажатие не соответствует ни одному элементу массива `gActionTemplate`:
```AutoIt
    $indexMax = UBound($gActionTemplate) - 1
    if $gActionIndex <= $indexMax and $key <> $gActionTemplate[$gActionIndex] then
        Reset()
        return
    endif
```
В этом случае мы вызываем функцию `Reset`, которая сбрасывает в ноль значения переменных `gActionIndex` и `gCounter`. После этого мы выходим из `AnalyzeKey`.

Второе условие обработки нажатия выполняется, когда перехваченное действие встречается в массиве `gActionTemplate`, этот элемент не последний и его индекс равен `gActionIndex`:
```AutoIt
    if $gActionIndex < $indexMax and $key = $gActionTemplate[$gActionIndex] then
        $gActionIndex += 1
        return
    endif
```
Это означает, что нажатие попадает в предполагаемую последовательность действий бота. В этом случае мы инкрементируем переменную `gActionIndex` и ожидаем новое нажатие, чтобы сравнить его со следующим элементом последовательности.

Последнее условие выполняется, когда перехваченное нажатие соответствует последнему элементу массива `gActionTemplate`:
```AutoIt
if $gActionIndex = $indexMax and $key = $gActionTemplate[$gActionIndex]
then
        $gCounter += 1
        $gActionIndex = 0
        if $gCounter = 3 then
            MsgBox(0, "Alert", "Clicker bot detected!")
            Reset()
        endif
    endif
```
В этом случае мы инкрементируем счётчик совпадения последовательностей `gCounter` и сбрасываем значение `gActionIndex`. Таким образом мы готовы к обнаружению следующей последовательности действий бота.

Если ожидаемая последовательность действий происходит три раза подряд, скрипт делает вывод, что работает бот и выводит соответствующее сообщение. В этом случае счётчик `gCounter` сбрасывается в ноль, и мы готовы снова обнаружить кликера.

Вы можете запустить скрипты `ActionSequenceProtection.au3` и `RandomDelayBot.au3` для тестирования нашего алгоритма. Теперь бот успешно обнаруживается.

Очевидно, что рассмотренный алгоритм защиты может ошибиться. Например, он примет игрока за бота, если тот трижды повторит одни и те же действия. Вероятность ошибки можно уменьшить, если мы увеличим пороговое значение для счётчика `$gCounter` в следующем условии:
```AutoIt
        if $gCounter = 3 then
            MsgBox(0, "Alert", "Clicker bot detected!")
            Reset()
        endif
```
У рассмотренного выше скрипта защиты `ActionSequenceProtection.au3` есть другой серьёзный недостаток. Он способен обнаружить только бота, который запрограммирован на последовательность нажатий "a", "b", "c". Если кликер изменит эту последовательность на "a", "c", "b", то алгоритм не сможет его обнаружить.

Мы можем обойти это ограничение, если немного изменим наш защитный алгоритм. Вместо проверки нажатий клавиш "на лету", он может записывать их в один большой файл. Когда этот файл достигает максимально допустимого размера, скрипт может читать его и проверять на наличие часто повторяющихся последовательностей действий. Если они встречаются, это может быть сигналом о том, что работает бот.

Изменим нашего бота согласно листингу 2-34. Теперь он обходит защиту `ActionSequenceProtection.au3`.

**Листинг 2-34.** *Скрипт `RandomActionBot.au3`*
```AutoIt
SRandom(@MSEC)

$hWnd = WinGetHandle("[CLASS:Notepad]")
WinActivate($hWnd)
Sleep(200)

while true
    Send("a")
    Sleep(1000)

    if Random(0, 9, 1) < 5 then
        Send("b")
        Sleep(2000)
    endif

    Send("c")
    Sleep(1500)
wend
```
Теперь симулируемая ботом последовательной действий случайна. Он нажимает клавишу "b" после "a" с вероятностью порядка 50%. Это приводит к тому, что условия функции `AnalyzeKey` на обнаружение бота перестают выполняться. Каждый раз, когда бот пропускает "b", алгоритм защиты сбрасывает счётчик `gCounter` в ноль. Таким образом, он никогда не достигает порогового значения.




