# Перехват пакетов

Мы рассмотрели протоколы, используемые в сети Интернет. Теперь познакомимся с методом перехвата трафика двух взаимодейтсвующих приложений, работающих на разных хостах. Анализ трафика игрового приложения - первый шаг при разработке внеигрового бота.

## Тестовое приложение

Для начала напишем простое приложение, которое передаёт по сети несколько байт. Оно состоит из двух частей: клиент и сервер. Благодаря loopback интерфейсу мы можем запустить их на одном компьютере и сымитировать передачу данных по сети. С помощью Wireshark перехватим трафик приложения.

Когда речь зашла о реализации сетевого приложения, важно рассмотреть ресурс операционной системы известный как [**сетевой сокет**](https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D0%BA%D0%B5%D1%82_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%BD%D1%8B%D0%B9_%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81)) (network socket). Как вы помните, порты отправителя и получателя указаны в заголовках протоколов TCP и UDP. Благодаря им, ОС доставляет пакет тому процессу, который его ожидает.

Предположим, что вы запускаете игровой клиент и чат-программу на своём компьютере. Что случится если оба приложения решат использовать один и тот же сетевой порт для связи со своими серверами? В теории, каждая программа может выбрать порт по своему умотрению. Чтобы предотвратить конфликты выбора портов, можно предложить зарезервировать некоторые порты для широко распространённых приложений. Это решение [уже существует](https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%D0%BF%D0%BE%D1%80%D1%82%D0%BE%D0%B2_TCP_%D0%B8_UDP). Порты с 0 по 1023 офицально зарезервированы для определённых целей (например, 80 - только для HTTP трафика). Вы не должны использовать их в своих приложениях. Доступные для использования порты находятся в диапазоне от 1024 до 65535.

Очевидно, что кто-то должен контролировать использование портов запущенными приложениями. Эту функцию выполняет ОС. Когда процесс хочет воспользоваться конкретным портом, он запрашивает у ОС сетевой сокет. Сокет - это абстрактный объект, представляющий собой конечную точку соединения. Этот объект содержит следующую информацию: IP-адрес, номер порта, состояние соединения. Как правило, приложение владеет сокетом и использует его монопольно. Когда он становится ненужен, его освобождают (release).

Для разных комбинаций протоколов нужны разные виды сокетов. Мы рассмотрим их далее, когда будем применять в наших примерах.

Наше первое приложение отправляет один пакет данных по протоколу TCP. Оно состоит из двух Python скриптов: `TestTcpReceiver.py` (см листинг 4-1) и `TestTcpSender.py` (см листинг 4-2). Алгоритм их работы следующий:

1. Скрипт `TestTcpReceiver.py` запускается первый. Он создаёт TCP сокет, привязанный (bind) к порту 24000 и IP-адресу 127.0.0.1, известному как localhost (локальный хост). Такая конфигурация известна как **TCP сокет сервера**.

2. Скрипт `TestTcpReceiver.py` запускает цикл ожидания входящего пакета через открытый им сокет. Говорят, что скрипт **слушает** (listen) порт 24000 в ожидании подключения.

3. Запускается скрипт `TestTcpSender.py`. Он открывает TCP сокет, но не привязывает его к какому-либо порту или IP-адресу. Такая конфигурация называется **TCP сокет клиента**.

4. Скрипт `TestTcpSender.py` подключается к сокету получателя по IP-адресу 127.0.0.1 и порту 24000. После этого он отправляет пакет данных. ОС самостоятельно выбирает IP-адрес и порт отправителя, т.е. скрипт `TestTcpSender.py` не может выбрать их по своему усмотрению. После отправки пакета, скрипт освобождает свой сокет.

5. Скрипт `TestTcpReceiver.py` принимает входящее подключение от отправителя, получает пакет данных, выводит их в консоль и освобождает свой сокет.

Рассмотренный нами алгоритм выглядит простым и прямолинейным. Однако, некоторые шаги по установке и разрыву TCP соединения скрыты от пользователя и выполняются ОС автоматически. Мы увидим их, если перехватим и просмотрим трафик приложения в Wireshark.

**Листинг 4-1.** *Скрипт `TestTcpReceiver.py`*
```Python
import socket

def main():
  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)
  s.bind(("127.0.0.1", 24000))
  s.listen(1)
  conn, addr = s.accept()
  data = conn.recv(1024, socket.MSG_WAITALL)
  print(data)
  s.close()

if __name__ == '__main__':
  main()
```
Скрипт `TestTcpReceiver.py` использует модуль `socket`, который предоставляет доступ к сокетам ОС. Алгоритм скрипта реализован в функции `main`. Рассмотрим её подробнее.

Первое действие - вызов функции `socket` модуля `socket`. Она создаёт новый объект для сокета. У функции есть три входных параметра:

* Набор протоколов, который будет использован при создании соединения. Наиболее часто используемые варианты: `AF_INET` (IPv4), `AF_INET6` (IPv6), `AF_UNIX` (локальное соединение)

* Тип сокета: `SOCK_STREAM` (TCP), `SOCK_DGRAM` (UDP), or
`SOCK_RAW` (без указания протокола транспортного уровня).

* Номер протокола используется, когда для указанного набора протоколов и типа сокета возможны несколько вариантов. В большинстве случаев этот параметр равен 0.

Мы создали сокет, который использует протоколы IPv4 и TCP. Следующий шаг нашего скрипта - привязать сокет к конкретному IP-адресу и порту с помощью вызова `bind`. Затем с помощью функции `listen` запускаем цикл ожидания входящего соединения. Единственный входной параметр этой функции определяет максимально число попыток установить соединение. В этой точке скрипт `TestTcpReceiver.py` останавливает своё выполнение, потому что вызов `listen` не возвращает управление пока не будет установлено соединение.
