# Перехват пакетов

Мы рассмотрели протоколы, используемые в сети Интернет. Теперь познакомимся с методом перехвата трафика двух взаимодейтсвующих приложений, работающих на разных хостах. Анализ трафика игрового приложения - первый шаг при разработке внеигрового бота.

## Тестовое приложение

Для начала напишем простое приложение, которое передаёт по сети несколько байт. Оно состоит из двух частей: клиент и сервер. Благодаря loopback интерфейсу мы можем запустить их на одном компьютере и сымитировать передачу данных по сети. С помощью Wireshark перехватим трафик приложения.

Когда речь зашла о реализации сетевого приложения, важно рассмотреть ресурс операционной системы известный как [**сетевой сокет**](https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D0%BA%D0%B5%D1%82_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%BD%D1%8B%D0%B9_%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81)) (network socket). Как вы помните, порты отправителя и получателя указаны в заголовках протоколов TCP и UDP. Благодаря им, ОС доставляет пакет тому процессу, который его ожидает.

Предположим, что вы запускаете игровой клиент и чат-программу на своём компьютере. Что случится если оба приложения решат использовать один и тот же сетевой порт для связи со своими серверами? В теории, каждая программа может выбрать порт по своему умотрению. Чтобы предотвратить конфликты выбора портов, можно предложить зарезервировать некоторые порты для широко распространённых приложений. Это решение [уже существует](https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%D0%BF%D0%BE%D1%80%D1%82%D0%BE%D0%B2_TCP_%D0%B8_UDP). Порты с 0 по 1023 офицально зарезервированы для определённых целей (например, 80 - только для HTTP трафика). Вы не должны использовать их в своих приложениях. Доступные для использования порты находятся в диапазоне от 1024 до 65535.

Очевидно, что кто-то должен контролировать использование портов запущенными приложениями. Эту функцию выполняет ОС. Когда процесс хочет воспользоваться конкретным портом, он запрашивает у ОС сетевой сокет. Сокет - это абстрактный объект, представляющий собой конечную точку соединения. Этот объект содержит следующую информацию: IP-адрес, номер порта, состояние соединения. Как правило, приложение владеет сокетом и использует его монопольно. Когда он становится ненужен, его освобождают (release).

Для разных комбинаций протоколов нужны разные виды сокетов. Мы рассмотрим их далее, когда будем применять в наших примерах.

Наше первое приложение отправляет один пакет данных по протоколу TCP. Оно состоит из двух Python скриптов: `TestTcpReceiver.py` (см листинг 4-1) и `TestTcpSender.py` (см листинг 4-2). Алгоритм их работы следующий:

1. Скрипт `TestTcpReceiver.py` запускается первый. Он создаёт TCP сокет, привязанный (bind) к порту 24000 и IP-адресу 127.0.0.1, известному как localhost (локальный хост). Такая конфигурация известна как **TCP сокет сервера**.

2. Скрипт `TestTcpReceiver.py` запускает цикл ожидания входящего пакета через открытый им сокет. Говорят, что скрипт **слушает** (listen) порт 24000 в ожидании подключения.

3. Запускается скрипт `TestTcpSender.py`. Он открывает TCP сокет, но не привязывает его к какому-либо порту или IP-адресу. Такая конфигурация называется **TCP сокет клиента**.

4. Скрипт `TestTcpSender.py` подключается к сокету получателя по IP-адресу 127.0.0.1 и порту 24000. После этого он отправляет пакет данных. ОС самостоятельно выбирает IP-адрес и порт отправителя, т.е. скрипт `TestTcpSender.py` не может выбрать их по своему усмотрению. После отправки пакета, скрипт освобождает свой сокет.

5. Скрипт `TestTcpReceiver.py` принимает входящее подключение от отправителя, получает пакет данных, выводит их в консоль и освобождает свой сокет.

Рассмотренный нами алгоритм выглядит простым и прямолинейным. Однако, некоторые шаги по установке и разрыву TCP соединения скрыты от пользователя и выполняются ОС автоматически. Мы увидим их, если перехватим и просмотрим трафик приложения в Wireshark.

**Листинг 4-1.** *Скрипт `TestTcpReceiver.py`*
```Python
import socket

def main():
  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)
  s.bind(("127.0.0.1", 24000))
  s.listen(1)
  conn, addr = s.accept()
  data = conn.recv(1024, socket.MSG_WAITALL)
  print(data)
  s.close()

if __name__ == '__main__':
  main()
```
Скрипт `TestTcpReceiver.py` использует модуль `socket`, который предоставляет доступ к сокетам ОС. Алгоритм скрипта реализован в функции `main`. Рассмотрим её подробнее.

Первое действие - вызов функции `socket` модуля `socket`. Она создаёт новый объект для сокета. У функции есть три входных параметра:

* Набор протоколов, который будет использован при создании соединения. Наиболее часто используемые варианты: `AF_INET` (IPv4), `AF_INET6` (IPv6), `AF_UNIX` (локальное соединение)

* Тип сокета: `SOCK_STREAM` (TCP), `SOCK_DGRAM` (UDP), or
`SOCK_RAW` (без указания протокола транспортного уровня).

* Номер протокола используется, когда для указанного набора протоколов и типа сокета возможны несколько вариантов. В большинстве случаев этот параметр равен 0.

Мы создали сокет, который использует протоколы IPv4 и TCP, и поместили его в переменную с именем `s`. Следующий шаг нашего скрипта - привязать сокет к конкретному IP-адресу и порту с помощью метода `bind` объекта `s`. Затем с помощью метода `listen` запускаем цикл ожидания входящего соединения. Единственный входной параметр `listen` определяет максимально число попыток установить соединение. В этой точке скрипт `TestTcpReceiver.py` останавливает своё выполнение, потому что вызов `listen` не возвращает управление пока не будет установлено соединение.

Когда скрипт `TestTcpSender.py` пытается установить соединение, `TestTcpReceiver.py` принимает его через вызов метода `accept`. Этот метод возвращает два значения: объект соединения, пару IP-адрес и порт отправителя. Мы сохраняем их в переменные `conn` и `addr` соответственно. Для чтения данных из принятого пакета мы вызываем метод `recv` объекта `conn`. Затем печатаем их на консоль с помощью функции `print`.

Последний шаг функции `main` - освобождение сокета через вызов метода `close` его объекта. После этого ОС помечает ресурс, как свободный. Теперь другое приложение может слушать TCP порт 24000.

Листинг 4-2 демонстрирует реализацию скрипта `TestTcpSender.py`.

**Листинг 4-2.** *Скрипт `TestTcpSender.py`*
```Python
import socket

def main():
  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)
  s.settimeout(2)
  s.connect(("127.0.0.1", 24000))
  s.send(bytes([44, 55, 66]))
  s.close()

if __name__ == '__main__':
  main()
```
Здесь мы создаём такой же объект `s` для сокета, использующего протоколы IPv4 и TCP. Затем через метод `settimeout` устанавливаем двухсекундный таймаут на все операции с сокетом. Если сервер не ответит в течении этоо времени на любой запрос клиента, будет сгенерировано исключение. Оно никак не обрабатывается в нашем скрипте, поэтому просто приведёт к его завершению.

Следующий шаг - установка соединения через вызов `connect` метода. Его единственный входной параметр - это пара IP-адрес и порт сервера. В Python для объединения двух значений в пару используются круглые скобки. Метод `connect` возвращает управление сразу после успешной установки соединения. После этого мы готовы к отправке пакета с данными. Для этого вызываем метод `send`. В примере отправляются три байта со значениями: 44, 55, 66. В конце функции `main` освобождаем сокет.

Перед запуском примера, необходимо проверить IP-адрес вашего интерфейа loopback. Для этог овыполните следующие шаги:

1. Откройте окно "Network Connections" (сетевые подключения).

2. Правый щелчок мыши по иконке "Microsoft Loopback Adapter" откройте всплывающее меню и выберите пункт "Status" (состояние).

3. Нажмите кнопку "Details..." (сведения). Откроется окно “Network Connection Details” (сведения о сетевом подключении), в котором указан IPv4 адрес.

Если этот адрес отличается от 127.0.0.1, добавьте его в оба скрипта. В `TestTcpReceiver.py` нужно поправить вызов метода `bind`, а в `TestTcpSender.py` - вызов `connect`.

Будет лучше запускать наш пример в командной строке. Тогда вы сможете прочитать выводы скриптов в консоль Если вы запустите скрипт получатель (`TestTcpReceiver.py`) первым, а отправителя (`TestTcpSender.py`) - вторым, получатель напечатает в консоль три байта, переданных через интерфейс loopback.

## Перехват пакета

Перехватим и проанализируем трафик нашего тестового с помощью Wireshark. Для этого выполните следующие действия:

1. Запустите Wireshark. В главном окне анализатора будет отображён список сетевых интерфейсов, как на иллюстрации 4-5.

![Окно Wireshark](Figure_4-5.png)

**Иллюстрация 4-5.** *Список активных сетевых интерфейсов в окне Wireshark*

2. Двойным щелчком левой кнопки мыши выберите loopback интерфейс в списке. Его имя вы можете уточнить в окне "Network Connections" (сетевые подключения). После выбора интерфейса, Wireshark сразу начнёт перехватывать проходящие через него пакеты.

3. Запустите скрипт `TestTcpReceiver.py`.

4. Запустите скрипт `TestTcpSender.py`.

В окне Wireshark вы увидите список перехваченных пакетов, как на иллюстрации 4-6.

![Пакеты тестового приложения](Figure_4-6.png)

**Иллюстрация 4-6.** *Перехваченные пакеты тестового приложения*

Как правило, вы перехватываете трафик на сетевом интерфейсе, чтобы отследить работу одного конкретного приложения. К сожалению, этим интерфейсом в то же самое время могут пользоваться компоненты ОС (например менеджер обновлений) и другие приложения (например веб-браузер). Их пакеты также попадут в список перехваченных Wireshark. Чтобы отобразить только интересующие вас пакеты, анализатор предоставляет возможность фильтрации.

Под панелью иконок находится строка для ввода текста. Когда она пустая, в ней написано "Apply a display filter ..." (применить фильтр отображения). В эту строку вы можете вводить правила фильтрации пакетов. Чтобы применить правила, нажмите иконку в виде стрелки слева от кнопки "Expression..." (выражение). После этого в списке перехваченных пакетов отобразятся только те, которые удовлетворяют условиям фильтрации.

Чтобы отобразить только пакеты нашего тестового приложения, применим следуюий фильтр:
```
tcp and ip.addr==127.0.0.1 and tcp.port==24000
```
Этот фильтр состоит из трёх условий. Первое из них представляет собой единственное слово "tcp". Это означает, что отображать следует только пакеты, использующие TCP протокол. Второе условие "ip.addr==127.0.0.1" проверяет IP-адрес отправителя и получателя. Если один из них равен 127.0.0.1, пакет попадёт в список для отображения. Последнее условие "tcp.port==24000" ограничивает TCP порты отправителя и получателя. Пакете будет отображён, только если в нём упоминается порт 24000.

Для комбинации правил в единый фильтр используется служебное слово "and" (И). Оно означает, что буду отображаться пакеты, для которых выполняются все три условия одновременно. Иначе пакет будет отфильтрован. Другие часто используемые служебные слова: "or" (ИЛИ) и "not" (НЕ). Первое означает, что пакет будет отображён если одно из указанных условий выполнено. Второе слово инвертирует условие. Подробнее они рассмотрены в [офицальной документации](https://www.wireshark.org/docs/wsug_html_chunked/ChWorkBuildDisplayFilterSection.html).

Указывать правила для фильтрации пакетов можно двумя способами: набирать текст правил в поле ввода (как мы сделали ранее) либо использовать диалог "Display Filter Expression" (фильтр отображения), приведённый на иллюстрации 4-7. Чтобы открыть этот диалог, нажмите кнопку "Expression...".

![Диалог "Display Filter Expression"](Figure_4-7.png)

**Иллюстрация 4-7.** *Диалог "Display Filter Expression"*

В левой части диалога находится список "Field Name" (название поля) всех поддерживаемых протоколов и полей их заголовков. В списке "Relation" (отношение) приведены операторы отношения, с помощью которых вы можете накладывать ограничения на значения полей. Под ним находится поле ввода "Value" (значение), в котором указывается значение для сравнения. В нижнеый части диалога находится поле с составленным правилом фильтрации, представленным в текстовой форме. На иллюстрации 4-7 это поле подсвечено зелёным цветом. Если в правиле ошибка, цвет поменяется на красный.

Механизм фильтрации - это мощный инструмент, помогающий анализировать лог файлы с перехваченным трафиком. Используйте его как можно чаще, чтобы ускорить свою работу с Wireshark.

Вернёмся к перехваченным пакетам нашего тестового приложения на иллюстрации 4-6. Почему в списке перехваченных оказалось восемь пакетов, хотя наше приложение посылает только один? Передача данных происходит только в пакете номер 13. Пакеты, переданные до него (с номерами 10, 11, 12), нужны чтобы установить TCP соединение. Этот процесс известен, как **тройное рукопожатие** (three-way handshake). Он состоит из следующих шагов:

1. Клиент (скрипт `TestTcpSender.py`) отправляет первый пакет (номер 10) на сервер. В TCP заголовке этого пакета установлен флаг SYN, а sequence number или seq (порядковый номер) равен 0. Это означает, что клиент хочет установить соединение. Следующий фильтр, отобразит в окне Wireshark только SYN пакеты:
```
tcp.flags.syn==1 and tcp.seq==0 and tcp.ack==0
```

2. Сервер (скрипт `TestTcpReceiver.py`) отвечает пакетом (номер 11), в котором установлены флаги SYN и ACK. Кроме них в пакете передаётся acknowledgment number или ack (номер подтверждения), равный seq, полученный от клиента, плюс один. Также сервер передаёт клиенту собственный seq, равный 0.



