# Перехват пакетов

Мы рассмотрели протоколы, используемые в сети Интернет. Теперь познакомимся с методом перехвата трафика двух взаимодейтсвующих приложений, работающих на разных хостах. Анализ трафика игрового приложения - первый шаг при разработке внеигрового бота.

## Тестовое приложение

Для начала напишем простое приложение, которое передаёт по сети несколько байт. Оно состоит из двух частей: клиент и сервер. Благодаря loopback интерфейсу мы можем запустить их на одном компьютере и сымитировать передачу данных по сети. С помощью Wireshark перехватим трафик приложения.

Когда речь зашла о реализации сетевого приложения, важно рассмотреть ресурс операционной системы известный как [**сетевой сокет**](https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D0%BA%D0%B5%D1%82_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%BD%D1%8B%D0%B9_%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81)) (network socket). Как вы помните, порты отправителя и получателя указаны в заголовках протоколов TCP и UDP. Благодаря им, ОС доставляет пакет тому процессу, который его ожидает.

Предположим, что вы запускаете игровой клиент и чат-программу на своём компьютере. Что случится если оба приложения решат использовать один и тот же сетевой порт для связи со своими серверами? В теории, каждая программа может выбрать порт по своему умотрению. Чтобы предотвратить конфликты выбора портов, можно предложить зарезервировать некоторые порты для широко распространённых приложений. Это решение [уже существует](https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%D0%BF%D0%BE%D1%80%D1%82%D0%BE%D0%B2_TCP_%D0%B8_UDP). Порты с 0 по 1023 офицально зарезервированы для определённых целей (например, 80 - только для HTTP трафика). Вы не должны использовать их в своих приложениях. Доступные для использования порты находятся в диапазоне от 1024 до 65535.

Очевидно, что кто-то должен контролировать использование портов запущенными приложениями. Эту функцию выполняет ОС. Когда процесс хочет воспользоваться конкретным портом, он запрашивает у ОС сетевой сокет. Сокет - это абстрактный объект, представляющий собой конечную точку соединения. Этот объект содержит следующую информацию: IP-адрес, номер порта, состояние соединения. Как правило, приложение владеет сокетом и использует его монопольно. Когда он становится ненужен, его освобождают (release).

Для разных комбинаций протоколов нужны разные виды сокетов. Мы рассмотрим их далее, когда будем применять в наших примерах.

Наше первое приложение отправляет один пакет данных по протоколу TCP. Оно состоит из двух Python скриптов: `TestTcpReceiver.py` (см листинг 4-1) и `TestTcpSender.py` (см листинг 4-2). Алгоритм их работы следующий:

1. Скрипт `TestTcpReceiver.py` запускается первый. Он создаёт TCP сокет, привязанный (bind) к порту 24000 и IP-адресу 127.0.0.1, известному как localhost (локальный хост). Такая конфигурация известна как **TCP сокет сервера**.

2. Скрипт `TestTcpReceiver.py` запускает цикл ожидания входящего пакета через открытый им сокет. Говорят, что скрипт **слушает** (listen) порт 24000 в ожидании подключения.

3. Запускается скрипт `TestTcpSender.py`. Он открывает TCP сокет, но не привязывает его к какому-либо порту или IP-адресу. Такая конфигурация называется **TCP сокет клиента**.

4. Скрипт `TestTcpSender.py` подключается к сокету получателя по IP-адресу 127.0.0.1 и порту 24000. После этого он отправляет пакет данных. ОС самостоятельно выбирает IP-адрес и порт отправителя, т.е. скрипт `TestTcpSender.py` не может выбрать их по своему усмотрению. После отправки пакета, скрипт освобождает свой сокет.

5. Скрипт `TestTcpReceiver.py` принимает входящее подключение от отправителя, получает пакет данных, выводит их в консоль и освобождает свой сокет.

Рассмотренный нами алгоритм выглядит простым и прямолинейным. Однако, некоторые шаги по установке и разрыву TCP соединения скрыты от пользователя и выполняются ОС автоматически. Мы увидим их, если перехватим и просмотрим трафик приложения в Wireshark.

**Листинг 4-1.** *Скрипт `TestTcpReceiver.py`*
```Python
import socket

def main():
  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)
  s.bind(("127.0.0.1", 24000))
  s.listen(1)
  conn, addr = s.accept()
  data = conn.recv(1024, socket.MSG_WAITALL)
  print(data)
  s.close()

if __name__ == '__main__':
  main()
```
Скрипт `TestTcpReceiver.py` использует модуль `socket`, который предоставляет доступ к сокетам ОС. Алгоритм скрипта реализован в функции `main`. Рассмотрим её подробнее.

Первое действие - вызов функции `socket` модуля `socket`. Она создаёт новый объект для сокета. У функции есть три входных параметра:

* Набор протоколов, который будет использован при создании соединения. Наиболее часто используемые варианты: `AF_INET` (IPv4), `AF_INET6` (IPv6), `AF_UNIX` (локальное соединение)

* Тип сокета: `SOCK_STREAM` (TCP), `SOCK_DGRAM` (UDP), or
`SOCK_RAW` (без указания протокола транспортного уровня).

* Номер протокола используется, когда для указанного набора протоколов и типа сокета возможны несколько вариантов. В большинстве случаев этот параметр равен 0.

Мы создали сокет, который использует протоколы IPv4 и TCP, и поместили его в переменную с именем `s`. Следующий шаг нашего скрипта - привязать сокет к конкретному IP-адресу и порту с помощью метода `bind` объекта `s`. Затем с помощью метода `listen` запускаем цикл ожидания входящего соединения. Единственный входной параметр `listen` определяет максимально число попыток установить соединение. В этой точке скрипт `TestTcpReceiver.py` останавливает своё выполнение, потому что вызов `listen` не возвращает управление пока не будет установлено соединение.

Когда скрипт `TestTcpSender.py` пытается установить соединение, `TestTcpReceiver.py` принимает его через вызов метода `accept`. Этот метод возвращает два значения: объект соединения, пару IP-адрес и порт отправителя. Мы сохраняем их в переменные `conn` и `addr` соответственно. Для чтения данных из принятого пакета мы вызываем метод `recv` объекта `conn`. Затем печатаем их на консоль с помощью функции `print`.

Последний шаг функции `main` - освобождение сокета через вызов метода `close` его объекта. После этого ОС помечает ресурс, как свободный. Теперь другое приложение может слушать TCP порт 24000.

Листинг 4-2 демонстрирует реализацию скрипта `TestTcpSender.py`.

**Листинг 4-2.** *Скрипт `TestTcpSender.py`*
```Python
import socket

def main():
  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)
  s.settimeout(2)
  s.connect(("127.0.0.1", 24000))
  s.send(bytes([44, 55, 66]))
  s.close()

if __name__ == '__main__':
  main()
```
Здесь мы создаём такой же объект `s` для сокета, использующего протоколы IPv4 и TCP. Затем через метод `settimeout` устанавливаем двухсекундный таймаут на все операции с сокетом. Если сервер не ответит в течении этоо времени на любой запрос клиента, будет сгенерировано исключение. Оно никак не обрабатывается в нашем скрипте, поэтому просто приведёт к его завершению.

Следующий шаг - установка соединения через вызов `connect` метода. Его единственный входной параметр - это пара IP-адрес и порт сервера. В Python для объединения двух значений в пару используются круглые скобки. Метод `connect` возвращает управление сразу после успешной установки соединения. После этого мы готовы к отправке пакета с данными. Для этого вызываем метод `send`. В примере отправляются три байта со значениями: 44, 55, 66. В конце функции `main` освобождаем сокет.

Перед запуском примера, необходимо проверить IP-адрес вашего интерфейа loopback. Для этог овыполните следующие шаги:

1. Откройте окно "Network Connections" (сетевые подключения).

2. Правый щелчок мыши по иконке "Microsoft Loopback Adapter" откройте всплывающее меню и выберите пункт "Status" (состояние).

3. Нажмите кнопку "Details..." (сведения). Откроется окно “Network Connection Details” (сведения о сетевом подключении), в котором указан IPv4 адрес.

Если этот адрес отличается от 127.0.0.1, добавьте его в оба скрипта. В `TestTcpReceiver.py` нужно поправить вызов метода `bind`, а в `TestTcpSender.py` - вызов `connect`.

Будет лучше запускать наш пример в командной строке. Тогда вы сможете прочитать выводы скриптов в консоль Если вы запустите скрипт получатель (`TestTcpReceiver.py`) первым, а отправителя (`TestTcpSender.py`) - вторым, получатель напечатает в консоль три байта, переданных через интерфейс loopback.

## Перехват пакета

Перехватим и проанализируем трафик нашего тестового с помощью Wireshark. Для этого выполните следующие действия:

1. Запустите Wireshark. В главном окне анализатора будет отображён список сетевых интерфейсов, как на иллюстрации 4-5.

![Окно Wireshark](Figure_4-5.png)

**Иллюстрация 4-5.** *Список активных сетевых интерфейсов в окне Wireshark*

2. Двойным щелчком левой кнопки мыши выберите loopback интерфейс в списке. Его имя вы можете уточнить в окне "Network Connections" (сетевые подключения). После выбора интерфейса, Wireshark сразу начнёт перехватывать проходящие через него пакеты.

3. Запустите скрипт `TestTcpReceiver.py`.

4. Запустите скрипт `TestTcpSender.py`.

В окне Wireshark вы увидите список перехваченных пакетов, как на иллюстрации 4-6.

![Пакеты тестового приложения](Figure_4-6.png)

**Иллюстрация 4-6.** *Перехваченные пакеты тестового приложения*

