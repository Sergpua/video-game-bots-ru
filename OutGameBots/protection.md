# Методы защиты от внеигровых ботов

Мы разработали бота для NetChess. Это простое приложение для игры в шахматы двух пользователей по локальной сети. Современные онлайн игры насчитывают тысячи пользователей, которые подключаются к серверу через Интернет. Несмотря на эти различия, разработка внеигровых ботов в обоих случаях пойдёт по одному и тому же плану. Прежде всего необходимо изучить протокол взаимодействия игрового клиента и сервера.

У приложения NetChess нет никакой защиты от реверс-инжиниринга и внеигровых ботов. Именно по этой причине нам так быстро удалось понять его протокол. Если вы попробуйте проделать то же самое с современной онлайн игрой, возникнут затруднения. Скорее всего, вы не сможете так просто установить соответствие между действиями игрока и данными в перехваченных пакетах. Одни и те же действия меняют байты по разным смещениям без какой-либо закономерности. Если вы столкнулись с подобным поведением, значит игра имеет систему защиты. Самый надёжный и широко применяемый подход для защиты трафика приложения - это шифрование.

В главе 3 мы рассмотрели два алгоритма шифрования применительно к защите памяти приложения. Теперь рассмотрим, как применить эти и другие алгоритмы к сетевому трафику.

## Криптосистема

Перед тем, как перейти к практическим примерами, рассмотрим понятие [**криптосистемы**](https://ru.wikipedia.org/wiki/Криптосистема). Криптосистема - это набор криптографических алгоритмов для обеспечения конфиденциальности информации. Как правило, криптосистема имеет три алгоритма для следующих целей:

1. Генерация ключа шифрования.

2. Шифрование.

3. Дешифрование.

Термин [**шифр**](https://ru.wikipedia.org/wiki/Шифр) относится только к алгоритмам шифрования и дешифрования. Первый же из алгоритмов в списке использется для создания [**секретного ключа**](https://ru.wikipedia.org/wiki/Ключ_(криптография)), который удовлетворяет требованиям шифра.

Как работает шифрование? Предположим, что у нас есть некотоаря информация (например сообщение), которое мы хотим защитить от несанкционированного чтения. Эта информация называется [**открытый текст**](https://ru.wikipedia.org/wiki/Открытый_текст) (plaintext). Открытый текст вместе с секретным ключом передаётся алгоритму шифрования. После отработки алгоритм выдаст информацию в зашифрованном виде или [**шифротекст**](https://ru.wikipedia.org/wiki/Шифротекст). Чтобы снова получить открытый текст, необходимо передать шифротекст и ключ в алгоритм дешифрования. Это значит, что исходное сообщение смогут прочитать только те получатели, которые знают ключ и алгоритм шифрования.

Мы рассмотрели работу типичной криптосистемы в общих чертах. В реальных системах могут быть дополнительные шаги шифрования и дешифрования, а также возможности управления ключами.

## Тестовое приложение

Для демонстрации алгоритмов шифрования воспользуемся простым приложением, которое передаёт текстовое сообщение по протоколу UDP. Мы использовали это приложение в разделе "Перехват трафика" (см. листинги 4-3 и 4-4). Немного изменим скрипт отправителя, чтобы вместо трёх байт отправлялась строка "Hello world!".

**Листинг 4-7.** *Скрипт `TestStringUdpSender.py`*
```Python
import socket

def main():
  s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, 0)
  s.bind(("127.0.0.1", 24001))
  data = bytes("Hello world!", "utf-8")
  s.sendto(data, ("127.0.0.1", 24000))
  s.close()

if __name__
  main()
```
Скрипт отправляет строку, хранящуюся в переменной `data`. Это байтовый массив, в котором каждой букве соответствует один байт (ASCII кодировка). Чтобы получить этот массив из исходной строки в кодировке UTF-8, используется функция `bytes`.

Запустите срипт `TestUdpReceiver.py` из листинга 4-3 и `TestStringUdpSender.py`. Когда получатели примет сообщение, он выведет на консоль текст:
```
b'Hello world!'
```
Символ "b" в начале строки означает, что строка хранится в памяти в виде байтового массива.

Иллюстрация 4-22 демонстрирует перехваченный пакет тестового приложения.

![Перехваченный пакет](Figure_4-22.png)

**Иллюстрация 4-22.** *Перехваченный пакет тестового приложения*

Wireshark корректно декодировал строку "Hello world!". Мы можем её прочитать в нижней части окна анализатора в области байтового представления пакета.

## XOR шифр

Одна из простейших криптосистем - шифр XOR. Мы применяли его в главе 3 для сокрытия данных процесса от сканеров памяти. Теперь воспользуемся им для шифрования сетевого пакета.

Библиотека PyCrypto предоставляет шифр XOR. Мы можем воспользоваться уже готовой реализацией и не писать алгоритм самостоятельно.

---
В библиотеки PyCryptodome нет реализации шифра XOR. Если вы установили её, а не PyCrypto, вы не сможете запустить следующие примеры из листингов 4-8, 4-9, 4-10 и 4-11.
---

Листинг 4-8 демонстрирует использование шифра XOR, предоставляемого библиотекой PyCrypto.

**Листинг 4-8.** *Скрипт `XorTest.py`*
```Python
from Crypto.Cipher import XOR

def main():
  key = b"The secret key"

  # Encryption
  encryption_suite = XOR.new(key)
  cipher_text = encryption_suite.encrypt(b"Hello world!")
  print(cipher_text)

  # Decryption
  decryption_suite = XOR.new(key)
  plain_text = decryption_suite.decrypt(cipher_text)
  print(plain_text)

if __name__ == '__main__':
  main()
```
Первая строка скрипта импортирует Python модуль `XOR`, в котором реализованы алгоритмы шифра. Чтобы ими воспользоваться, нам надо подготовить секретный ключ. В нашем случае это переменная `key` со строкой "The secret key".

Чтобы зашифровать строку, мы создаем объект `encryption_suite` класса `XORCipher` с помощью функции `new` (вызов `XOR.new`). В качестве параметра она принимает секретный ключ. У созданного объекта есть метод `encrypt`, который применяет шифр к переданному ему открытому тексту в формате байтового массива. Получившийся шифротекст сохраняется в переменной `cipher_text` и выводится на консоль. Этот вывод выглядит следующим образом:
```
b'\x1c\r\tL\x1cE\x14\x1d\x17\x18DJ'
```
Оставшаяся часть функции `main` дешифрует шифротекст в исходный вид. Для этого мы создаём объект `dencryption_suite` точно так же, как и `encryption_suite` ранее. С помощью метода `decrypt` этого объекта мы дешифруем строку `cipher_text`. После этого выводим результат на консоль. Он должен совпасть с исходной строкой "Hello world!".

После внимательного изучения кода листинга 4-8 возникает вопрос. Можно ли использовать один и тот же объект класса `XORCipher` и для шифрования, и для дешифрования? Ответ - нет. Классы библиотеки PyCrypto имеют внутренние состояния, которые зависят от последней выполненной операции. Это означает, что любое действие над ними окажет влияние на последующее. Если вы зашифруете две строки друг за другом с помощью одного объекта, расшифровать их возможно только в той же последовательности. Иначе результат будет ошибочным. Надёжный и правильный способ использовать объекты `XORCipher` - применять их для однократных операций шифрования и дешифрования.

Теперь применим шифр XOR для скриптов отправки и получения UDP пакета нашего тестового приложения. Листинг 4-9 демонстрирует дополненный срипт отправителя.

**Листинг 4-9.** *Скрипт `XorUdpSender.py`*
```Python
import socket
from Crypto.Cipher import XOR

def main():
  s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, 0)
  s.bind(("127.0.0.1", 24001))

  key = b"The secret key"
  encryption_suite = XOR.new(key)
  cipher_text = encryption_suite.encrypt(b"Hello world!")

  s.sendto(cipher_text, ("127.0.0.1", 24000))
  s.close()

if __name__ == '__main__':
  main()
```
В скрипте `XorUdpSender.py` мы шифруем строку "Hello world!" и отправляем её по протоколу UDP.

Скрипт получателя приведён в листинге 4-10.

**Листинг 4-10.** *Скрипт `XorUdpReceiver.py`*
```Python
import socket
from Crypto.Cipher import XOR

def main():
  s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, 0)
  s.bind(("127.0.0.1", 24000))
  data, addr = s.recvfrom(1024, socket.MSG_WAITALL)

  key = b"The secret key"
  decryption_suite = XOR.new(key)
  plain_text = decryption_suite.decrypt(data)
  print(plain_text)

  s.close()

if __name__ == '__main__':
  main()
```
Если вы запустите дополненные скрипты отправителя и получателя, результат будет тем же что и раньше. Скрипт `XorUdpReceiver.py` выведет на консоль полученную строку:
```
b'Hello world!'
```
Однако, если вы перехватите переаднный пакет с помощью Wireshark, вы заметите разницу. Этот пакет приведён на иллюстрации 4-23.

![Пакет зашифрованный XOR](Figure_4-23.png)

**Иллюстрация 4-23.** *Перехваченный пакет, который был зашифрован XOR*

Обратите внимание, что теперь Wireshark не может декодировать строку. Теперь эту операцию надо выполнять вручную, но для этого понадобится секретный ключ.

У вас может возникнуть мысль, что XOR шифр - это хороший вариант для вашего приложения. Он прост в использовании и быстро работает. На самом деле это не так, поскольку этот шифр легко взломать.

В шифре применяется логическая операция [**исключающее "или"**](https://ru.wikipedia.org/wiki/Сложение_по_модулю_2). Предположим, что мы шифруем открытый текст A с помощью секретного ключа K. Тогда мы получим шифротекст B:
```
A ⊕ K = B
```
Если мы применим исключающее "или" к A и B, то получим ключ K:
```
A ⊕ B = K
```
Это означает, что мы можем восстановить секретный ключ, если нам известны открытый текст и шифротекст. Скрипт `XorCrack.py` из листинга 4-11 восстанавливает секретный ключ по этому алгоритму.

**Листинг 4-11.** *Скрипт `XorCrack.py`*
```Python
from Crypto.Cipher import XOR

def main():
  key = b"The secret key"

  # Encryption
  encryption_suite = XOR.new(key)
  cipher_text = encryption_suite.encrypt(b"Hello world!")
  print(cipher_text)

  # Decryption
  decryption_suite = XOR.new(key)
  plain_text = decryption_suite.decrypt(cipher_text)
  print(plain_text)

  # Crack
  crack_suite = XOR.new(plain_text)
  key = crack_suite.encrypt(cipher_text)
  print(key)

if __name__ == '__main__':
  main()
```
При запуске этот скрипт выведет на консоль следующее:
```
b'\x1c\r\tL\x1cE\x14\x1d\x17\x18DJ'
b'Hello world!'
b'The secret k'
```
Первая строка соответствует шифротексту. Далее идёт открытый текст и восстановленный секретный ключ.

Почему скрипт `XorCrack.py` восстановил только часть секретного ключа? В XOR шифре оператор исключающего "или" последовательно применяется к каждой букве открытого текста и соответствующему ей байту ключа. В нашем случае индексы букв текста и байтов ключа совпадают. Если строка текста оказывается короче ключа, оставшаяся его часть не используется. Если же ключ оказался длиннее, то он будет применяться циклично.

Как рассмотренное свойство оператора исключающего "или" поможет нам расшифровать пакет с реальными игровыми данными? В этом случае у нас есть шифротекст. Наша задача - получить открытый текст. Прежде всего, нам необходимо восстановить секретный ключ. Для этого применим в точности ту же криптосистему для шифрования известного нам открытого текста. Тогда нам станет известен шифротекст и соответствующий ему открытый текст. Это позволит нам восстановить ключ.

Предположим, что мы заполняем форму регистрации для онлайн игры. В неё надо указать информацию о новом игроке (имя, пароль, адрес электронной почты). Все эти данные нам известны. После заполнения формы, обычно надо нажать кнопку "отправить". Перехватим пакеты, которые игровое приложение посылает по этому нажатию. Данные пользователя из формы регистрации находятся в этих пакетах. Применим оператор исключающего "или" к этим данным и шифротексту из пакета. Чтобы перепробовать все комбинации, понадобится время, но рано или поздно мы восстановим секретный ключ.

Можно заключить, что у шифра XOR есть положительные стороны, но он не способен обеспечить надёжную защиту для трафика приложений.

## Шифр Triple DES

Следующий шифр, который мы рассмотрим называется [**Triple DES**](https://ru.wikipedia.org/wiki/Triple_DES) (3DES). Для шифрования в нём трижды применяется алгоритм [**DES**](https://ru.wikipedia.org/wiki/DES) (Data Encryption Standard) над открытым текстом. Алгоритм DES был разработан в 1975 году компанией IBM. Сегодня он считается ненадёжным из-за использования коротких секретных ключей длиной 56 бит. Современные компьютеры позволяют перебрать все возможные ключи (количеством 2<sup>56</sup>) такой длины в течении нескольких дней. Алгоритм 3DES решает эту проблему путём увеличения длины ключа в три раза до 168 бит.

Почему необходимо применять алгоритм DES именно три раза? Почему недостаточно двух? В этом случае мы получили бы ключ длиной 112 бит, которого достаточно для современных требований. Ожидается, что этот ключ потребует перебора 2<sup>112</sup> всех возможных комбинаций **атакующим** (лицом взламывающим шифр). Это предположение не верно. Атака под названием [**встреча по середине**](https://ru.wikipedia.org/wiki/Метод_встречи_посередине) (meet-in-the-middle) позволяет сократить число перебираемых вариантов ключей до 2<sup>57</sup>. Этого недостаточно для надёжного шифрования открытого текста. Если же применить алгоритм 3DES, атакующему придётся перебрать 2<sup>112</sup> комбинаций ключей, даже если он применит атаку встреча по середине.

При разработке шифра 3DES учитывалось, насколько удобно будет его применение на специальных чипах. Сегодня по-прежнему эксплуатируется много устройств, выпущенных десять и более лет назад. Они поддерживают алгоритм DES на аппаратном уровне. Достаточно просто настроить эти устройства на использование шифрования 3DES. Обратная совместимость с устаревшими решениями - это основная причина использования 3DES в наши дни. Более современные шифры быстрее и надёжнее.

Обе библиотеки PyCrypto и PyCryptodome предоставляют реализации шифров DES и 3DES. Мы рассмотрим только 3DES алгоритм.

Листинг 4-12 демонстрирует скрипт для шифрования и дешифрования строки с помощью 3DES.

**Листинг 4-12.** *Скрипт `3DesTest.py`*
```Python
from Crypto.Cipher import DES3
from Crypto import Random

def main():
  key = b"The secret key a"
  iv = Random.new().read(DES3.block_size)

  # Encryption
  encryption_suite = DES3.new(key, DES3.MODE_CBC, iv) 
  cipher_text = encryption_suite.encrypt(b"Hello world!    ")
  print(cipher_text)

  # Decryption
  decryption_suite = DES3.new(key, DES3.MODE_CBC, iv)
  plain_text = decryption_suite.decrypt(cipher_text)
  print(plain_text)

if __name__ == '__main__':
  main()
```
В этом скрипте мы импортируем Python модули `DES3` и `Random` библиотеки PyCrypto. Первый из них предоставляет класс DES3Cipher, в котором реализованы алгоритмы шифрования и дешифрования. Модуль `Random` предоставляет генератор случайных последовательностей байтов. Его следует использовать вместо стандартного модуля `random`, распространяемого с интерпретатором Python. Потому что `random` считается небезопасным для целей шифрования.

Зачем нам понадобился массив случайных байтов для алгоритма 3DES? 3DES - это блочный шифр. В нём открытый текст разделяется на блоки, которые последовательно шифруются с помощью секретного ключа. Если мы применим алгоритм в таком виде, шифр будет недостаточно надёжным. Причина в том, что атакующий может найти закономерность между отдельными блоками открытый текст и шифротекста. Тогда он сможет определить содержимое зашифрованных блоков. Чтобы предотвратить эту уязвимость, можно смешать каждый блок открытого текста с предыдущим блоком шифротекста. Этот подход известен как [**сцепление блоков шифротекста**](https://ru.wikipedia.org/wiki/Режим_сцепления_блоков_шифротекста) (Cipher Block Chaining или CBC). Единственная проблема возникает с первым блоком открытого текста. С какими данными следует смешивать его? Этия данные должны генерироваться случайно. Они называются [**вектором инициализации**](https://en.wikipedia.org/wiki/Initialization_vector) (Initialization Vector или IV).


// TODO: Упомянть про теоретическую ненадёжность 3DES:
https://habr.com/ru/post/239287/


