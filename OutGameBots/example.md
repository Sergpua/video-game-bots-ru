# Пример бота для Net Chess

Мы узнали достаточно, чтобы написать простого внеигрового бота. Он будет делать ходы в шахматной программе NetChess. Эта программа состоит клиента и сервера и позволяет играть по локальной сети. Вы можете бесплатно скачать её на сайте [Sourceforge](https://sourceforge.net/projects/avmnetchess). Чтобы установить игру, просто распакуйте архив с ней в любой каталог.

Рассмотрим интерфейс игры. Её главное окно изображено на иллюстрации 4-11. Большую его часть занимает шахматная доска с фигурами на ней. Главное меню находится в верхней части окна. Ряд иконок под меню дублирует часть его функций.

![Окно NetChess](Figure_4-11.png)

**Иллюстрация 4-11.** *Окно NetChess*

Чтобы начать игру, необходимо запустить приложение NetChess и назначить ему роль сервера. После этого второй игрок запускает приложение на другом компьютере в роли клиента. Он подключается к серверу, и игра начинается. Благодаря loopback интерфейсу можно запустить клиент и сервер на одном хосте.

Чтобы запустить NetChess и начать игру выполните следующие действия:

1. Дважды запустите исполняемый файл `NetChess2.1.exe` из каталога `Debug` игры. В результате запустится два процесса NetChess. Выберите из них тот, который будет настроен в роли сервера. Тогда другой будет исполнять роль клиента.

2. Переключитесь на окно сервера и выберите пункт меню "Network" ➤ "Server" ("Сеть" ➤ "Сервер"). Откроется диалог конфигурации приложения в роли сервера, как на иллюстрации 4-12.

![Диалог конфигурации сервера](Figure_4-12.png)

**Иллюстрация 4-12.** *Диалог конфигурации сервера*

3. Введите имя пользователя, который играет на стороне сервера, и нажмите кнопку "OK".

4. Переключитесь на окно приложения NetChess, выполняющее роль клиента. Выберите пнкт меню "Network" ➤ "Client" ("Сеть" ➤ "Клиент"). Откроется диалог конфигурации клиента, как на иллюстрации 4-13.

![Диалог конфигурации клиента](Figure_4-13.png)

**Иллюстрация 4-13.** *Диалог конфигурации клиента*

5. Введите имя пользователя на стороне клиента и IP-адрес сервера (в моём случае это 169.254.144.77). Затем нажмите кнопку "OK".

6. Переключитесь на окно сервера. Когда клиент попытается подключится, должен открыться диалог "Accept" (принять), как на иллюстрации 4-14. В нём вы должны выбрать цвет фигур (чёрный, белый, случайный). После этого нажмите кнопку "Accept" (принять).

![Диалог подключения клиента](Figure_4-14.png)

**Иллюстрация 4-14.** *Диалог подключения клиента*

7. Переключитесь на окно клиента. Вы увидите сообщение об успешном поключении к серверу. В нём выводится имя оппонента и цвет его фигур (см иллюстрацию 4-15).

![Диалог подтверждения подключения](Figure_4-15.png)

**Иллюстрация 4-15.** *Диалог подтверждения подключения*

8. Переключитесь на окно сервера и выберите пункт меню "Edit" ➤ "Manual Edit" ➤ "Start Editing" ("Редактирование" ➤ "Ручное редактирование" ➤ "Начать редактирование"). Откроется диалог с подтверждением в котором вы должны нажать кнопку "Yes" (да). После этого приложение перейдёт в режим, в котором вы сможете запустить игровые часы.

9. Переключитесь на окно клиента и подтвердите включение режима "Manual Edit" в открывшемся диалоге. Для этого нажмите кнопку "Yes".

10. Переключитесь на окно сервера. Вы увидите сообщение, что клиент подтвердил включение режима "Manual Edit". Закройте сообщение нажатием кнопки "OK". Затем уберите галочку с пункта меню "Edit" ➤ "Manual Edit" ➤ "Pause clock" ("Редактирование" ➤ "Ручное редактирование" ➤ "Остановить часы").

Игровые часы запустятся, и белая сторона может сделать первый ход. Чтобы сделать ход достаточно перетащить мышью нужную фигуру на новую клетку доски.

## Обзор бота

Наш внеигровой бот будет подключаться к серверу и полностью замещать собой приложение NetChess, выполняющее роль клиента.

Есть несколько способов, как бот может выбирать свои ходы. Предлагаю остановиться на самом простом решении, поскольку мы рассматриваем взаимодействие с игровым сервером, а не алгоритмы шахматных программ. Наш бот будет зеркально повторять ходы игрока до тех пор, пока это позволяют праивла игры. Задача выглядит достаточно простой, но потребует изучения протокола NetChess.

Проект NetChess распространяется с открытым исходным кодом. Вы можете изучить код и быстро разобраться в протоколе приложения. Мы выберем другой путь. Давайте предположим, что NetChess - проприетарная игра, и её исходный код не доступен. Для исследования у нас есть только перехваченный сетевой трафик между клиентом и сервером.

## Изучение трафика NetChess

Мы рассмотрели шаги, необходимые для установки соединения между клиентом и сервером NetChess, а также чтобы начать игру. Теперь мы можем перехватить трафик и найти сетевые пакеты, соответствующие каждому из этих шагов. Перед этим рассмотрим два важных вопроса.

Как мы будем отличать трафик NetChess от остальных приложений в Wireshark логе? Если бы мы использовали сетевую плату вместо loopback интерфейса, в лог попали бы пакеты всех работающих в данный момент сетевых приложений. Пакеты NetChess мы можем отличить по номеру порта. Мы указали его при настройке серверной части приложения. По-умолчанию он равен 55555. Применим следующее условие на проверку порт в качестве Wireshark фильтра:
```
tcp.port==55555
```
Теперь в логе будет выводиться только трафик NetChess.

Следующий вопрос: как именно следует перехватывать трафик? Самый простой и очевидный путь - запустить Wireshark, начать прослушивать lopback интерфейс и сыграть подряд несколько игр. Поступив так, мы потеряем важную информацию, которая очень пригодилась бы для изучения трафика. В Wireshark логе, собранном по нескольким играм, будет очень сложно различить отдельные ходы каждой стороны. Наример, какой именно пакет соответствует первому ходу белых? В логе десятки пакетов, а мы не можем даже сказать в какой именно момент началась каждая игра. Чтобы избежать этого затруднения, будем проверять Wireshark лог после каждого совершённого действия. В этом случае мы сразу увидим соответствующие ему пакеты.

Теперь запустим Wireshark, NetChess клиент и сервер. Начнём прослушивание loopback интерфейса в анализаторе. После этого выполните следующие действия:

1. Запустите NetChess в режиме сервера (настройка “Network” ➤ “Server”). После этого действия приложение только открывает сокет. Поэтому в логе Wireshark новых пакетов не появится.

2. Подключитесь NetChess клиентом к серверу (настройка “Network” ➤ “Client”). В Wireshark окне появятся три пакета, как на иллюстрации 4-16. Это установка TCP соединения через тройное рукопожатие.

![Установка соединения](Figure_4-16.png)

**Иллюстрация 4-16.** *Установка соединения между NetChess клиентом и сервером*

3. Сервер принимает соединение клиента. После этого анализатор перехватит два пакета, отправленные сервером. На иллюстрации 4-17 их номера 22 и 24. Клиент подтверждает их получение и сам посылает два пакета с данными (с номерами 26 и 28).

Отсановимся в этом месте и рассмотрим пакеты с данными, которыми обмениваются клиент и сервер после установки соединения. Первый пакет от сервера под номером 22 содержит следующие данные:
```
0f 00 00 00
```
Попробуйте перезапустить NetChess клиент и сервер. После этого снова установите соединение между ними. Данные, передаваемые в этом пакете не изменятся. Вероятнее всего, на прикладном уровне модели TCP/IP они означают, что сервер принял соединение клиента. Чтобы проверить это предположение, попробуйте отклонить подключение клиента на сервере. В этом случае данные пакета изменятся на следующие:
```
01 00 00 00
```
Из этого следует, что наше предположение верно. Если первый байт равен 0f, значит соединение принято сервером. Иначе этот байт равен 01.

![Подтверждение подключения](Figure_4-17.png)

**Иллюстрация 4-17.** *Подтверждение подключения NetChess сервером*

Второй пакет от сервера с номером 24 содержит следующие байты данных:
```
0b 02 46 6d e7 5a 73 72 76 5f 75 73 65 72 00
```
Эти байты соответствуют случаю, когда игрок на стороне сервера выбрал белые фигуры и ввёл имя "srv_user". Wireshark способен частично декодировать эти данные. Согласно иллюстрации 4-18, байты с 7-ого по 15-ый соответствуют имени пользователя.

![Декодирование данных](Figure_4-18.png)

**Иллюстрация 4-18.** *Декодирование данных второго пакета от сервера в Wireshark*

Что означают первые шесть байт в ответе сервера? Попробуйте перезапустить NetChess клиент и сервер, чтобы проверить изменяться ли байты в следующий раз. Не забудьте выбрать то же имя пользователя "srv_user" и белые фигуры на стороне сервера. В этом случае уже известные нам байты данных не изменятся.

После перезапуска NetChess, у меня получились следующие данные в пакете:
```
0b 02 99 b3 ee 5a 73 72 76 5f 75 73 65 72 00
```
Обратите внимание, что первые два байта (0b и 02) не изменились. Скорее всего, в них закодирован цвет фигур, который выбрал игрок на стороне сервера. Попробуйте перезапустить NetChess и выбрать черные фигуры. Данные этого пакета поменяются:
```
0b 01 ba 45 e8 5a 73 72 76 5f 75 73 65 72 00
```
Если повторить тест с выбором чёрных фигур несколько раз, второй байт всегда будет равен 01. Это подтверждает наше предположение. Цвет фигур игрока на стороне сервера кодируется согласно таблице 4-2. Исходя из этой информации, наш бот может установить цвет своих фигур.

**Таблица 4-2.** *Кодирование цвета фигур игрока на стороне сервера*

| Байт | Цвет |
| --- | --- |
| 01 | Чёрный |
| 02 | Белый |

Следующие два пакета с данными отправляются клиентом. Первый из низ под номером 26 содержит следующие байты:
```
09 00 00 00
```
Они не изменяться, если мы перезапустим приложение и попробуем поменять имя игрока на стороне сервера или цвет его фигур. Поэтому предположительно эти байты кодируют неизменный ответ клиента.

Следующий пакет под номером 28 содержит следующие данные:
```
0c 63 6c 5f 75 73 65 72 00
```
Wireshark декодирует эти байты, начиная со второго, как имя игрока на стороне клиента (см. иллюстрацию 4-19). Значение первого байта неясно. Оно не меняется после перезапуска приложения. Бот может обращаться с ним, как с константой, и всегда включать в свой ответ серверу.

![Декодирование данных](Figure_4-19.png)

**Иллюстрация 4-19.** *Декодирование данных второго пакета от клиента в Wireshark*

Продолжим действия в приложении NetChess, необходимые для начала игры. Следующий шаг - включение режима "Manual Edit" на стороне сервера ("Edit" ➤ "Manual Edit" ➤ "Start Editing"). После этого действия сервер отправляет два пакета клиенту.

Первый пакет под номером 41 на иллюстрации 4-20 содержит следующие данные:
```
0a 00 00 00
```
Вероятнее всего певрый байт 0a соответствует коду запроса сервера.
Данные второго пакета под номером 43 выглядят так:
```
13 73 72 76 5f 75 73 65 72 00
```
Мы уже встречали байты со 2-ого по 9-ый и знаем, что они соответствуют строке "srv_user". Первый же байт со значением 13 не меняется и наш бот может его игнорировать.

Когда клиент подтверждает включение режима "Manual Edit", он отвечает двумя пакетам с номерами 45 и 47 на иллюстрации 4-20. Их данные следующие:
```
01 00 00 00
17
```
При получение запроса сервера 0a, наш бот должен повторить этот ответ без изменений.

![Включение режима "Manual Edit"](Figure_4-20.png)

**Иллюстрация 4-20.** *Включение режима "Manual Edit" сервером*

Последнее действие, чтобы начать игру, - это включение часов. Ему соответствует отправка сервером двух пакетов с номерами 54 и 56 на иллюстрации 4-21. Данные этих пакетов следующие:
```
02 00 00 00
22 00
```
Клиент не отвечает на эти пакеты, поэтому наш бот может их просто проигнорировать.

Все последующие пакеты (начиная с номера 58) содержат ходы игроков. Первыми ходят белые фигуры. В нашем случае это игрок на стороне сервера. Каждому ходу соответствует два пакета с данными в Wireshark логе.

Если белые сделают первый ход e2-e4, сервер передаст два пакета со следующими данными:
```
07 00 00 00
00 00 06 04 04 04 00
```
Попробуйте сделать еще несколько ходов за обе стороны. Вы заметите, что данные первого пакета не меняются. Это значит, что они константны. Таким образом если бот получает пакет, начинающийся с 07, следующий пакет будет содержать ход оппонента.

![Запуск игровых часов сервером](Figure_4-21.png)

**Иллюстрация 4-21.** *Запуск игровых часов сервером*

Мы подошли к самому важному вопросу: как декодировать данные о ходе игрока? Представим себе шахматную доску. В ней всего 64 поля (8 по вертикали и 8 по горизонтали). По вертикали поля нумеруются цифрами от 1 до 8, а по горизонтали - латинскими буквами от a до h. Очевидно, что ход каждого игрока должен содержать информацию о текущем поле досик, в котором находится фигура, и поле, куда фигура перемещается.

Вернёмся к перехваченному пакету с информацией о ходе. Его данные содержат четыре ненулевых байта. Попробуйте сделать несколько ходов. Первые два и последний байт всегда равны нулю, а остальные - нет. Следовательно начальное и конечно поля хода  фигуры должны быть закодированы в этих четырёх байтах. То есть каждое поле описано двумя байтами.

Предположим, что первым указывается текущее поле фигуры. В нашем случае клетке "e2" соответствуют два байта 06 04, а "e4" - 04 04. Обратите внимание, что буква обоих полей одинакова. Исходя из этого предположим, что байт 04 соответствует букве "e".

Теперь сделайте ход пешкой на поле с другой буквой, чтобы подтвердить наше предположение. В случае хода "d2-d4" данные соответствующего пакета выглядят следующим образом:
```
00 00 06 03 04 03 00
```
Следовательно букве "d" соответствует байт 03. Логично предположить, что коды букв идут последовательно один за другим. Это позволяет нам составить таблицу 4-3 соответствия буков и их кодов.

**Таблица 4-3.** *Коды букв полей шахматной доски*

| Байт | Буква |
| --- | --- |
| 00 | a |
| 01 | b |
| 02 | c |
| 03 | d |
| 04 | e |
| 05 | f |
| 06 | g |
| 07 | h |

Как мы получили эту таблицу? Начнём заполнять левый её столбец с уже известных нам байтов 03 и 04, которые соответствуют буквам "d" и "e". Затем продолжим вверх значения в левом столбце: 02, 01, 00. Точно так же продолжем вверх значения в правом стобце: "c", "b", "a". Аналогично заполним строки таблицы после байта 04.

Составим похожую таблицу для номеров клеток. Мы уже знаем, что байт 06 соответствует номеру 2, а 04 - номеру 4. Поместим эти значения в таблицу и заполним остальные её строки. Вы должны получить таблицу 4-4.

Проверьте наши выводы, делая различные игровые ходы. По номерам и буквам клеток вы легко сможете предсказать данные пакетов, которые отправляют друг другу клиент и сервер.

Теперь мы знаем об игровом протоколе всё необходимое, чтобы написать бота.

**Таблица 4-4.** *Коды номеров полей шахматной доски*

| Байт | Номер |
| --- | --- |
| 07 | 1 |
| 06 | 2 |
| 05 | 3 |
| 04 | 4 |
| 03 | 5 |
| 02 | 6 |
| 01 | 7 |
| 00 | 8 |

## Реализация бота

### Начало игры

Первая задача, с которой должен справиться наш бот, - подключиться к серверу и начать игру в качестве клиента. Мы уже рассмотрели все пакеты которыми обмениваются обе стороны на этом этапе. Теперь реализуем скрипт, который отвечает на запросы сервера точно так же, как клиент NetChess. Результат приведён в листинге 4-5.

**Листинг 4-5.** *Скрипт `StartGameBot.py`*
```Python
import socket

def main():
  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)
  s.settimeout(60)
  s.connect(("127.0.0.1", 55555))

  # получить от сервера подтверждение соединения
  s.recv(1024, socket.MSG_WAITALL)
  s.recv(1024, socket.MSG_WAITALL)

  # отправить имя пользователя на стороне клиента
  s.send(bytes([0x09, 0, 0, 0]))
  s.send(bytes([0x0C, 0x63, 0x6C, 0x5F, 0x75, 0x73, 0x65, 0x72, 0x00]))

  # получить от сервера уведомление о включении режима "Manual Edit"
  s.recv(1024, socket.MSG_WAITALL)
  s.recv(1024, socket.MSG_WAITALL)

  # отправить подтверждение клиентом режима "Manual Edit"
  s.send(bytes([0x01, 0, 0, 0]))
  s.send(bytes([0x17]))

  # получить от сервера уведомление о включении игровых часов
  s.recv(1024, socket.MSG_WAITALL)
  s.recv(1024, socket.MSG_WAITALL)

  s.close()

if __name__ == '__main__':
  main()
```
---
Некоторые строки скрипта `StartGameBot.py` начинаются со знака решётки (#). Это комментарии, а не код.
---
Первые три строчки функции `main` устанваливают TCP соединение. Обратите внимание, что мы установили таймаут на 60 секунд. В течении этого времени вызовы `recv` ожидают пакеты от сервера. За это время игрок на стороне сервера должен успеть сделать свой ход.

Затем идут два вызова `recv`, чтобы получить подтверждение от сервера об успешном соединении. В этих пакетах указано имя пользователя на стороне сервера и цвет его фигур. Эти данные не интересны для бота, поэтому он их игнорирует.

Почему цвет фигур оппонента не важен для бота? На самом деле вопрос стоит сформулировать по-другому: сможет ли бот сыграть любым цветом? На самом деле не сможет. Наш бот отвечает на ходы игрока зеркально, то есть повторяет их пока может. Следовательно, он может сделать свой ход только после человека. То есть бот играет только за чёрных.

Получив подтверждение от сервера, бот отправляет имя пользователя на стороне клиента. Именем служит строка "cl_user", которая в виде байтового массива представляется следующим образом:
```
63 6C 5F 75 73 65 72
```
Перед именем пользователя бот добавляет обязательную константу 0c.

Следующий шаг процедуры начала игры - включение режима "Manual Edit". Получив уведомление от сервера, бот отправляет пакет с подтверждением включения этого режима.

Последнее действия сервера перед тем, как пользователь и бот начнут делать ходы, - запуск игровых часов. Уведомление об этом не требует ответа.

Можем ли мы удалить лишние `recv` вызовы из скрипта `StartGameBot.py`? В процессе начала игры бот игнорирует практически всю информацию от сервера: выбранный пользователем цвет фигур, его имя, код режима "Manual Edit". Всё что на самом деле нужно боту - это информация о ходах игрока. Мы могли бы удалить лишние вызовы `recv`, но тогда возникает проблема. Как бот узнает, в какой момент ему следует посылать подтверждения на действия пользователя на стороне сервера и пакеты со своими ходами? Можно останавливать выполнение скрипта с помощью функции `sleep`. Но тогда возникает вопрос: в какой момент боту следует просыпаться и совершает свой ход? Ответ зависит от действий игрока. На один ход ему может понадобиться 15 секунд, а на другой минута. Следовательно мы не можем точно определить моменты времени, когда бот должен ходить. Получается, что единственный способ для бота вовремя реагировать на действия игрока - это получать все пакеты от сервера с помощью вызова `recv`. Зная заранее последовательность действии для начала игры, бот может точно установить момент получения пакета с первым ходом пользователя.

### Повторение ходов игрока

Мы рассмотрели часть скрипта бота, которая отвечает за процесс начала игры. Следующий шаг - реализовать алгоритм для зеркального повторения ходов пользователя.

Как правильно выбрать фигуру для хода и её новое поле? Рассмотрим несколько примеров зеркальных ходов в таблице 4-5.

**Таблица 4-5.** *Зеркальные ходы*

| Ход | Байты данных | Зеркальный ход | Байты данных |
| --- | --- | --- | --- |
| e2 - e4 | 00 00 06 04 04 04 00 | e7 - e5 | 00 00 01 04 03 04 00 |
| d2 - d4 | 00 00 06 03 04 03 00 | d7 - d5 | 00 00 01 03 03 03 00 |
| b1 - c3 | 00 00 07 01 05 02 00 | b8 - c6 | 00 00 00 01 02 02 00 |

Первый ход в таблице "e2 - e4" делает белая пешка. Зеркальный ход чёрной пешкой "e7 - e5". Следующую пару ходов делают пешки на линии "d". Затем идёт ход белого коня "b1 - c3". Когда вы прочитаете соответствующий ему зеркальный ход чёрных, вы должны заметить некоторые закономерности в байтах данных.

Первая закономерность относится к буквам клеток. Поля зеркального хода имеют те же буквенные обозначения, что и хода белых. Это правило выполняется для всех фигурых.

Вторая закономерность поможет рассчитать номера клеток. Внимательно помотрите на следующие пары чисел:

* 6 и 1
* 4 и 3
* 7 и 0
* 5 и 2

Как из правого числа получить левое? Для этого надо вычести его из семи. Это правило выполняется для каждой из рассмотренных пар.

Теперь реализуем алгоритм расчёта зеркальных ходов. Результат приведён на листинге 4-6.

**Листинг 4-6.** *Алгоритм расчёта зеркальных ходов*
```Python
  while(1):
    # получить от сервера ход игрока
    s.recv(1024, socket.MSG_WAITALL)
    data = s.recv(1024, socket.MSG_WAITALL)
    print(data)

    start_num = 7 - data[2]
    end_num = 7 - data[4]

    # отправить ход бота
    s.send(bytes([0x07, 0, 0, 0]))
    s.send(bytes([0, 0, start_num, data[3], end_num, data[5], 0x00]))
```
Алгоритм работает в бесконечном цикле `while`. В нём мы получаем пакет от сервера с ходом игрока и сохраняем его данные в переменной `data`. С помощью функции `print` выводим эти данные на консоль. Далее вычисляем номер клетки в которой находится фигура чёрных, которая должна сделать ход. Для расчёта используем третий байт массива `data` (с индексом 2). Он соответствует номеру начального поля белой фигуры. Результат сохраняем в переменной `start_num`. Аналогично вычисляем номер поля, куда фигура должна походить. Результат сохраняем в переменной `end_num`. После этого отправляем два пакета с ходом бота. Первый пакет содержит константные данные (07 00 00 00). Второй - рассчитанные номера клеток и такие же буквы, как в ходе игрока. Они хранятся в байтах с индексами 3 и 5 массива `data`.

Полная реализация бота доступна в файле `MirrorBot.py` из архива примеров к этой книге. В нём объединён код из листингов 4-5 и 4-6.

Чтобы протестировать бота выполните следующие действия:

1. Запустите приложение NetChess.

2. Настройте его на работу в режиме сервера.

3. Запустите скрипт `MirrorBot.py`.

4. В приложении включите режим "Manual Edit".

5. Запустите игровые часы.

6. Сделайте первый ход за белых.

Бот будет повторять каждый ваш ход до тех пор, пока это позволяют правила игры. Если такой ход невозможен, бот не будет ничего делать.
